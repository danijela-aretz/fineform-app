
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model StaffProfile
 * 
 */
export type StaffProfile = $Result.DefaultSelection<Prisma.$StaffProfilePayload>
/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model AccountUser
 * 
 */
export type AccountUser = $Result.DefaultSelection<Prisma.$AccountUserPayload>
/**
 * Model ClientEntity
 * 
 */
export type ClientEntity = $Result.DefaultSelection<Prisma.$ClientEntityPayload>
/**
 * Model EntityTaxYear
 * 
 */
export type EntityTaxYear = $Result.DefaultSelection<Prisma.$EntityTaxYearPayload>
/**
 * Model ClientAcl
 * 
 */
export type ClientAcl = $Result.DefaultSelection<Prisma.$ClientAclPayload>
/**
 * Model ClientStaffPermission
 * 
 */
export type ClientStaffPermission = $Result.DefaultSelection<Prisma.$ClientStaffPermissionPayload>
/**
 * Model ClientStaffAssignment
 * 
 */
export type ClientStaffAssignment = $Result.DefaultSelection<Prisma.$ClientStaffAssignmentPayload>
/**
 * Model Folder
 * 
 */
export type Folder = $Result.DefaultSelection<Prisma.$FolderPayload>
/**
 * Model FolderAcl
 * 
 */
export type FolderAcl = $Result.DefaultSelection<Prisma.$FolderAclPayload>
/**
 * Model Document
 * 
 */
export type Document = $Result.DefaultSelection<Prisma.$DocumentPayload>
/**
 * Model ChecklistItem
 * 
 */
export type ChecklistItem = $Result.DefaultSelection<Prisma.$ChecklistItemPayload>
/**
 * Model ChecklistItemFile
 * 
 */
export type ChecklistItemFile = $Result.DefaultSelection<Prisma.$ChecklistItemFilePayload>
/**
 * Model QuestionnaireSection
 * 
 */
export type QuestionnaireSection = $Result.DefaultSelection<Prisma.$QuestionnaireSectionPayload>
/**
 * Model QuestionnaireQuestion
 * 
 */
export type QuestionnaireQuestion = $Result.DefaultSelection<Prisma.$QuestionnaireQuestionPayload>
/**
 * Model QuestionnaireAnswer
 * 
 */
export type QuestionnaireAnswer = $Result.DefaultSelection<Prisma.$QuestionnaireAnswerPayload>
/**
 * Model EngagementSignature
 * 
 */
export type EngagementSignature = $Result.DefaultSelection<Prisma.$EngagementSignaturePayload>
/**
 * Model EfileAuthorization
 * 
 */
export type EfileAuthorization = $Result.DefaultSelection<Prisma.$EfileAuthorizationPayload>
/**
 * Model MessageThread
 * 
 */
export type MessageThread = $Result.DefaultSelection<Prisma.$MessageThreadPayload>
/**
 * Model ThreadParticipant
 * 
 */
export type ThreadParticipant = $Result.DefaultSelection<Prisma.$ThreadParticipantPayload>
/**
 * Model Message
 * 
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model ReminderState
 * 
 */
export type ReminderState = $Result.DefaultSelection<Prisma.$ReminderStatePayload>
/**
 * Model StatusAuditLog
 * 
 */
export type StatusAuditLog = $Result.DefaultSelection<Prisma.$StatusAuditLogPayload>
/**
 * Model PermissionAuditLog
 * 
 */
export type PermissionAuditLog = $Result.DefaultSelection<Prisma.$PermissionAuditLogPayload>
/**
 * Model DocumentEvent
 * 
 */
export type DocumentEvent = $Result.DefaultSelection<Prisma.$DocumentEventPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserType: {
  STAFF: 'STAFF',
  CLIENT: 'CLIENT'
};

export type UserType = (typeof UserType)[keyof typeof UserType]


export const StaffRole: {
  SUPER_ADMIN: 'SUPER_ADMIN',
  ADMIN: 'ADMIN',
  STAFF: 'STAFF'
};

export type StaffRole = (typeof StaffRole)[keyof typeof StaffRole]


export const ClientRole: {
  ADMIN: 'ADMIN',
  ASSISTANT: 'ASSISTANT'
};

export type ClientRole = (typeof ClientRole)[keyof typeof ClientRole]


export const EntityType: {
  HOUSEHOLD_1040: 'HOUSEHOLD_1040',
  LLC: 'LLC',
  S_CORP: 'S_CORP',
  C_CORP: 'C_CORP',
  PARTNERSHIP: 'PARTNERSHIP',
  SOLE_PROPRIETORSHIP: 'SOLE_PROPRIETORSHIP',
  TRUST: 'TRUST',
  ESTATE: 'ESTATE',
  OTHER: 'OTHER'
};

export type EntityType = (typeof EntityType)[keyof typeof EntityType]


export const InviteStatus: {
  NOT_SENT: 'NOT_SENT',
  QUEUED: 'QUEUED',
  SENT: 'SENT',
  FAILED: 'FAILED'
};

export type InviteStatus = (typeof InviteStatus)[keyof typeof InviteStatus]


export const EngagementStatus: {
  NOT_STARTED: 'NOT_STARTED',
  PARTIALLY_SIGNED: 'PARTIALLY_SIGNED',
  FULLY_SIGNED: 'FULLY_SIGNED'
};

export type EngagementStatus = (typeof EngagementStatus)[keyof typeof EngagementStatus]


export const ConfirmationStatus: {
  NOT_SIGNED: 'NOT_SIGNED',
  SIGNED: 'SIGNED'
};

export type ConfirmationStatus = (typeof ConfirmationStatus)[keyof typeof ConfirmationStatus]


export const QuestionnaireStatus: {
  NOT_STARTED: 'NOT_STARTED',
  IN_PROGRESS: 'IN_PROGRESS',
  COMPLETED: 'COMPLETED'
};

export type QuestionnaireStatus = (typeof QuestionnaireStatus)[keyof typeof QuestionnaireStatus]


export const IdStatus: {
  INVALID: 'INVALID',
  VALID: 'VALID',
  EXPIRED: 'EXPIRED'
};

export type IdStatus = (typeof IdStatus)[keyof typeof IdStatus]


export const InternalStatus: {
  INVITED: 'INVITED',
  ENGAGED: 'ENGAGED',
  COLLECTING_DOCS: 'COLLECTING_DOCS',
  AWAITING_CONFIRMATION: 'AWAITING_CONFIRMATION',
  READY_FOR_PREP: 'READY_FOR_PREP',
  IN_PREP: 'IN_PREP',
  AWAITING_EFILE_AUTH: 'AWAITING_EFILE_AUTH',
  FILED: 'FILED'
};

export type InternalStatus = (typeof InternalStatus)[keyof typeof InternalStatus]


export const ChecklistItemStatus: {
  PENDING: 'PENDING',
  RECEIVED: 'RECEIVED',
  NOT_APPLICABLE: 'NOT_APPLICABLE'
};

export type ChecklistItemStatus = (typeof ChecklistItemStatus)[keyof typeof ChecklistItemStatus]


export const QuestionType: {
  TEXT: 'TEXT',
  TEXTAREA: 'TEXTAREA',
  NUMBER: 'NUMBER',
  DATE: 'DATE',
  SELECT: 'SELECT',
  MULTI_SELECT: 'MULTI_SELECT',
  BOOLEAN: 'BOOLEAN',
  FILE: 'FILE'
};

export type QuestionType = (typeof QuestionType)[keyof typeof QuestionType]


export const ReminderType: {
  DOCUMENTS: 'DOCUMENTS',
  QUESTIONNAIRE: 'QUESTIONNAIRE',
  ID: 'ID'
};

export type ReminderType = (typeof ReminderType)[keyof typeof ReminderType]


export const DocumentEventType: {
  UPLOADED: 'UPLOADED',
  REPLACED: 'REPLACED',
  MARKED_NOT_APPLICABLE: 'MARKED_NOT_APPLICABLE',
  CONFIRMATION_SIGNED: 'CONFIRMATION_SIGNED',
  EXTENSION_REQUESTED: 'EXTENSION_REQUESTED',
  EXTENSION_FILED: 'EXTENSION_FILED',
  EFILE_AUTH_REQUESTED: 'EFILE_AUTH_REQUESTED',
  EFILE_AUTH_SIGNED: 'EFILE_AUTH_SIGNED'
};

export type DocumentEventType = (typeof DocumentEventType)[keyof typeof DocumentEventType]

}

export type UserType = $Enums.UserType

export const UserType: typeof $Enums.UserType

export type StaffRole = $Enums.StaffRole

export const StaffRole: typeof $Enums.StaffRole

export type ClientRole = $Enums.ClientRole

export const ClientRole: typeof $Enums.ClientRole

export type EntityType = $Enums.EntityType

export const EntityType: typeof $Enums.EntityType

export type InviteStatus = $Enums.InviteStatus

export const InviteStatus: typeof $Enums.InviteStatus

export type EngagementStatus = $Enums.EngagementStatus

export const EngagementStatus: typeof $Enums.EngagementStatus

export type ConfirmationStatus = $Enums.ConfirmationStatus

export const ConfirmationStatus: typeof $Enums.ConfirmationStatus

export type QuestionnaireStatus = $Enums.QuestionnaireStatus

export const QuestionnaireStatus: typeof $Enums.QuestionnaireStatus

export type IdStatus = $Enums.IdStatus

export const IdStatus: typeof $Enums.IdStatus

export type InternalStatus = $Enums.InternalStatus

export const InternalStatus: typeof $Enums.InternalStatus

export type ChecklistItemStatus = $Enums.ChecklistItemStatus

export const ChecklistItemStatus: typeof $Enums.ChecklistItemStatus

export type QuestionType = $Enums.QuestionType

export const QuestionType: typeof $Enums.QuestionType

export type ReminderType = $Enums.ReminderType

export const ReminderType: typeof $Enums.ReminderType

export type DocumentEventType = $Enums.DocumentEventType

export const DocumentEventType: typeof $Enums.DocumentEventType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.staffProfile`: Exposes CRUD operations for the **StaffProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StaffProfiles
    * const staffProfiles = await prisma.staffProfile.findMany()
    * ```
    */
  get staffProfile(): Prisma.StaffProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accountUser`: Exposes CRUD operations for the **AccountUser** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccountUsers
    * const accountUsers = await prisma.accountUser.findMany()
    * ```
    */
  get accountUser(): Prisma.AccountUserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientEntity`: Exposes CRUD operations for the **ClientEntity** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientEntities
    * const clientEntities = await prisma.clientEntity.findMany()
    * ```
    */
  get clientEntity(): Prisma.ClientEntityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.entityTaxYear`: Exposes CRUD operations for the **EntityTaxYear** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EntityTaxYears
    * const entityTaxYears = await prisma.entityTaxYear.findMany()
    * ```
    */
  get entityTaxYear(): Prisma.EntityTaxYearDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientAcl`: Exposes CRUD operations for the **ClientAcl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientAcls
    * const clientAcls = await prisma.clientAcl.findMany()
    * ```
    */
  get clientAcl(): Prisma.ClientAclDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientStaffPermission`: Exposes CRUD operations for the **ClientStaffPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientStaffPermissions
    * const clientStaffPermissions = await prisma.clientStaffPermission.findMany()
    * ```
    */
  get clientStaffPermission(): Prisma.ClientStaffPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.clientStaffAssignment`: Exposes CRUD operations for the **ClientStaffAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClientStaffAssignments
    * const clientStaffAssignments = await prisma.clientStaffAssignment.findMany()
    * ```
    */
  get clientStaffAssignment(): Prisma.ClientStaffAssignmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folder`: Exposes CRUD operations for the **Folder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Folders
    * const folders = await prisma.folder.findMany()
    * ```
    */
  get folder(): Prisma.FolderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.folderAcl`: Exposes CRUD operations for the **FolderAcl** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FolderAcls
    * const folderAcls = await prisma.folderAcl.findMany()
    * ```
    */
  get folderAcl(): Prisma.FolderAclDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.document`: Exposes CRUD operations for the **Document** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documents
    * const documents = await prisma.document.findMany()
    * ```
    */
  get document(): Prisma.DocumentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checklistItem`: Exposes CRUD operations for the **ChecklistItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChecklistItems
    * const checklistItems = await prisma.checklistItem.findMany()
    * ```
    */
  get checklistItem(): Prisma.ChecklistItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checklistItemFile`: Exposes CRUD operations for the **ChecklistItemFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChecklistItemFiles
    * const checklistItemFiles = await prisma.checklistItemFile.findMany()
    * ```
    */
  get checklistItemFile(): Prisma.ChecklistItemFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionnaireSection`: Exposes CRUD operations for the **QuestionnaireSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionnaireSections
    * const questionnaireSections = await prisma.questionnaireSection.findMany()
    * ```
    */
  get questionnaireSection(): Prisma.QuestionnaireSectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionnaireQuestion`: Exposes CRUD operations for the **QuestionnaireQuestion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionnaireQuestions
    * const questionnaireQuestions = await prisma.questionnaireQuestion.findMany()
    * ```
    */
  get questionnaireQuestion(): Prisma.QuestionnaireQuestionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.questionnaireAnswer`: Exposes CRUD operations for the **QuestionnaireAnswer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more QuestionnaireAnswers
    * const questionnaireAnswers = await prisma.questionnaireAnswer.findMany()
    * ```
    */
  get questionnaireAnswer(): Prisma.QuestionnaireAnswerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.engagementSignature`: Exposes CRUD operations for the **EngagementSignature** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EngagementSignatures
    * const engagementSignatures = await prisma.engagementSignature.findMany()
    * ```
    */
  get engagementSignature(): Prisma.EngagementSignatureDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.efileAuthorization`: Exposes CRUD operations for the **EfileAuthorization** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EfileAuthorizations
    * const efileAuthorizations = await prisma.efileAuthorization.findMany()
    * ```
    */
  get efileAuthorization(): Prisma.EfileAuthorizationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageThread`: Exposes CRUD operations for the **MessageThread** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageThreads
    * const messageThreads = await prisma.messageThread.findMany()
    * ```
    */
  get messageThread(): Prisma.MessageThreadDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.threadParticipant`: Exposes CRUD operations for the **ThreadParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ThreadParticipants
    * const threadParticipants = await prisma.threadParticipant.findMany()
    * ```
    */
  get threadParticipant(): Prisma.ThreadParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reminderState`: Exposes CRUD operations for the **ReminderState** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReminderStates
    * const reminderStates = await prisma.reminderState.findMany()
    * ```
    */
  get reminderState(): Prisma.ReminderStateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.statusAuditLog`: Exposes CRUD operations for the **StatusAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StatusAuditLogs
    * const statusAuditLogs = await prisma.statusAuditLog.findMany()
    * ```
    */
  get statusAuditLog(): Prisma.StatusAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissionAuditLog`: Exposes CRUD operations for the **PermissionAuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PermissionAuditLogs
    * const permissionAuditLogs = await prisma.permissionAuditLog.findMany()
    * ```
    */
  get permissionAuditLog(): Prisma.PermissionAuditLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.documentEvent`: Exposes CRUD operations for the **DocumentEvent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DocumentEvents
    * const documentEvents = await prisma.documentEvent.findMany()
    * ```
    */
  get documentEvent(): Prisma.DocumentEventDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    StaffProfile: 'StaffProfile',
    Account: 'Account',
    AccountUser: 'AccountUser',
    ClientEntity: 'ClientEntity',
    EntityTaxYear: 'EntityTaxYear',
    ClientAcl: 'ClientAcl',
    ClientStaffPermission: 'ClientStaffPermission',
    ClientStaffAssignment: 'ClientStaffAssignment',
    Folder: 'Folder',
    FolderAcl: 'FolderAcl',
    Document: 'Document',
    ChecklistItem: 'ChecklistItem',
    ChecklistItemFile: 'ChecklistItemFile',
    QuestionnaireSection: 'QuestionnaireSection',
    QuestionnaireQuestion: 'QuestionnaireQuestion',
    QuestionnaireAnswer: 'QuestionnaireAnswer',
    EngagementSignature: 'EngagementSignature',
    EfileAuthorization: 'EfileAuthorization',
    MessageThread: 'MessageThread',
    ThreadParticipant: 'ThreadParticipant',
    Message: 'Message',
    ReminderState: 'ReminderState',
    StatusAuditLog: 'StatusAuditLog',
    PermissionAuditLog: 'PermissionAuditLog',
    DocumentEvent: 'DocumentEvent'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "profile" | "staffProfile" | "account" | "accountUser" | "clientEntity" | "entityTaxYear" | "clientAcl" | "clientStaffPermission" | "clientStaffAssignment" | "folder" | "folderAcl" | "document" | "checklistItem" | "checklistItemFile" | "questionnaireSection" | "questionnaireQuestion" | "questionnaireAnswer" | "engagementSignature" | "efileAuthorization" | "messageThread" | "threadParticipant" | "message" | "reminderState" | "statusAuditLog" | "permissionAuditLog" | "documentEvent"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      StaffProfile: {
        payload: Prisma.$StaffProfilePayload<ExtArgs>
        fields: Prisma.StaffProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StaffProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StaffProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          findFirst: {
            args: Prisma.StaffProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StaffProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          findMany: {
            args: Prisma.StaffProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          create: {
            args: Prisma.StaffProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          createMany: {
            args: Prisma.StaffProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StaffProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          delete: {
            args: Prisma.StaffProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          update: {
            args: Prisma.StaffProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          deleteMany: {
            args: Prisma.StaffProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StaffProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StaffProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>[]
          }
          upsert: {
            args: Prisma.StaffProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StaffProfilePayload>
          }
          aggregate: {
            args: Prisma.StaffProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStaffProfile>
          }
          groupBy: {
            args: Prisma.StaffProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<StaffProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.StaffProfileCountArgs<ExtArgs>
            result: $Utils.Optional<StaffProfileCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      AccountUser: {
        payload: Prisma.$AccountUserPayload<ExtArgs>
        fields: Prisma.AccountUserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountUserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountUserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>
          }
          findFirst: {
            args: Prisma.AccountUserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountUserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>
          }
          findMany: {
            args: Prisma.AccountUserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>[]
          }
          create: {
            args: Prisma.AccountUserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>
          }
          createMany: {
            args: Prisma.AccountUserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountUserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>[]
          }
          delete: {
            args: Prisma.AccountUserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>
          }
          update: {
            args: Prisma.AccountUserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>
          }
          deleteMany: {
            args: Prisma.AccountUserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>[]
          }
          upsert: {
            args: Prisma.AccountUserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountUserPayload>
          }
          aggregate: {
            args: Prisma.AccountUserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccountUser>
          }
          groupBy: {
            args: Prisma.AccountUserGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountUserGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountUserCountArgs<ExtArgs>
            result: $Utils.Optional<AccountUserCountAggregateOutputType> | number
          }
        }
      }
      ClientEntity: {
        payload: Prisma.$ClientEntityPayload<ExtArgs>
        fields: Prisma.ClientEntityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientEntityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientEntityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>
          }
          findFirst: {
            args: Prisma.ClientEntityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientEntityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>
          }
          findMany: {
            args: Prisma.ClientEntityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>[]
          }
          create: {
            args: Prisma.ClientEntityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>
          }
          createMany: {
            args: Prisma.ClientEntityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientEntityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>[]
          }
          delete: {
            args: Prisma.ClientEntityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>
          }
          update: {
            args: Prisma.ClientEntityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>
          }
          deleteMany: {
            args: Prisma.ClientEntityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientEntityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientEntityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>[]
          }
          upsert: {
            args: Prisma.ClientEntityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientEntityPayload>
          }
          aggregate: {
            args: Prisma.ClientEntityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientEntity>
          }
          groupBy: {
            args: Prisma.ClientEntityGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientEntityGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientEntityCountArgs<ExtArgs>
            result: $Utils.Optional<ClientEntityCountAggregateOutputType> | number
          }
        }
      }
      EntityTaxYear: {
        payload: Prisma.$EntityTaxYearPayload<ExtArgs>
        fields: Prisma.EntityTaxYearFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EntityTaxYearFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EntityTaxYearFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>
          }
          findFirst: {
            args: Prisma.EntityTaxYearFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EntityTaxYearFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>
          }
          findMany: {
            args: Prisma.EntityTaxYearFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>[]
          }
          create: {
            args: Prisma.EntityTaxYearCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>
          }
          createMany: {
            args: Prisma.EntityTaxYearCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EntityTaxYearCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>[]
          }
          delete: {
            args: Prisma.EntityTaxYearDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>
          }
          update: {
            args: Prisma.EntityTaxYearUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>
          }
          deleteMany: {
            args: Prisma.EntityTaxYearDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EntityTaxYearUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EntityTaxYearUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>[]
          }
          upsert: {
            args: Prisma.EntityTaxYearUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EntityTaxYearPayload>
          }
          aggregate: {
            args: Prisma.EntityTaxYearAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEntityTaxYear>
          }
          groupBy: {
            args: Prisma.EntityTaxYearGroupByArgs<ExtArgs>
            result: $Utils.Optional<EntityTaxYearGroupByOutputType>[]
          }
          count: {
            args: Prisma.EntityTaxYearCountArgs<ExtArgs>
            result: $Utils.Optional<EntityTaxYearCountAggregateOutputType> | number
          }
        }
      }
      ClientAcl: {
        payload: Prisma.$ClientAclPayload<ExtArgs>
        fields: Prisma.ClientAclFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientAclFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientAclFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>
          }
          findFirst: {
            args: Prisma.ClientAclFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientAclFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>
          }
          findMany: {
            args: Prisma.ClientAclFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>[]
          }
          create: {
            args: Prisma.ClientAclCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>
          }
          createMany: {
            args: Prisma.ClientAclCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientAclCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>[]
          }
          delete: {
            args: Prisma.ClientAclDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>
          }
          update: {
            args: Prisma.ClientAclUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>
          }
          deleteMany: {
            args: Prisma.ClientAclDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientAclUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientAclUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>[]
          }
          upsert: {
            args: Prisma.ClientAclUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientAclPayload>
          }
          aggregate: {
            args: Prisma.ClientAclAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientAcl>
          }
          groupBy: {
            args: Prisma.ClientAclGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientAclGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientAclCountArgs<ExtArgs>
            result: $Utils.Optional<ClientAclCountAggregateOutputType> | number
          }
        }
      }
      ClientStaffPermission: {
        payload: Prisma.$ClientStaffPermissionPayload<ExtArgs>
        fields: Prisma.ClientStaffPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientStaffPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientStaffPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>
          }
          findFirst: {
            args: Prisma.ClientStaffPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientStaffPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>
          }
          findMany: {
            args: Prisma.ClientStaffPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>[]
          }
          create: {
            args: Prisma.ClientStaffPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>
          }
          createMany: {
            args: Prisma.ClientStaffPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientStaffPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>[]
          }
          delete: {
            args: Prisma.ClientStaffPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>
          }
          update: {
            args: Prisma.ClientStaffPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>
          }
          deleteMany: {
            args: Prisma.ClientStaffPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientStaffPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientStaffPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>[]
          }
          upsert: {
            args: Prisma.ClientStaffPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffPermissionPayload>
          }
          aggregate: {
            args: Prisma.ClientStaffPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientStaffPermission>
          }
          groupBy: {
            args: Prisma.ClientStaffPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientStaffPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientStaffPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<ClientStaffPermissionCountAggregateOutputType> | number
          }
        }
      }
      ClientStaffAssignment: {
        payload: Prisma.$ClientStaffAssignmentPayload<ExtArgs>
        fields: Prisma.ClientStaffAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClientStaffAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClientStaffAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ClientStaffAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClientStaffAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>
          }
          findMany: {
            args: Prisma.ClientStaffAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>[]
          }
          create: {
            args: Prisma.ClientStaffAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>
          }
          createMany: {
            args: Prisma.ClientStaffAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClientStaffAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ClientStaffAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>
          }
          update: {
            args: Prisma.ClientStaffAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ClientStaffAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClientStaffAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClientStaffAssignmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>[]
          }
          upsert: {
            args: Prisma.ClientStaffAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClientStaffAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ClientStaffAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClientStaffAssignment>
          }
          groupBy: {
            args: Prisma.ClientStaffAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClientStaffAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClientStaffAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ClientStaffAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Folder: {
        payload: Prisma.$FolderPayload<ExtArgs>
        fields: Prisma.FolderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findFirst: {
            args: Prisma.FolderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          findMany: {
            args: Prisma.FolderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          create: {
            args: Prisma.FolderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          createMany: {
            args: Prisma.FolderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          delete: {
            args: Prisma.FolderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          update: {
            args: Prisma.FolderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          deleteMany: {
            args: Prisma.FolderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>[]
          }
          upsert: {
            args: Prisma.FolderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderPayload>
          }
          aggregate: {
            args: Prisma.FolderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolder>
          }
          groupBy: {
            args: Prisma.FolderGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderCountArgs<ExtArgs>
            result: $Utils.Optional<FolderCountAggregateOutputType> | number
          }
        }
      }
      FolderAcl: {
        payload: Prisma.$FolderAclPayload<ExtArgs>
        fields: Prisma.FolderAclFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FolderAclFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FolderAclFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>
          }
          findFirst: {
            args: Prisma.FolderAclFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FolderAclFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>
          }
          findMany: {
            args: Prisma.FolderAclFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>[]
          }
          create: {
            args: Prisma.FolderAclCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>
          }
          createMany: {
            args: Prisma.FolderAclCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FolderAclCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>[]
          }
          delete: {
            args: Prisma.FolderAclDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>
          }
          update: {
            args: Prisma.FolderAclUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>
          }
          deleteMany: {
            args: Prisma.FolderAclDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FolderAclUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FolderAclUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>[]
          }
          upsert: {
            args: Prisma.FolderAclUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FolderAclPayload>
          }
          aggregate: {
            args: Prisma.FolderAclAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFolderAcl>
          }
          groupBy: {
            args: Prisma.FolderAclGroupByArgs<ExtArgs>
            result: $Utils.Optional<FolderAclGroupByOutputType>[]
          }
          count: {
            args: Prisma.FolderAclCountArgs<ExtArgs>
            result: $Utils.Optional<FolderAclCountAggregateOutputType> | number
          }
        }
      }
      Document: {
        payload: Prisma.$DocumentPayload<ExtArgs>
        fields: Prisma.DocumentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findFirst: {
            args: Prisma.DocumentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          findMany: {
            args: Prisma.DocumentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          create: {
            args: Prisma.DocumentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          createMany: {
            args: Prisma.DocumentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          delete: {
            args: Prisma.DocumentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          update: {
            args: Prisma.DocumentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          deleteMany: {
            args: Prisma.DocumentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>[]
          }
          upsert: {
            args: Prisma.DocumentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentPayload>
          }
          aggregate: {
            args: Prisma.DocumentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocument>
          }
          groupBy: {
            args: Prisma.DocumentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentCountAggregateOutputType> | number
          }
        }
      }
      ChecklistItem: {
        payload: Prisma.$ChecklistItemPayload<ExtArgs>
        fields: Prisma.ChecklistItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChecklistItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChecklistItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          findFirst: {
            args: Prisma.ChecklistItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChecklistItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          findMany: {
            args: Prisma.ChecklistItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>[]
          }
          create: {
            args: Prisma.ChecklistItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          createMany: {
            args: Prisma.ChecklistItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChecklistItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>[]
          }
          delete: {
            args: Prisma.ChecklistItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          update: {
            args: Prisma.ChecklistItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          deleteMany: {
            args: Prisma.ChecklistItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChecklistItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChecklistItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>[]
          }
          upsert: {
            args: Prisma.ChecklistItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemPayload>
          }
          aggregate: {
            args: Prisma.ChecklistItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChecklistItem>
          }
          groupBy: {
            args: Prisma.ChecklistItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChecklistItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChecklistItemCountArgs<ExtArgs>
            result: $Utils.Optional<ChecklistItemCountAggregateOutputType> | number
          }
        }
      }
      ChecklistItemFile: {
        payload: Prisma.$ChecklistItemFilePayload<ExtArgs>
        fields: Prisma.ChecklistItemFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChecklistItemFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChecklistItemFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>
          }
          findFirst: {
            args: Prisma.ChecklistItemFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChecklistItemFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>
          }
          findMany: {
            args: Prisma.ChecklistItemFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>[]
          }
          create: {
            args: Prisma.ChecklistItemFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>
          }
          createMany: {
            args: Prisma.ChecklistItemFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChecklistItemFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>[]
          }
          delete: {
            args: Prisma.ChecklistItemFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>
          }
          update: {
            args: Prisma.ChecklistItemFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>
          }
          deleteMany: {
            args: Prisma.ChecklistItemFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChecklistItemFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChecklistItemFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>[]
          }
          upsert: {
            args: Prisma.ChecklistItemFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChecklistItemFilePayload>
          }
          aggregate: {
            args: Prisma.ChecklistItemFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChecklistItemFile>
          }
          groupBy: {
            args: Prisma.ChecklistItemFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChecklistItemFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChecklistItemFileCountArgs<ExtArgs>
            result: $Utils.Optional<ChecklistItemFileCountAggregateOutputType> | number
          }
        }
      }
      QuestionnaireSection: {
        payload: Prisma.$QuestionnaireSectionPayload<ExtArgs>
        fields: Prisma.QuestionnaireSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionnaireSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionnaireSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>
          }
          findFirst: {
            args: Prisma.QuestionnaireSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionnaireSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>
          }
          findMany: {
            args: Prisma.QuestionnaireSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>[]
          }
          create: {
            args: Prisma.QuestionnaireSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>
          }
          createMany: {
            args: Prisma.QuestionnaireSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionnaireSectionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>[]
          }
          delete: {
            args: Prisma.QuestionnaireSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>
          }
          update: {
            args: Prisma.QuestionnaireSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionnaireSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionnaireSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionnaireSectionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionnaireSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireSectionPayload>
          }
          aggregate: {
            args: Prisma.QuestionnaireSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionnaireSection>
          }
          groupBy: {
            args: Prisma.QuestionnaireSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionnaireSectionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireSectionCountAggregateOutputType> | number
          }
        }
      }
      QuestionnaireQuestion: {
        payload: Prisma.$QuestionnaireQuestionPayload<ExtArgs>
        fields: Prisma.QuestionnaireQuestionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionnaireQuestionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionnaireQuestionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>
          }
          findFirst: {
            args: Prisma.QuestionnaireQuestionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionnaireQuestionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>
          }
          findMany: {
            args: Prisma.QuestionnaireQuestionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>[]
          }
          create: {
            args: Prisma.QuestionnaireQuestionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>
          }
          createMany: {
            args: Prisma.QuestionnaireQuestionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionnaireQuestionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>[]
          }
          delete: {
            args: Prisma.QuestionnaireQuestionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>
          }
          update: {
            args: Prisma.QuestionnaireQuestionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>
          }
          deleteMany: {
            args: Prisma.QuestionnaireQuestionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionnaireQuestionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionnaireQuestionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>[]
          }
          upsert: {
            args: Prisma.QuestionnaireQuestionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireQuestionPayload>
          }
          aggregate: {
            args: Prisma.QuestionnaireQuestionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionnaireQuestion>
          }
          groupBy: {
            args: Prisma.QuestionnaireQuestionGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireQuestionGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionnaireQuestionCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireQuestionCountAggregateOutputType> | number
          }
        }
      }
      QuestionnaireAnswer: {
        payload: Prisma.$QuestionnaireAnswerPayload<ExtArgs>
        fields: Prisma.QuestionnaireAnswerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.QuestionnaireAnswerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.QuestionnaireAnswerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>
          }
          findFirst: {
            args: Prisma.QuestionnaireAnswerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.QuestionnaireAnswerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>
          }
          findMany: {
            args: Prisma.QuestionnaireAnswerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>[]
          }
          create: {
            args: Prisma.QuestionnaireAnswerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>
          }
          createMany: {
            args: Prisma.QuestionnaireAnswerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.QuestionnaireAnswerCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>[]
          }
          delete: {
            args: Prisma.QuestionnaireAnswerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>
          }
          update: {
            args: Prisma.QuestionnaireAnswerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>
          }
          deleteMany: {
            args: Prisma.QuestionnaireAnswerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.QuestionnaireAnswerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.QuestionnaireAnswerUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>[]
          }
          upsert: {
            args: Prisma.QuestionnaireAnswerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$QuestionnaireAnswerPayload>
          }
          aggregate: {
            args: Prisma.QuestionnaireAnswerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateQuestionnaireAnswer>
          }
          groupBy: {
            args: Prisma.QuestionnaireAnswerGroupByArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireAnswerGroupByOutputType>[]
          }
          count: {
            args: Prisma.QuestionnaireAnswerCountArgs<ExtArgs>
            result: $Utils.Optional<QuestionnaireAnswerCountAggregateOutputType> | number
          }
        }
      }
      EngagementSignature: {
        payload: Prisma.$EngagementSignaturePayload<ExtArgs>
        fields: Prisma.EngagementSignatureFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EngagementSignatureFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EngagementSignatureFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>
          }
          findFirst: {
            args: Prisma.EngagementSignatureFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EngagementSignatureFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>
          }
          findMany: {
            args: Prisma.EngagementSignatureFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>[]
          }
          create: {
            args: Prisma.EngagementSignatureCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>
          }
          createMany: {
            args: Prisma.EngagementSignatureCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EngagementSignatureCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>[]
          }
          delete: {
            args: Prisma.EngagementSignatureDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>
          }
          update: {
            args: Prisma.EngagementSignatureUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>
          }
          deleteMany: {
            args: Prisma.EngagementSignatureDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EngagementSignatureUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EngagementSignatureUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>[]
          }
          upsert: {
            args: Prisma.EngagementSignatureUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EngagementSignaturePayload>
          }
          aggregate: {
            args: Prisma.EngagementSignatureAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEngagementSignature>
          }
          groupBy: {
            args: Prisma.EngagementSignatureGroupByArgs<ExtArgs>
            result: $Utils.Optional<EngagementSignatureGroupByOutputType>[]
          }
          count: {
            args: Prisma.EngagementSignatureCountArgs<ExtArgs>
            result: $Utils.Optional<EngagementSignatureCountAggregateOutputType> | number
          }
        }
      }
      EfileAuthorization: {
        payload: Prisma.$EfileAuthorizationPayload<ExtArgs>
        fields: Prisma.EfileAuthorizationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EfileAuthorizationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EfileAuthorizationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>
          }
          findFirst: {
            args: Prisma.EfileAuthorizationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EfileAuthorizationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>
          }
          findMany: {
            args: Prisma.EfileAuthorizationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>[]
          }
          create: {
            args: Prisma.EfileAuthorizationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>
          }
          createMany: {
            args: Prisma.EfileAuthorizationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EfileAuthorizationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>[]
          }
          delete: {
            args: Prisma.EfileAuthorizationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>
          }
          update: {
            args: Prisma.EfileAuthorizationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>
          }
          deleteMany: {
            args: Prisma.EfileAuthorizationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EfileAuthorizationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EfileAuthorizationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>[]
          }
          upsert: {
            args: Prisma.EfileAuthorizationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EfileAuthorizationPayload>
          }
          aggregate: {
            args: Prisma.EfileAuthorizationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEfileAuthorization>
          }
          groupBy: {
            args: Prisma.EfileAuthorizationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EfileAuthorizationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EfileAuthorizationCountArgs<ExtArgs>
            result: $Utils.Optional<EfileAuthorizationCountAggregateOutputType> | number
          }
        }
      }
      MessageThread: {
        payload: Prisma.$MessageThreadPayload<ExtArgs>
        fields: Prisma.MessageThreadFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageThreadFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageThreadFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          findFirst: {
            args: Prisma.MessageThreadFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageThreadFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          findMany: {
            args: Prisma.MessageThreadFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          create: {
            args: Prisma.MessageThreadCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          createMany: {
            args: Prisma.MessageThreadCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageThreadCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          delete: {
            args: Prisma.MessageThreadDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          update: {
            args: Prisma.MessageThreadUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          deleteMany: {
            args: Prisma.MessageThreadDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageThreadUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageThreadUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>[]
          }
          upsert: {
            args: Prisma.MessageThreadUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageThreadPayload>
          }
          aggregate: {
            args: Prisma.MessageThreadAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageThread>
          }
          groupBy: {
            args: Prisma.MessageThreadGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageThreadGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageThreadCountArgs<ExtArgs>
            result: $Utils.Optional<MessageThreadCountAggregateOutputType> | number
          }
        }
      }
      ThreadParticipant: {
        payload: Prisma.$ThreadParticipantPayload<ExtArgs>
        fields: Prisma.ThreadParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ThreadParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ThreadParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>
          }
          findFirst: {
            args: Prisma.ThreadParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ThreadParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>
          }
          findMany: {
            args: Prisma.ThreadParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>[]
          }
          create: {
            args: Prisma.ThreadParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>
          }
          createMany: {
            args: Prisma.ThreadParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ThreadParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>[]
          }
          delete: {
            args: Prisma.ThreadParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>
          }
          update: {
            args: Prisma.ThreadParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>
          }
          deleteMany: {
            args: Prisma.ThreadParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ThreadParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ThreadParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>[]
          }
          upsert: {
            args: Prisma.ThreadParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ThreadParticipantPayload>
          }
          aggregate: {
            args: Prisma.ThreadParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateThreadParticipant>
          }
          groupBy: {
            args: Prisma.ThreadParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<ThreadParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.ThreadParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<ThreadParticipantCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      ReminderState: {
        payload: Prisma.$ReminderStatePayload<ExtArgs>
        fields: Prisma.ReminderStateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReminderStateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReminderStateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>
          }
          findFirst: {
            args: Prisma.ReminderStateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReminderStateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>
          }
          findMany: {
            args: Prisma.ReminderStateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>[]
          }
          create: {
            args: Prisma.ReminderStateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>
          }
          createMany: {
            args: Prisma.ReminderStateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReminderStateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>[]
          }
          delete: {
            args: Prisma.ReminderStateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>
          }
          update: {
            args: Prisma.ReminderStateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>
          }
          deleteMany: {
            args: Prisma.ReminderStateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReminderStateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReminderStateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>[]
          }
          upsert: {
            args: Prisma.ReminderStateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReminderStatePayload>
          }
          aggregate: {
            args: Prisma.ReminderStateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReminderState>
          }
          groupBy: {
            args: Prisma.ReminderStateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReminderStateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReminderStateCountArgs<ExtArgs>
            result: $Utils.Optional<ReminderStateCountAggregateOutputType> | number
          }
        }
      }
      StatusAuditLog: {
        payload: Prisma.$StatusAuditLogPayload<ExtArgs>
        fields: Prisma.StatusAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StatusAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StatusAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>
          }
          findFirst: {
            args: Prisma.StatusAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StatusAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>
          }
          findMany: {
            args: Prisma.StatusAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>[]
          }
          create: {
            args: Prisma.StatusAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>
          }
          createMany: {
            args: Prisma.StatusAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StatusAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>[]
          }
          delete: {
            args: Prisma.StatusAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>
          }
          update: {
            args: Prisma.StatusAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.StatusAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StatusAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StatusAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.StatusAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StatusAuditLogPayload>
          }
          aggregate: {
            args: Prisma.StatusAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStatusAuditLog>
          }
          groupBy: {
            args: Prisma.StatusAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatusAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.StatusAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<StatusAuditLogCountAggregateOutputType> | number
          }
        }
      }
      PermissionAuditLog: {
        payload: Prisma.$PermissionAuditLogPayload<ExtArgs>
        fields: Prisma.PermissionAuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PermissionAuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PermissionAuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
          }
          findFirst: {
            args: Prisma.PermissionAuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PermissionAuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
          }
          findMany: {
            args: Prisma.PermissionAuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
          }
          create: {
            args: Prisma.PermissionAuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
          }
          createMany: {
            args: Prisma.PermissionAuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PermissionAuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
          }
          delete: {
            args: Prisma.PermissionAuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
          }
          update: {
            args: Prisma.PermissionAuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
          }
          deleteMany: {
            args: Prisma.PermissionAuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PermissionAuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PermissionAuditLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>[]
          }
          upsert: {
            args: Prisma.PermissionAuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PermissionAuditLogPayload>
          }
          aggregate: {
            args: Prisma.PermissionAuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissionAuditLog>
          }
          groupBy: {
            args: Prisma.PermissionAuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionAuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.PermissionAuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionAuditLogCountAggregateOutputType> | number
          }
        }
      }
      DocumentEvent: {
        payload: Prisma.$DocumentEventPayload<ExtArgs>
        fields: Prisma.DocumentEventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentEventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentEventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>
          }
          findFirst: {
            args: Prisma.DocumentEventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentEventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>
          }
          findMany: {
            args: Prisma.DocumentEventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>[]
          }
          create: {
            args: Prisma.DocumentEventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>
          }
          createMany: {
            args: Prisma.DocumentEventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentEventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>[]
          }
          delete: {
            args: Prisma.DocumentEventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>
          }
          update: {
            args: Prisma.DocumentEventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>
          }
          deleteMany: {
            args: Prisma.DocumentEventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentEventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DocumentEventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>[]
          }
          upsert: {
            args: Prisma.DocumentEventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentEventPayload>
          }
          aggregate: {
            args: Prisma.DocumentEventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumentEvent>
          }
          groupBy: {
            args: Prisma.DocumentEventGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentEventGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentEventCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentEventCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    profile?: ProfileOmit
    staffProfile?: StaffProfileOmit
    account?: AccountOmit
    accountUser?: AccountUserOmit
    clientEntity?: ClientEntityOmit
    entityTaxYear?: EntityTaxYearOmit
    clientAcl?: ClientAclOmit
    clientStaffPermission?: ClientStaffPermissionOmit
    clientStaffAssignment?: ClientStaffAssignmentOmit
    folder?: FolderOmit
    folderAcl?: FolderAclOmit
    document?: DocumentOmit
    checklistItem?: ChecklistItemOmit
    checklistItemFile?: ChecklistItemFileOmit
    questionnaireSection?: QuestionnaireSectionOmit
    questionnaireQuestion?: QuestionnaireQuestionOmit
    questionnaireAnswer?: QuestionnaireAnswerOmit
    engagementSignature?: EngagementSignatureOmit
    efileAuthorization?: EfileAuthorizationOmit
    messageThread?: MessageThreadOmit
    threadParticipant?: ThreadParticipantOmit
    message?: MessageOmit
    reminderState?: ReminderStateOmit
    statusAuditLog?: StatusAuditLogOmit
    permissionAuditLog?: PermissionAuditLogOmit
    documentEvent?: DocumentEventOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    accountUsers: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountUsers?: boolean | ProfileCountOutputTypeCountAccountUsersArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountAccountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountUserWhereInput
  }


  /**
   * Count Type StaffProfileCountOutputType
   */

  export type StaffProfileCountOutputType = {
    clientAcl: number
    clientStaffPermissions: number
    clientStaffAssignments: number
    folderAcl: number
    uploadedDocuments: number
    assignedThreads: number
    sentMessages: number
    statusAuditLogs: number
    permissionAuditLogs: number
  }

  export type StaffProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientAcl?: boolean | StaffProfileCountOutputTypeCountClientAclArgs
    clientStaffPermissions?: boolean | StaffProfileCountOutputTypeCountClientStaffPermissionsArgs
    clientStaffAssignments?: boolean | StaffProfileCountOutputTypeCountClientStaffAssignmentsArgs
    folderAcl?: boolean | StaffProfileCountOutputTypeCountFolderAclArgs
    uploadedDocuments?: boolean | StaffProfileCountOutputTypeCountUploadedDocumentsArgs
    assignedThreads?: boolean | StaffProfileCountOutputTypeCountAssignedThreadsArgs
    sentMessages?: boolean | StaffProfileCountOutputTypeCountSentMessagesArgs
    statusAuditLogs?: boolean | StaffProfileCountOutputTypeCountStatusAuditLogsArgs
    permissionAuditLogs?: boolean | StaffProfileCountOutputTypeCountPermissionAuditLogsArgs
  }

  // Custom InputTypes
  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfileCountOutputType
     */
    select?: StaffProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountClientAclArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAclWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountClientStaffPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientStaffPermissionWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountClientStaffAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientStaffAssignmentWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountFolderAclArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderAclWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountUploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountAssignedThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadParticipantWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountStatusAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusAuditLogWhereInput
  }

  /**
   * StaffProfileCountOutputType without action
   */
  export type StaffProfileCountOutputTypeCountPermissionAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionAuditLogWhereInput
  }


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    accountUsers: number
    entities: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountUsers?: boolean | AccountCountOutputTypeCountAccountUsersArgs
    entities?: boolean | AccountCountOutputTypeCountEntitiesArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountAccountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountUserWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountEntitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEntityWhereInput
  }


  /**
   * Count Type ClientEntityCountOutputType
   */

  export type ClientEntityCountOutputType = {
    entityTaxYears: number
    folders: number
    documents: number
    clientAcl: number
    clientStaffPermissions: number
    clientStaffAssignments: number
  }

  export type ClientEntityCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYears?: boolean | ClientEntityCountOutputTypeCountEntityTaxYearsArgs
    folders?: boolean | ClientEntityCountOutputTypeCountFoldersArgs
    documents?: boolean | ClientEntityCountOutputTypeCountDocumentsArgs
    clientAcl?: boolean | ClientEntityCountOutputTypeCountClientAclArgs
    clientStaffPermissions?: boolean | ClientEntityCountOutputTypeCountClientStaffPermissionsArgs
    clientStaffAssignments?: boolean | ClientEntityCountOutputTypeCountClientStaffAssignmentsArgs
  }

  // Custom InputTypes
  /**
   * ClientEntityCountOutputType without action
   */
  export type ClientEntityCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntityCountOutputType
     */
    select?: ClientEntityCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClientEntityCountOutputType without action
   */
  export type ClientEntityCountOutputTypeCountEntityTaxYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityTaxYearWhereInput
  }

  /**
   * ClientEntityCountOutputType without action
   */
  export type ClientEntityCountOutputTypeCountFoldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * ClientEntityCountOutputType without action
   */
  export type ClientEntityCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * ClientEntityCountOutputType without action
   */
  export type ClientEntityCountOutputTypeCountClientAclArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAclWhereInput
  }

  /**
   * ClientEntityCountOutputType without action
   */
  export type ClientEntityCountOutputTypeCountClientStaffPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientStaffPermissionWhereInput
  }

  /**
   * ClientEntityCountOutputType without action
   */
  export type ClientEntityCountOutputTypeCountClientStaffAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientStaffAssignmentWhereInput
  }


  /**
   * Count Type EntityTaxYearCountOutputType
   */

  export type EntityTaxYearCountOutputType = {
    checklistItems: number
    questionnaireAnswers: number
    statusAuditLogs: number
    documentEvents: number
    engagementSignatures: number
    efileAuthorizations: number
  }

  export type EntityTaxYearCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklistItems?: boolean | EntityTaxYearCountOutputTypeCountChecklistItemsArgs
    questionnaireAnswers?: boolean | EntityTaxYearCountOutputTypeCountQuestionnaireAnswersArgs
    statusAuditLogs?: boolean | EntityTaxYearCountOutputTypeCountStatusAuditLogsArgs
    documentEvents?: boolean | EntityTaxYearCountOutputTypeCountDocumentEventsArgs
    engagementSignatures?: boolean | EntityTaxYearCountOutputTypeCountEngagementSignaturesArgs
    efileAuthorizations?: boolean | EntityTaxYearCountOutputTypeCountEfileAuthorizationsArgs
  }

  // Custom InputTypes
  /**
   * EntityTaxYearCountOutputType without action
   */
  export type EntityTaxYearCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYearCountOutputType
     */
    select?: EntityTaxYearCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EntityTaxYearCountOutputType without action
   */
  export type EntityTaxYearCountOutputTypeCountChecklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistItemWhereInput
  }

  /**
   * EntityTaxYearCountOutputType without action
   */
  export type EntityTaxYearCountOutputTypeCountQuestionnaireAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireAnswerWhereInput
  }

  /**
   * EntityTaxYearCountOutputType without action
   */
  export type EntityTaxYearCountOutputTypeCountStatusAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusAuditLogWhereInput
  }

  /**
   * EntityTaxYearCountOutputType without action
   */
  export type EntityTaxYearCountOutputTypeCountDocumentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentEventWhereInput
  }

  /**
   * EntityTaxYearCountOutputType without action
   */
  export type EntityTaxYearCountOutputTypeCountEngagementSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementSignatureWhereInput
  }

  /**
   * EntityTaxYearCountOutputType without action
   */
  export type EntityTaxYearCountOutputTypeCountEfileAuthorizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EfileAuthorizationWhereInput
  }


  /**
   * Count Type FolderCountOutputType
   */

  export type FolderCountOutputType = {
    children: number
    documents: number
    folderAcl: number
  }

  export type FolderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | FolderCountOutputTypeCountChildrenArgs
    documents?: boolean | FolderCountOutputTypeCountDocumentsArgs
    folderAcl?: boolean | FolderCountOutputTypeCountFolderAclArgs
  }

  // Custom InputTypes
  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderCountOutputType
     */
    select?: FolderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
  }

  /**
   * FolderCountOutputType without action
   */
  export type FolderCountOutputTypeCountFolderAclArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderAclWhereInput
  }


  /**
   * Count Type DocumentCountOutputType
   */

  export type DocumentCountOutputType = {
    checklistItems: number
  }

  export type DocumentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklistItems?: boolean | DocumentCountOutputTypeCountChecklistItemsArgs
  }

  // Custom InputTypes
  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentCountOutputType
     */
    select?: DocumentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentCountOutputType without action
   */
  export type DocumentCountOutputTypeCountChecklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistItemFileWhereInput
  }


  /**
   * Count Type ChecklistItemCountOutputType
   */

  export type ChecklistItemCountOutputType = {
    files: number
  }

  export type ChecklistItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | ChecklistItemCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * ChecklistItemCountOutputType without action
   */
  export type ChecklistItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemCountOutputType
     */
    select?: ChecklistItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChecklistItemCountOutputType without action
   */
  export type ChecklistItemCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistItemFileWhereInput
  }


  /**
   * Count Type QuestionnaireSectionCountOutputType
   */

  export type QuestionnaireSectionCountOutputType = {
    questions: number
  }

  export type QuestionnaireSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuestionnaireSectionCountOutputTypeCountQuestionsArgs
  }

  // Custom InputTypes
  /**
   * QuestionnaireSectionCountOutputType without action
   */
  export type QuestionnaireSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSectionCountOutputType
     */
    select?: QuestionnaireSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionnaireSectionCountOutputType without action
   */
  export type QuestionnaireSectionCountOutputTypeCountQuestionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireQuestionWhereInput
  }


  /**
   * Count Type QuestionnaireQuestionCountOutputType
   */

  export type QuestionnaireQuestionCountOutputType = {
    answers: number
  }

  export type QuestionnaireQuestionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    answers?: boolean | QuestionnaireQuestionCountOutputTypeCountAnswersArgs
  }

  // Custom InputTypes
  /**
   * QuestionnaireQuestionCountOutputType without action
   */
  export type QuestionnaireQuestionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestionCountOutputType
     */
    select?: QuestionnaireQuestionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * QuestionnaireQuestionCountOutputType without action
   */
  export type QuestionnaireQuestionCountOutputTypeCountAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireAnswerWhereInput
  }


  /**
   * Count Type MessageThreadCountOutputType
   */

  export type MessageThreadCountOutputType = {
    participants: number
    messages: number
  }

  export type MessageThreadCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | MessageThreadCountOutputTypeCountParticipantsArgs
    messages?: boolean | MessageThreadCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThreadCountOutputType
     */
    select?: MessageThreadCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadParticipantWhereInput
  }

  /**
   * MessageThreadCountOutputType without action
   */
  export type MessageThreadCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
    staffProfile?: boolean | User$staffProfileArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "passwordHash" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
    staffProfile?: boolean | User$staffProfileArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
      staffProfile: Prisma.$StaffProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    staffProfile<T extends User$staffProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$staffProfileArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User.staffProfile
   */
  export type User$staffProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    userType: $Enums.UserType | null
    fullName: string | null
    email: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    userType: $Enums.UserType | null
    fullName: string | null
    email: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    userType: number
    fullName: number
    email: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    userType?: true
    fullName?: true
    email?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    userType?: true
    fullName?: true
    email?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    userType?: true
    fullName?: true
    email?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    userType: $Enums.UserType
    fullName: string
    email: string
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userType?: boolean
    fullName?: boolean
    email?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    staffProfile?: boolean | Profile$staffProfileArgs<ExtArgs>
    accountUsers?: boolean | Profile$accountUsersArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userType?: boolean
    fullName?: boolean
    email?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    userType?: boolean
    fullName?: boolean
    email?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    userType?: boolean
    fullName?: boolean
    email?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "userType" | "fullName" | "email" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    staffProfile?: boolean | Profile$staffProfileArgs<ExtArgs>
    accountUsers?: boolean | Profile$accountUsersArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      staffProfile: Prisma.$StaffProfilePayload<ExtArgs> | null
      accountUsers: Prisma.$AccountUserPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      userType: $Enums.UserType
      fullName: string
      email: string
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staffProfile<T extends Profile$staffProfileArgs<ExtArgs> = {}>(args?: Subset<T, Profile$staffProfileArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accountUsers<T extends Profile$accountUsersArgs<ExtArgs> = {}>(args?: Subset<T, Profile$accountUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly userType: FieldRef<"Profile", 'UserType'>
    readonly fullName: FieldRef<"Profile", 'String'>
    readonly email: FieldRef<"Profile", 'String'>
    readonly active: FieldRef<"Profile", 'Boolean'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.staffProfile
   */
  export type Profile$staffProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * Profile.accountUsers
   */
  export type Profile$accountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    where?: AccountUserWhereInput
    orderBy?: AccountUserOrderByWithRelationInput | AccountUserOrderByWithRelationInput[]
    cursor?: AccountUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountUserScalarFieldEnum | AccountUserScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model StaffProfile
   */

  export type AggregateStaffProfile = {
    _count: StaffProfileCountAggregateOutputType | null
    _min: StaffProfileMinAggregateOutputType | null
    _max: StaffProfileMaxAggregateOutputType | null
  }

  export type StaffProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    staffRole: $Enums.StaffRole | null
    staffTeamReporting: string | null
    jobTitle: string | null
    phone: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    staffRole: $Enums.StaffRole | null
    staffTeamReporting: string | null
    jobTitle: string | null
    phone: string | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StaffProfileCountAggregateOutputType = {
    id: number
    userId: number
    staffRole: number
    staffTeamReporting: number
    jobTitle: number
    phone: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StaffProfileMinAggregateInputType = {
    id?: true
    userId?: true
    staffRole?: true
    staffTeamReporting?: true
    jobTitle?: true
    phone?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    staffRole?: true
    staffTeamReporting?: true
    jobTitle?: true
    phone?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StaffProfileCountAggregateInputType = {
    id?: true
    userId?: true
    staffRole?: true
    staffTeamReporting?: true
    jobTitle?: true
    phone?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StaffProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffProfile to aggregate.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StaffProfiles
    **/
    _count?: true | StaffProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StaffProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StaffProfileMaxAggregateInputType
  }

  export type GetStaffProfileAggregateType<T extends StaffProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateStaffProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStaffProfile[P]>
      : GetScalarType<T[P], AggregateStaffProfile[P]>
  }




  export type StaffProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StaffProfileWhereInput
    orderBy?: StaffProfileOrderByWithAggregationInput | StaffProfileOrderByWithAggregationInput[]
    by: StaffProfileScalarFieldEnum[] | StaffProfileScalarFieldEnum
    having?: StaffProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StaffProfileCountAggregateInputType | true
    _min?: StaffProfileMinAggregateInputType
    _max?: StaffProfileMaxAggregateInputType
  }

  export type StaffProfileGroupByOutputType = {
    id: string
    userId: string
    staffRole: $Enums.StaffRole
    staffTeamReporting: string | null
    jobTitle: string | null
    phone: string | null
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: StaffProfileCountAggregateOutputType | null
    _min: StaffProfileMinAggregateOutputType | null
    _max: StaffProfileMaxAggregateOutputType | null
  }

  type GetStaffProfileGroupByPayload<T extends StaffProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StaffProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StaffProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StaffProfileGroupByOutputType[P]>
            : GetScalarType<T[P], StaffProfileGroupByOutputType[P]>
        }
      >
    >


  export type StaffProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffRole?: boolean
    staffTeamReporting?: boolean
    jobTitle?: boolean
    phone?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    clientAcl?: boolean | StaffProfile$clientAclArgs<ExtArgs>
    clientStaffPermissions?: boolean | StaffProfile$clientStaffPermissionsArgs<ExtArgs>
    clientStaffAssignments?: boolean | StaffProfile$clientStaffAssignmentsArgs<ExtArgs>
    folderAcl?: boolean | StaffProfile$folderAclArgs<ExtArgs>
    uploadedDocuments?: boolean | StaffProfile$uploadedDocumentsArgs<ExtArgs>
    assignedThreads?: boolean | StaffProfile$assignedThreadsArgs<ExtArgs>
    sentMessages?: boolean | StaffProfile$sentMessagesArgs<ExtArgs>
    statusAuditLogs?: boolean | StaffProfile$statusAuditLogsArgs<ExtArgs>
    permissionAuditLogs?: boolean | StaffProfile$permissionAuditLogsArgs<ExtArgs>
    _count?: boolean | StaffProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffRole?: boolean
    staffTeamReporting?: boolean
    jobTitle?: boolean
    phone?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    staffRole?: boolean
    staffTeamReporting?: boolean
    jobTitle?: boolean
    phone?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["staffProfile"]>

  export type StaffProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    staffRole?: boolean
    staffTeamReporting?: boolean
    jobTitle?: boolean
    phone?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StaffProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "staffRole" | "staffTeamReporting" | "jobTitle" | "phone" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["staffProfile"]>
  export type StaffProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
    clientAcl?: boolean | StaffProfile$clientAclArgs<ExtArgs>
    clientStaffPermissions?: boolean | StaffProfile$clientStaffPermissionsArgs<ExtArgs>
    clientStaffAssignments?: boolean | StaffProfile$clientStaffAssignmentsArgs<ExtArgs>
    folderAcl?: boolean | StaffProfile$folderAclArgs<ExtArgs>
    uploadedDocuments?: boolean | StaffProfile$uploadedDocumentsArgs<ExtArgs>
    assignedThreads?: boolean | StaffProfile$assignedThreadsArgs<ExtArgs>
    sentMessages?: boolean | StaffProfile$sentMessagesArgs<ExtArgs>
    statusAuditLogs?: boolean | StaffProfile$statusAuditLogsArgs<ExtArgs>
    permissionAuditLogs?: boolean | StaffProfile$permissionAuditLogsArgs<ExtArgs>
    _count?: boolean | StaffProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StaffProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type StaffProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $StaffProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StaffProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
      clientAcl: Prisma.$ClientAclPayload<ExtArgs>[]
      clientStaffPermissions: Prisma.$ClientStaffPermissionPayload<ExtArgs>[]
      clientStaffAssignments: Prisma.$ClientStaffAssignmentPayload<ExtArgs>[]
      folderAcl: Prisma.$FolderAclPayload<ExtArgs>[]
      uploadedDocuments: Prisma.$DocumentPayload<ExtArgs>[]
      assignedThreads: Prisma.$ThreadParticipantPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      statusAuditLogs: Prisma.$StatusAuditLogPayload<ExtArgs>[]
      permissionAuditLogs: Prisma.$PermissionAuditLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      staffRole: $Enums.StaffRole
      staffTeamReporting: string | null
      jobTitle: string | null
      phone: string | null
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["staffProfile"]>
    composites: {}
  }

  type StaffProfileGetPayload<S extends boolean | null | undefined | StaffProfileDefaultArgs> = $Result.GetResult<Prisma.$StaffProfilePayload, S>

  type StaffProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StaffProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StaffProfileCountAggregateInputType | true
    }

  export interface StaffProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StaffProfile'], meta: { name: 'StaffProfile' } }
    /**
     * Find zero or one StaffProfile that matches the filter.
     * @param {StaffProfileFindUniqueArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StaffProfileFindUniqueArgs>(args: SelectSubset<T, StaffProfileFindUniqueArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StaffProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StaffProfileFindUniqueOrThrowArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StaffProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, StaffProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindFirstArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StaffProfileFindFirstArgs>(args?: SelectSubset<T, StaffProfileFindFirstArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StaffProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindFirstOrThrowArgs} args - Arguments to find a StaffProfile
     * @example
     * // Get one StaffProfile
     * const staffProfile = await prisma.staffProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StaffProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, StaffProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StaffProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StaffProfiles
     * const staffProfiles = await prisma.staffProfile.findMany()
     * 
     * // Get first 10 StaffProfiles
     * const staffProfiles = await prisma.staffProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StaffProfileFindManyArgs>(args?: SelectSubset<T, StaffProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StaffProfile.
     * @param {StaffProfileCreateArgs} args - Arguments to create a StaffProfile.
     * @example
     * // Create one StaffProfile
     * const StaffProfile = await prisma.staffProfile.create({
     *   data: {
     *     // ... data to create a StaffProfile
     *   }
     * })
     * 
     */
    create<T extends StaffProfileCreateArgs>(args: SelectSubset<T, StaffProfileCreateArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StaffProfiles.
     * @param {StaffProfileCreateManyArgs} args - Arguments to create many StaffProfiles.
     * @example
     * // Create many StaffProfiles
     * const staffProfile = await prisma.staffProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StaffProfileCreateManyArgs>(args?: SelectSubset<T, StaffProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StaffProfiles and returns the data saved in the database.
     * @param {StaffProfileCreateManyAndReturnArgs} args - Arguments to create many StaffProfiles.
     * @example
     * // Create many StaffProfiles
     * const staffProfile = await prisma.staffProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StaffProfiles and only return the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StaffProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, StaffProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StaffProfile.
     * @param {StaffProfileDeleteArgs} args - Arguments to delete one StaffProfile.
     * @example
     * // Delete one StaffProfile
     * const StaffProfile = await prisma.staffProfile.delete({
     *   where: {
     *     // ... filter to delete one StaffProfile
     *   }
     * })
     * 
     */
    delete<T extends StaffProfileDeleteArgs>(args: SelectSubset<T, StaffProfileDeleteArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StaffProfile.
     * @param {StaffProfileUpdateArgs} args - Arguments to update one StaffProfile.
     * @example
     * // Update one StaffProfile
     * const staffProfile = await prisma.staffProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StaffProfileUpdateArgs>(args: SelectSubset<T, StaffProfileUpdateArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StaffProfiles.
     * @param {StaffProfileDeleteManyArgs} args - Arguments to filter StaffProfiles to delete.
     * @example
     * // Delete a few StaffProfiles
     * const { count } = await prisma.staffProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StaffProfileDeleteManyArgs>(args?: SelectSubset<T, StaffProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StaffProfiles
     * const staffProfile = await prisma.staffProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StaffProfileUpdateManyArgs>(args: SelectSubset<T, StaffProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StaffProfiles and returns the data updated in the database.
     * @param {StaffProfileUpdateManyAndReturnArgs} args - Arguments to update many StaffProfiles.
     * @example
     * // Update many StaffProfiles
     * const staffProfile = await prisma.staffProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StaffProfiles and only return the `id`
     * const staffProfileWithIdOnly = await prisma.staffProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StaffProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, StaffProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StaffProfile.
     * @param {StaffProfileUpsertArgs} args - Arguments to update or create a StaffProfile.
     * @example
     * // Update or create a StaffProfile
     * const staffProfile = await prisma.staffProfile.upsert({
     *   create: {
     *     // ... data to create a StaffProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StaffProfile we want to update
     *   }
     * })
     */
    upsert<T extends StaffProfileUpsertArgs>(args: SelectSubset<T, StaffProfileUpsertArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StaffProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileCountArgs} args - Arguments to filter StaffProfiles to count.
     * @example
     * // Count the number of StaffProfiles
     * const count = await prisma.staffProfile.count({
     *   where: {
     *     // ... the filter for the StaffProfiles we want to count
     *   }
     * })
    **/
    count<T extends StaffProfileCountArgs>(
      args?: Subset<T, StaffProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StaffProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StaffProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StaffProfileAggregateArgs>(args: Subset<T, StaffProfileAggregateArgs>): Prisma.PrismaPromise<GetStaffProfileAggregateType<T>>

    /**
     * Group by StaffProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StaffProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StaffProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StaffProfileGroupByArgs['orderBy'] }
        : { orderBy?: StaffProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StaffProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStaffProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StaffProfile model
   */
  readonly fields: StaffProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StaffProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StaffProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    clientAcl<T extends StaffProfile$clientAclArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$clientAclArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientStaffPermissions<T extends StaffProfile$clientStaffPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$clientStaffPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientStaffAssignments<T extends StaffProfile$clientStaffAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$clientStaffAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folderAcl<T extends StaffProfile$folderAclArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$folderAclArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    uploadedDocuments<T extends StaffProfile$uploadedDocumentsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$uploadedDocumentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    assignedThreads<T extends StaffProfile$assignedThreadsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$assignedThreadsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends StaffProfile$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    statusAuditLogs<T extends StaffProfile$statusAuditLogsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$statusAuditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    permissionAuditLogs<T extends StaffProfile$permissionAuditLogsArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfile$permissionAuditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StaffProfile model
   */
  interface StaffProfileFieldRefs {
    readonly id: FieldRef<"StaffProfile", 'String'>
    readonly userId: FieldRef<"StaffProfile", 'String'>
    readonly staffRole: FieldRef<"StaffProfile", 'StaffRole'>
    readonly staffTeamReporting: FieldRef<"StaffProfile", 'String'>
    readonly jobTitle: FieldRef<"StaffProfile", 'String'>
    readonly phone: FieldRef<"StaffProfile", 'String'>
    readonly active: FieldRef<"StaffProfile", 'Boolean'>
    readonly createdAt: FieldRef<"StaffProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"StaffProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StaffProfile findUnique
   */
  export type StaffProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile findUniqueOrThrow
   */
  export type StaffProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile findFirst
   */
  export type StaffProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffProfiles.
     */
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile findFirstOrThrow
   */
  export type StaffProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfile to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StaffProfiles.
     */
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile findMany
   */
  export type StaffProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter, which StaffProfiles to fetch.
     */
    where?: StaffProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StaffProfiles to fetch.
     */
    orderBy?: StaffProfileOrderByWithRelationInput | StaffProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StaffProfiles.
     */
    cursor?: StaffProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StaffProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StaffProfiles.
     */
    skip?: number
    distinct?: StaffProfileScalarFieldEnum | StaffProfileScalarFieldEnum[]
  }

  /**
   * StaffProfile create
   */
  export type StaffProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a StaffProfile.
     */
    data: XOR<StaffProfileCreateInput, StaffProfileUncheckedCreateInput>
  }

  /**
   * StaffProfile createMany
   */
  export type StaffProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StaffProfiles.
     */
    data: StaffProfileCreateManyInput | StaffProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StaffProfile createManyAndReturn
   */
  export type StaffProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * The data used to create many StaffProfiles.
     */
    data: StaffProfileCreateManyInput | StaffProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffProfile update
   */
  export type StaffProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a StaffProfile.
     */
    data: XOR<StaffProfileUpdateInput, StaffProfileUncheckedUpdateInput>
    /**
     * Choose, which StaffProfile to update.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile updateMany
   */
  export type StaffProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StaffProfiles.
     */
    data: XOR<StaffProfileUpdateManyMutationInput, StaffProfileUncheckedUpdateManyInput>
    /**
     * Filter which StaffProfiles to update
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to update.
     */
    limit?: number
  }

  /**
   * StaffProfile updateManyAndReturn
   */
  export type StaffProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * The data used to update StaffProfiles.
     */
    data: XOR<StaffProfileUpdateManyMutationInput, StaffProfileUncheckedUpdateManyInput>
    /**
     * Filter which StaffProfiles to update
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StaffProfile upsert
   */
  export type StaffProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the StaffProfile to update in case it exists.
     */
    where: StaffProfileWhereUniqueInput
    /**
     * In case the StaffProfile found by the `where` argument doesn't exist, create a new StaffProfile with this data.
     */
    create: XOR<StaffProfileCreateInput, StaffProfileUncheckedCreateInput>
    /**
     * In case the StaffProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StaffProfileUpdateInput, StaffProfileUncheckedUpdateInput>
  }

  /**
   * StaffProfile delete
   */
  export type StaffProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    /**
     * Filter which StaffProfile to delete.
     */
    where: StaffProfileWhereUniqueInput
  }

  /**
   * StaffProfile deleteMany
   */
  export type StaffProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StaffProfiles to delete
     */
    where?: StaffProfileWhereInput
    /**
     * Limit how many StaffProfiles to delete.
     */
    limit?: number
  }

  /**
   * StaffProfile.clientAcl
   */
  export type StaffProfile$clientAclArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    where?: ClientAclWhereInput
    orderBy?: ClientAclOrderByWithRelationInput | ClientAclOrderByWithRelationInput[]
    cursor?: ClientAclWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientAclScalarFieldEnum | ClientAclScalarFieldEnum[]
  }

  /**
   * StaffProfile.clientStaffPermissions
   */
  export type StaffProfile$clientStaffPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    where?: ClientStaffPermissionWhereInput
    orderBy?: ClientStaffPermissionOrderByWithRelationInput | ClientStaffPermissionOrderByWithRelationInput[]
    cursor?: ClientStaffPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientStaffPermissionScalarFieldEnum | ClientStaffPermissionScalarFieldEnum[]
  }

  /**
   * StaffProfile.clientStaffAssignments
   */
  export type StaffProfile$clientStaffAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    where?: ClientStaffAssignmentWhereInput
    orderBy?: ClientStaffAssignmentOrderByWithRelationInput | ClientStaffAssignmentOrderByWithRelationInput[]
    cursor?: ClientStaffAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientStaffAssignmentScalarFieldEnum | ClientStaffAssignmentScalarFieldEnum[]
  }

  /**
   * StaffProfile.folderAcl
   */
  export type StaffProfile$folderAclArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    where?: FolderAclWhereInput
    orderBy?: FolderAclOrderByWithRelationInput | FolderAclOrderByWithRelationInput[]
    cursor?: FolderAclWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderAclScalarFieldEnum | FolderAclScalarFieldEnum[]
  }

  /**
   * StaffProfile.uploadedDocuments
   */
  export type StaffProfile$uploadedDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * StaffProfile.assignedThreads
   */
  export type StaffProfile$assignedThreadsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    where?: ThreadParticipantWhereInput
    orderBy?: ThreadParticipantOrderByWithRelationInput | ThreadParticipantOrderByWithRelationInput[]
    cursor?: ThreadParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreadParticipantScalarFieldEnum | ThreadParticipantScalarFieldEnum[]
  }

  /**
   * StaffProfile.sentMessages
   */
  export type StaffProfile$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * StaffProfile.statusAuditLogs
   */
  export type StaffProfile$statusAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    where?: StatusAuditLogWhereInput
    orderBy?: StatusAuditLogOrderByWithRelationInput | StatusAuditLogOrderByWithRelationInput[]
    cursor?: StatusAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatusAuditLogScalarFieldEnum | StatusAuditLogScalarFieldEnum[]
  }

  /**
   * StaffProfile.permissionAuditLogs
   */
  export type StaffProfile$permissionAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    where?: PermissionAuditLogWhereInput
    orderBy?: PermissionAuditLogOrderByWithRelationInput | PermissionAuditLogOrderByWithRelationInput[]
    cursor?: PermissionAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PermissionAuditLogScalarFieldEnum | PermissionAuditLogScalarFieldEnum[]
  }

  /**
   * StaffProfile without action
   */
  export type StaffProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    displayName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    displayName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    displayName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    displayName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    displayName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    displayName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    displayName: string
    createdAt: Date
    updatedAt: Date
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    accountUsers?: boolean | Account$accountUsersArgs<ExtArgs>
    entities?: boolean | Account$entitiesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    displayName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    displayName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "displayName" | "createdAt" | "updatedAt", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accountUsers?: boolean | Account$accountUsersArgs<ExtArgs>
    entities?: boolean | Account$entitiesArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      accountUsers: Prisma.$AccountUserPayload<ExtArgs>[]
      entities: Prisma.$ClientEntityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      displayName: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    accountUsers<T extends Account$accountUsersArgs<ExtArgs> = {}>(args?: Subset<T, Account$accountUsersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    entities<T extends Account$entitiesArgs<ExtArgs> = {}>(args?: Subset<T, Account$entitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly displayName: FieldRef<"Account", 'String'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.accountUsers
   */
  export type Account$accountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    where?: AccountUserWhereInput
    orderBy?: AccountUserOrderByWithRelationInput | AccountUserOrderByWithRelationInput[]
    cursor?: AccountUserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountUserScalarFieldEnum | AccountUserScalarFieldEnum[]
  }

  /**
   * Account.entities
   */
  export type Account$entitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    where?: ClientEntityWhereInput
    orderBy?: ClientEntityOrderByWithRelationInput | ClientEntityOrderByWithRelationInput[]
    cursor?: ClientEntityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientEntityScalarFieldEnum | ClientEntityScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model AccountUser
   */

  export type AggregateAccountUser = {
    _count: AccountUserCountAggregateOutputType | null
    _min: AccountUserMinAggregateOutputType | null
    _max: AccountUserMaxAggregateOutputType | null
  }

  export type AccountUserMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    userId: string | null
    clientRole: $Enums.ClientRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountUserMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    userId: string | null
    clientRole: $Enums.ClientRole | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AccountUserCountAggregateOutputType = {
    id: number
    accountId: number
    userId: number
    clientRole: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AccountUserMinAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    clientRole?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountUserMaxAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    clientRole?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AccountUserCountAggregateInputType = {
    id?: true
    accountId?: true
    userId?: true
    clientRole?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AccountUserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountUser to aggregate.
     */
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     */
    orderBy?: AccountUserOrderByWithRelationInput | AccountUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccountUsers
    **/
    _count?: true | AccountUserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountUserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountUserMaxAggregateInputType
  }

  export type GetAccountUserAggregateType<T extends AccountUserAggregateArgs> = {
        [P in keyof T & keyof AggregateAccountUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccountUser[P]>
      : GetScalarType<T[P], AggregateAccountUser[P]>
  }




  export type AccountUserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountUserWhereInput
    orderBy?: AccountUserOrderByWithAggregationInput | AccountUserOrderByWithAggregationInput[]
    by: AccountUserScalarFieldEnum[] | AccountUserScalarFieldEnum
    having?: AccountUserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountUserCountAggregateInputType | true
    _min?: AccountUserMinAggregateInputType
    _max?: AccountUserMaxAggregateInputType
  }

  export type AccountUserGroupByOutputType = {
    id: string
    accountId: string
    userId: string
    clientRole: $Enums.ClientRole
    createdAt: Date
    updatedAt: Date
    _count: AccountUserCountAggregateOutputType | null
    _min: AccountUserMinAggregateOutputType | null
    _max: AccountUserMaxAggregateOutputType | null
  }

  type GetAccountUserGroupByPayload<T extends AccountUserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountUserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountUserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountUserGroupByOutputType[P]>
            : GetScalarType<T[P], AccountUserGroupByOutputType[P]>
        }
      >
    >


  export type AccountUserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    clientRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountUser"]>

  export type AccountUserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    clientRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountUser"]>

  export type AccountUserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userId?: boolean
    clientRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accountUser"]>

  export type AccountUserSelectScalar = {
    id?: boolean
    accountId?: boolean
    userId?: boolean
    clientRole?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AccountUserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "userId" | "clientRole" | "createdAt" | "updatedAt", ExtArgs["result"]["accountUser"]>
  export type AccountUserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type AccountUserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type AccountUserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    profile?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $AccountUserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccountUser"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      profile: Prisma.$ProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      userId: string
      clientRole: $Enums.ClientRole
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["accountUser"]>
    composites: {}
  }

  type AccountUserGetPayload<S extends boolean | null | undefined | AccountUserDefaultArgs> = $Result.GetResult<Prisma.$AccountUserPayload, S>

  type AccountUserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountUserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountUserCountAggregateInputType | true
    }

  export interface AccountUserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccountUser'], meta: { name: 'AccountUser' } }
    /**
     * Find zero or one AccountUser that matches the filter.
     * @param {AccountUserFindUniqueArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountUserFindUniqueArgs>(args: SelectSubset<T, AccountUserFindUniqueArgs<ExtArgs>>): Prisma__AccountUserClient<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccountUser that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountUserFindUniqueOrThrowArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountUserFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountUserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountUserClient<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountUser that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindFirstArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountUserFindFirstArgs>(args?: SelectSubset<T, AccountUserFindFirstArgs<ExtArgs>>): Prisma__AccountUserClient<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccountUser that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindFirstOrThrowArgs} args - Arguments to find a AccountUser
     * @example
     * // Get one AccountUser
     * const accountUser = await prisma.accountUser.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountUserFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountUserFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountUserClient<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccountUsers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccountUsers
     * const accountUsers = await prisma.accountUser.findMany()
     * 
     * // Get first 10 AccountUsers
     * const accountUsers = await prisma.accountUser.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountUserWithIdOnly = await prisma.accountUser.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountUserFindManyArgs>(args?: SelectSubset<T, AccountUserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccountUser.
     * @param {AccountUserCreateArgs} args - Arguments to create a AccountUser.
     * @example
     * // Create one AccountUser
     * const AccountUser = await prisma.accountUser.create({
     *   data: {
     *     // ... data to create a AccountUser
     *   }
     * })
     * 
     */
    create<T extends AccountUserCreateArgs>(args: SelectSubset<T, AccountUserCreateArgs<ExtArgs>>): Prisma__AccountUserClient<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccountUsers.
     * @param {AccountUserCreateManyArgs} args - Arguments to create many AccountUsers.
     * @example
     * // Create many AccountUsers
     * const accountUser = await prisma.accountUser.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountUserCreateManyArgs>(args?: SelectSubset<T, AccountUserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccountUsers and returns the data saved in the database.
     * @param {AccountUserCreateManyAndReturnArgs} args - Arguments to create many AccountUsers.
     * @example
     * // Create many AccountUsers
     * const accountUser = await prisma.accountUser.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccountUsers and only return the `id`
     * const accountUserWithIdOnly = await prisma.accountUser.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountUserCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountUserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccountUser.
     * @param {AccountUserDeleteArgs} args - Arguments to delete one AccountUser.
     * @example
     * // Delete one AccountUser
     * const AccountUser = await prisma.accountUser.delete({
     *   where: {
     *     // ... filter to delete one AccountUser
     *   }
     * })
     * 
     */
    delete<T extends AccountUserDeleteArgs>(args: SelectSubset<T, AccountUserDeleteArgs<ExtArgs>>): Prisma__AccountUserClient<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccountUser.
     * @param {AccountUserUpdateArgs} args - Arguments to update one AccountUser.
     * @example
     * // Update one AccountUser
     * const accountUser = await prisma.accountUser.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUserUpdateArgs>(args: SelectSubset<T, AccountUserUpdateArgs<ExtArgs>>): Prisma__AccountUserClient<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccountUsers.
     * @param {AccountUserDeleteManyArgs} args - Arguments to filter AccountUsers to delete.
     * @example
     * // Delete a few AccountUsers
     * const { count } = await prisma.accountUser.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountUserDeleteManyArgs>(args?: SelectSubset<T, AccountUserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccountUsers
     * const accountUser = await prisma.accountUser.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUserUpdateManyArgs>(args: SelectSubset<T, AccountUserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccountUsers and returns the data updated in the database.
     * @param {AccountUserUpdateManyAndReturnArgs} args - Arguments to update many AccountUsers.
     * @example
     * // Update many AccountUsers
     * const accountUser = await prisma.accountUser.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccountUsers and only return the `id`
     * const accountUserWithIdOnly = await prisma.accountUser.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUserUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccountUser.
     * @param {AccountUserUpsertArgs} args - Arguments to update or create a AccountUser.
     * @example
     * // Update or create a AccountUser
     * const accountUser = await prisma.accountUser.upsert({
     *   create: {
     *     // ... data to create a AccountUser
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccountUser we want to update
     *   }
     * })
     */
    upsert<T extends AccountUserUpsertArgs>(args: SelectSubset<T, AccountUserUpsertArgs<ExtArgs>>): Prisma__AccountUserClient<$Result.GetResult<Prisma.$AccountUserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccountUsers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserCountArgs} args - Arguments to filter AccountUsers to count.
     * @example
     * // Count the number of AccountUsers
     * const count = await prisma.accountUser.count({
     *   where: {
     *     // ... the filter for the AccountUsers we want to count
     *   }
     * })
    **/
    count<T extends AccountUserCountArgs>(
      args?: Subset<T, AccountUserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountUserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccountUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountUserAggregateArgs>(args: Subset<T, AccountUserAggregateArgs>): Prisma.PrismaPromise<GetAccountUserAggregateType<T>>

    /**
     * Group by AccountUser.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountUserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountUserGroupByArgs['orderBy'] }
        : { orderBy?: AccountUserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountUserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccountUser model
   */
  readonly fields: AccountUserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccountUser.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountUserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    profile<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccountUser model
   */
  interface AccountUserFieldRefs {
    readonly id: FieldRef<"AccountUser", 'String'>
    readonly accountId: FieldRef<"AccountUser", 'String'>
    readonly userId: FieldRef<"AccountUser", 'String'>
    readonly clientRole: FieldRef<"AccountUser", 'ClientRole'>
    readonly createdAt: FieldRef<"AccountUser", 'DateTime'>
    readonly updatedAt: FieldRef<"AccountUser", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccountUser findUnique
   */
  export type AccountUserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * Filter, which AccountUser to fetch.
     */
    where: AccountUserWhereUniqueInput
  }

  /**
   * AccountUser findUniqueOrThrow
   */
  export type AccountUserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * Filter, which AccountUser to fetch.
     */
    where: AccountUserWhereUniqueInput
  }

  /**
   * AccountUser findFirst
   */
  export type AccountUserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * Filter, which AccountUser to fetch.
     */
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     */
    orderBy?: AccountUserOrderByWithRelationInput | AccountUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountUsers.
     */
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountUsers.
     */
    distinct?: AccountUserScalarFieldEnum | AccountUserScalarFieldEnum[]
  }

  /**
   * AccountUser findFirstOrThrow
   */
  export type AccountUserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * Filter, which AccountUser to fetch.
     */
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     */
    orderBy?: AccountUserOrderByWithRelationInput | AccountUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccountUsers.
     */
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccountUsers.
     */
    distinct?: AccountUserScalarFieldEnum | AccountUserScalarFieldEnum[]
  }

  /**
   * AccountUser findMany
   */
  export type AccountUserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * Filter, which AccountUsers to fetch.
     */
    where?: AccountUserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccountUsers to fetch.
     */
    orderBy?: AccountUserOrderByWithRelationInput | AccountUserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccountUsers.
     */
    cursor?: AccountUserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccountUsers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccountUsers.
     */
    skip?: number
    distinct?: AccountUserScalarFieldEnum | AccountUserScalarFieldEnum[]
  }

  /**
   * AccountUser create
   */
  export type AccountUserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * The data needed to create a AccountUser.
     */
    data: XOR<AccountUserCreateInput, AccountUserUncheckedCreateInput>
  }

  /**
   * AccountUser createMany
   */
  export type AccountUserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccountUsers.
     */
    data: AccountUserCreateManyInput | AccountUserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccountUser createManyAndReturn
   */
  export type AccountUserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * The data used to create many AccountUsers.
     */
    data: AccountUserCreateManyInput | AccountUserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountUser update
   */
  export type AccountUserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * The data needed to update a AccountUser.
     */
    data: XOR<AccountUserUpdateInput, AccountUserUncheckedUpdateInput>
    /**
     * Choose, which AccountUser to update.
     */
    where: AccountUserWhereUniqueInput
  }

  /**
   * AccountUser updateMany
   */
  export type AccountUserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccountUsers.
     */
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyInput>
    /**
     * Filter which AccountUsers to update
     */
    where?: AccountUserWhereInput
    /**
     * Limit how many AccountUsers to update.
     */
    limit?: number
  }

  /**
   * AccountUser updateManyAndReturn
   */
  export type AccountUserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * The data used to update AccountUsers.
     */
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyInput>
    /**
     * Filter which AccountUsers to update
     */
    where?: AccountUserWhereInput
    /**
     * Limit how many AccountUsers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccountUser upsert
   */
  export type AccountUserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * The filter to search for the AccountUser to update in case it exists.
     */
    where: AccountUserWhereUniqueInput
    /**
     * In case the AccountUser found by the `where` argument doesn't exist, create a new AccountUser with this data.
     */
    create: XOR<AccountUserCreateInput, AccountUserUncheckedCreateInput>
    /**
     * In case the AccountUser was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUserUpdateInput, AccountUserUncheckedUpdateInput>
  }

  /**
   * AccountUser delete
   */
  export type AccountUserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
    /**
     * Filter which AccountUser to delete.
     */
    where: AccountUserWhereUniqueInput
  }

  /**
   * AccountUser deleteMany
   */
  export type AccountUserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccountUsers to delete
     */
    where?: AccountUserWhereInput
    /**
     * Limit how many AccountUsers to delete.
     */
    limit?: number
  }

  /**
   * AccountUser without action
   */
  export type AccountUserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountUser
     */
    select?: AccountUserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccountUser
     */
    omit?: AccountUserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountUserInclude<ExtArgs> | null
  }


  /**
   * Model ClientEntity
   */

  export type AggregateClientEntity = {
    _count: ClientEntityCountAggregateOutputType | null
    _min: ClientEntityMinAggregateOutputType | null
    _max: ClientEntityMaxAggregateOutputType | null
  }

  export type ClientEntityMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    entityName: string | null
    entityType: $Enums.EntityType | null
    status: string | null
    isRestricted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientEntityMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    entityName: string | null
    entityType: $Enums.EntityType | null
    status: string | null
    isRestricted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientEntityCountAggregateOutputType = {
    id: number
    accountId: number
    entityName: number
    entityType: number
    status: number
    isRestricted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientEntityMinAggregateInputType = {
    id?: true
    accountId?: true
    entityName?: true
    entityType?: true
    status?: true
    isRestricted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientEntityMaxAggregateInputType = {
    id?: true
    accountId?: true
    entityName?: true
    entityType?: true
    status?: true
    isRestricted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientEntityCountAggregateInputType = {
    id?: true
    accountId?: true
    entityName?: true
    entityType?: true
    status?: true
    isRestricted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientEntityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEntity to aggregate.
     */
    where?: ClientEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntities to fetch.
     */
    orderBy?: ClientEntityOrderByWithRelationInput | ClientEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientEntities
    **/
    _count?: true | ClientEntityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientEntityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientEntityMaxAggregateInputType
  }

  export type GetClientEntityAggregateType<T extends ClientEntityAggregateArgs> = {
        [P in keyof T & keyof AggregateClientEntity]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientEntity[P]>
      : GetScalarType<T[P], AggregateClientEntity[P]>
  }




  export type ClientEntityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientEntityWhereInput
    orderBy?: ClientEntityOrderByWithAggregationInput | ClientEntityOrderByWithAggregationInput[]
    by: ClientEntityScalarFieldEnum[] | ClientEntityScalarFieldEnum
    having?: ClientEntityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientEntityCountAggregateInputType | true
    _min?: ClientEntityMinAggregateInputType
    _max?: ClientEntityMaxAggregateInputType
  }

  export type ClientEntityGroupByOutputType = {
    id: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status: string | null
    isRestricted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClientEntityCountAggregateOutputType | null
    _min: ClientEntityMinAggregateOutputType | null
    _max: ClientEntityMaxAggregateOutputType | null
  }

  type GetClientEntityGroupByPayload<T extends ClientEntityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientEntityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientEntityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientEntityGroupByOutputType[P]>
            : GetScalarType<T[P], ClientEntityGroupByOutputType[P]>
        }
      >
    >


  export type ClientEntitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    entityName?: boolean
    entityType?: boolean
    status?: boolean
    isRestricted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    entityTaxYears?: boolean | ClientEntity$entityTaxYearsArgs<ExtArgs>
    folders?: boolean | ClientEntity$foldersArgs<ExtArgs>
    documents?: boolean | ClientEntity$documentsArgs<ExtArgs>
    clientAcl?: boolean | ClientEntity$clientAclArgs<ExtArgs>
    clientStaffPermissions?: boolean | ClientEntity$clientStaffPermissionsArgs<ExtArgs>
    clientStaffAssignments?: boolean | ClientEntity$clientStaffAssignmentsArgs<ExtArgs>
    _count?: boolean | ClientEntityCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientEntity"]>

  export type ClientEntitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    entityName?: boolean
    entityType?: boolean
    status?: boolean
    isRestricted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientEntity"]>

  export type ClientEntitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    entityName?: boolean
    entityType?: boolean
    status?: boolean
    isRestricted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientEntity"]>

  export type ClientEntitySelectScalar = {
    id?: boolean
    accountId?: boolean
    entityName?: boolean
    entityType?: boolean
    status?: boolean
    isRestricted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientEntityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "entityName" | "entityType" | "status" | "isRestricted" | "createdAt" | "updatedAt", ExtArgs["result"]["clientEntity"]>
  export type ClientEntityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    entityTaxYears?: boolean | ClientEntity$entityTaxYearsArgs<ExtArgs>
    folders?: boolean | ClientEntity$foldersArgs<ExtArgs>
    documents?: boolean | ClientEntity$documentsArgs<ExtArgs>
    clientAcl?: boolean | ClientEntity$clientAclArgs<ExtArgs>
    clientStaffPermissions?: boolean | ClientEntity$clientStaffPermissionsArgs<ExtArgs>
    clientStaffAssignments?: boolean | ClientEntity$clientStaffAssignmentsArgs<ExtArgs>
    _count?: boolean | ClientEntityCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClientEntityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type ClientEntityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $ClientEntityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientEntity"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      entityTaxYears: Prisma.$EntityTaxYearPayload<ExtArgs>[]
      folders: Prisma.$FolderPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      clientAcl: Prisma.$ClientAclPayload<ExtArgs>[]
      clientStaffPermissions: Prisma.$ClientStaffPermissionPayload<ExtArgs>[]
      clientStaffAssignments: Prisma.$ClientStaffAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      entityName: string
      entityType: $Enums.EntityType
      status: string | null
      isRestricted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientEntity"]>
    composites: {}
  }

  type ClientEntityGetPayload<S extends boolean | null | undefined | ClientEntityDefaultArgs> = $Result.GetResult<Prisma.$ClientEntityPayload, S>

  type ClientEntityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientEntityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientEntityCountAggregateInputType | true
    }

  export interface ClientEntityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientEntity'], meta: { name: 'ClientEntity' } }
    /**
     * Find zero or one ClientEntity that matches the filter.
     * @param {ClientEntityFindUniqueArgs} args - Arguments to find a ClientEntity
     * @example
     * // Get one ClientEntity
     * const clientEntity = await prisma.clientEntity.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientEntityFindUniqueArgs>(args: SelectSubset<T, ClientEntityFindUniqueArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientEntity that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientEntityFindUniqueOrThrowArgs} args - Arguments to find a ClientEntity
     * @example
     * // Get one ClientEntity
     * const clientEntity = await prisma.clientEntity.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientEntityFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientEntityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientEntity that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityFindFirstArgs} args - Arguments to find a ClientEntity
     * @example
     * // Get one ClientEntity
     * const clientEntity = await prisma.clientEntity.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientEntityFindFirstArgs>(args?: SelectSubset<T, ClientEntityFindFirstArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientEntity that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityFindFirstOrThrowArgs} args - Arguments to find a ClientEntity
     * @example
     * // Get one ClientEntity
     * const clientEntity = await prisma.clientEntity.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientEntityFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientEntityFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientEntities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientEntities
     * const clientEntities = await prisma.clientEntity.findMany()
     * 
     * // Get first 10 ClientEntities
     * const clientEntities = await prisma.clientEntity.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientEntityWithIdOnly = await prisma.clientEntity.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientEntityFindManyArgs>(args?: SelectSubset<T, ClientEntityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientEntity.
     * @param {ClientEntityCreateArgs} args - Arguments to create a ClientEntity.
     * @example
     * // Create one ClientEntity
     * const ClientEntity = await prisma.clientEntity.create({
     *   data: {
     *     // ... data to create a ClientEntity
     *   }
     * })
     * 
     */
    create<T extends ClientEntityCreateArgs>(args: SelectSubset<T, ClientEntityCreateArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientEntities.
     * @param {ClientEntityCreateManyArgs} args - Arguments to create many ClientEntities.
     * @example
     * // Create many ClientEntities
     * const clientEntity = await prisma.clientEntity.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientEntityCreateManyArgs>(args?: SelectSubset<T, ClientEntityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientEntities and returns the data saved in the database.
     * @param {ClientEntityCreateManyAndReturnArgs} args - Arguments to create many ClientEntities.
     * @example
     * // Create many ClientEntities
     * const clientEntity = await prisma.clientEntity.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientEntities and only return the `id`
     * const clientEntityWithIdOnly = await prisma.clientEntity.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientEntityCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientEntityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientEntity.
     * @param {ClientEntityDeleteArgs} args - Arguments to delete one ClientEntity.
     * @example
     * // Delete one ClientEntity
     * const ClientEntity = await prisma.clientEntity.delete({
     *   where: {
     *     // ... filter to delete one ClientEntity
     *   }
     * })
     * 
     */
    delete<T extends ClientEntityDeleteArgs>(args: SelectSubset<T, ClientEntityDeleteArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientEntity.
     * @param {ClientEntityUpdateArgs} args - Arguments to update one ClientEntity.
     * @example
     * // Update one ClientEntity
     * const clientEntity = await prisma.clientEntity.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientEntityUpdateArgs>(args: SelectSubset<T, ClientEntityUpdateArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientEntities.
     * @param {ClientEntityDeleteManyArgs} args - Arguments to filter ClientEntities to delete.
     * @example
     * // Delete a few ClientEntities
     * const { count } = await prisma.clientEntity.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientEntityDeleteManyArgs>(args?: SelectSubset<T, ClientEntityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientEntities
     * const clientEntity = await prisma.clientEntity.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientEntityUpdateManyArgs>(args: SelectSubset<T, ClientEntityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientEntities and returns the data updated in the database.
     * @param {ClientEntityUpdateManyAndReturnArgs} args - Arguments to update many ClientEntities.
     * @example
     * // Update many ClientEntities
     * const clientEntity = await prisma.clientEntity.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientEntities and only return the `id`
     * const clientEntityWithIdOnly = await prisma.clientEntity.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientEntityUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientEntityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientEntity.
     * @param {ClientEntityUpsertArgs} args - Arguments to update or create a ClientEntity.
     * @example
     * // Update or create a ClientEntity
     * const clientEntity = await prisma.clientEntity.upsert({
     *   create: {
     *     // ... data to create a ClientEntity
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientEntity we want to update
     *   }
     * })
     */
    upsert<T extends ClientEntityUpsertArgs>(args: SelectSubset<T, ClientEntityUpsertArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientEntities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityCountArgs} args - Arguments to filter ClientEntities to count.
     * @example
     * // Count the number of ClientEntities
     * const count = await prisma.clientEntity.count({
     *   where: {
     *     // ... the filter for the ClientEntities we want to count
     *   }
     * })
    **/
    count<T extends ClientEntityCountArgs>(
      args?: Subset<T, ClientEntityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientEntityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientEntityAggregateArgs>(args: Subset<T, ClientEntityAggregateArgs>): Prisma.PrismaPromise<GetClientEntityAggregateType<T>>

    /**
     * Group by ClientEntity.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientEntityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientEntityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientEntityGroupByArgs['orderBy'] }
        : { orderBy?: ClientEntityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientEntityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientEntityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientEntity model
   */
  readonly fields: ClientEntityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientEntity.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientEntityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    entityTaxYears<T extends ClientEntity$entityTaxYearsArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntity$entityTaxYearsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folders<T extends ClientEntity$foldersArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntity$foldersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends ClientEntity$documentsArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntity$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientAcl<T extends ClientEntity$clientAclArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntity$clientAclArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientStaffPermissions<T extends ClientEntity$clientStaffPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntity$clientStaffPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    clientStaffAssignments<T extends ClientEntity$clientStaffAssignmentsArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntity$clientStaffAssignmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientEntity model
   */
  interface ClientEntityFieldRefs {
    readonly id: FieldRef<"ClientEntity", 'String'>
    readonly accountId: FieldRef<"ClientEntity", 'String'>
    readonly entityName: FieldRef<"ClientEntity", 'String'>
    readonly entityType: FieldRef<"ClientEntity", 'EntityType'>
    readonly status: FieldRef<"ClientEntity", 'String'>
    readonly isRestricted: FieldRef<"ClientEntity", 'Boolean'>
    readonly createdAt: FieldRef<"ClientEntity", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientEntity", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientEntity findUnique
   */
  export type ClientEntityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntity to fetch.
     */
    where: ClientEntityWhereUniqueInput
  }

  /**
   * ClientEntity findUniqueOrThrow
   */
  export type ClientEntityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntity to fetch.
     */
    where: ClientEntityWhereUniqueInput
  }

  /**
   * ClientEntity findFirst
   */
  export type ClientEntityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntity to fetch.
     */
    where?: ClientEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntities to fetch.
     */
    orderBy?: ClientEntityOrderByWithRelationInput | ClientEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEntities.
     */
    cursor?: ClientEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEntities.
     */
    distinct?: ClientEntityScalarFieldEnum | ClientEntityScalarFieldEnum[]
  }

  /**
   * ClientEntity findFirstOrThrow
   */
  export type ClientEntityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntity to fetch.
     */
    where?: ClientEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntities to fetch.
     */
    orderBy?: ClientEntityOrderByWithRelationInput | ClientEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientEntities.
     */
    cursor?: ClientEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientEntities.
     */
    distinct?: ClientEntityScalarFieldEnum | ClientEntityScalarFieldEnum[]
  }

  /**
   * ClientEntity findMany
   */
  export type ClientEntityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * Filter, which ClientEntities to fetch.
     */
    where?: ClientEntityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientEntities to fetch.
     */
    orderBy?: ClientEntityOrderByWithRelationInput | ClientEntityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientEntities.
     */
    cursor?: ClientEntityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientEntities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientEntities.
     */
    skip?: number
    distinct?: ClientEntityScalarFieldEnum | ClientEntityScalarFieldEnum[]
  }

  /**
   * ClientEntity create
   */
  export type ClientEntityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientEntity.
     */
    data: XOR<ClientEntityCreateInput, ClientEntityUncheckedCreateInput>
  }

  /**
   * ClientEntity createMany
   */
  export type ClientEntityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientEntities.
     */
    data: ClientEntityCreateManyInput | ClientEntityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientEntity createManyAndReturn
   */
  export type ClientEntityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * The data used to create many ClientEntities.
     */
    data: ClientEntityCreateManyInput | ClientEntityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientEntity update
   */
  export type ClientEntityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientEntity.
     */
    data: XOR<ClientEntityUpdateInput, ClientEntityUncheckedUpdateInput>
    /**
     * Choose, which ClientEntity to update.
     */
    where: ClientEntityWhereUniqueInput
  }

  /**
   * ClientEntity updateMany
   */
  export type ClientEntityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientEntities.
     */
    data: XOR<ClientEntityUpdateManyMutationInput, ClientEntityUncheckedUpdateManyInput>
    /**
     * Filter which ClientEntities to update
     */
    where?: ClientEntityWhereInput
    /**
     * Limit how many ClientEntities to update.
     */
    limit?: number
  }

  /**
   * ClientEntity updateManyAndReturn
   */
  export type ClientEntityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * The data used to update ClientEntities.
     */
    data: XOR<ClientEntityUpdateManyMutationInput, ClientEntityUncheckedUpdateManyInput>
    /**
     * Filter which ClientEntities to update
     */
    where?: ClientEntityWhereInput
    /**
     * Limit how many ClientEntities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientEntity upsert
   */
  export type ClientEntityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientEntity to update in case it exists.
     */
    where: ClientEntityWhereUniqueInput
    /**
     * In case the ClientEntity found by the `where` argument doesn't exist, create a new ClientEntity with this data.
     */
    create: XOR<ClientEntityCreateInput, ClientEntityUncheckedCreateInput>
    /**
     * In case the ClientEntity was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientEntityUpdateInput, ClientEntityUncheckedUpdateInput>
  }

  /**
   * ClientEntity delete
   */
  export type ClientEntityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
    /**
     * Filter which ClientEntity to delete.
     */
    where: ClientEntityWhereUniqueInput
  }

  /**
   * ClientEntity deleteMany
   */
  export type ClientEntityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientEntities to delete
     */
    where?: ClientEntityWhereInput
    /**
     * Limit how many ClientEntities to delete.
     */
    limit?: number
  }

  /**
   * ClientEntity.entityTaxYears
   */
  export type ClientEntity$entityTaxYearsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    where?: EntityTaxYearWhereInput
    orderBy?: EntityTaxYearOrderByWithRelationInput | EntityTaxYearOrderByWithRelationInput[]
    cursor?: EntityTaxYearWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EntityTaxYearScalarFieldEnum | EntityTaxYearScalarFieldEnum[]
  }

  /**
   * ClientEntity.folders
   */
  export type ClientEntity$foldersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * ClientEntity.documents
   */
  export type ClientEntity$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * ClientEntity.clientAcl
   */
  export type ClientEntity$clientAclArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    where?: ClientAclWhereInput
    orderBy?: ClientAclOrderByWithRelationInput | ClientAclOrderByWithRelationInput[]
    cursor?: ClientAclWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientAclScalarFieldEnum | ClientAclScalarFieldEnum[]
  }

  /**
   * ClientEntity.clientStaffPermissions
   */
  export type ClientEntity$clientStaffPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    where?: ClientStaffPermissionWhereInput
    orderBy?: ClientStaffPermissionOrderByWithRelationInput | ClientStaffPermissionOrderByWithRelationInput[]
    cursor?: ClientStaffPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientStaffPermissionScalarFieldEnum | ClientStaffPermissionScalarFieldEnum[]
  }

  /**
   * ClientEntity.clientStaffAssignments
   */
  export type ClientEntity$clientStaffAssignmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    where?: ClientStaffAssignmentWhereInput
    orderBy?: ClientStaffAssignmentOrderByWithRelationInput | ClientStaffAssignmentOrderByWithRelationInput[]
    cursor?: ClientStaffAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClientStaffAssignmentScalarFieldEnum | ClientStaffAssignmentScalarFieldEnum[]
  }

  /**
   * ClientEntity without action
   */
  export type ClientEntityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientEntity
     */
    select?: ClientEntitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientEntity
     */
    omit?: ClientEntityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientEntityInclude<ExtArgs> | null
  }


  /**
   * Model EntityTaxYear
   */

  export type AggregateEntityTaxYear = {
    _count: EntityTaxYearCountAggregateOutputType | null
    _avg: EntityTaxYearAvgAggregateOutputType | null
    _sum: EntityTaxYearSumAggregateOutputType | null
    _min: EntityTaxYearMinAggregateOutputType | null
    _max: EntityTaxYearMaxAggregateOutputType | null
  }

  export type EntityTaxYearAvgAggregateOutputType = {
    taxYear: number | null
    attemptCount: number | null
    docsRequiredCount: number | null
    docsReceivedCount: number | null
  }

  export type EntityTaxYearSumAggregateOutputType = {
    taxYear: number | null
    attemptCount: number | null
    docsRequiredCount: number | null
    docsReceivedCount: number | null
  }

  export type EntityTaxYearMinAggregateOutputType = {
    id: string | null
    clientEntityId: string | null
    taxYear: number | null
    taxReturnExpected: boolean | null
    inviteStatus: $Enums.InviteStatus | null
    inviteSentAt: Date | null
    attemptCount: number | null
    lastError: string | null
    engagementStatus: $Enums.EngagementStatus | null
    engagementSignedAt: Date | null
    engagementSigner1Id: string | null
    engagementSigner2Id: string | null
    docsRequiredCount: number | null
    docsReceivedCount: number | null
    checklistCompleteAt: Date | null
    docConfirmationStatus: $Enums.ConfirmationStatus | null
    docConfirmationSignedAt: Date | null
    docConfirmationSignerId: string | null
    questionnaireStatus: $Enums.QuestionnaireStatus | null
    questionnaireCompletedAt: Date | null
    idStatus: $Enums.IdStatus | null
    idValidUntil: Date | null
    readyForPrep: boolean | null
    extensionRequested: boolean | null
    extensionFiled: boolean | null
    extendedDueDate: Date | null
    internalStatus: $Enums.InternalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntityTaxYearMaxAggregateOutputType = {
    id: string | null
    clientEntityId: string | null
    taxYear: number | null
    taxReturnExpected: boolean | null
    inviteStatus: $Enums.InviteStatus | null
    inviteSentAt: Date | null
    attemptCount: number | null
    lastError: string | null
    engagementStatus: $Enums.EngagementStatus | null
    engagementSignedAt: Date | null
    engagementSigner1Id: string | null
    engagementSigner2Id: string | null
    docsRequiredCount: number | null
    docsReceivedCount: number | null
    checklistCompleteAt: Date | null
    docConfirmationStatus: $Enums.ConfirmationStatus | null
    docConfirmationSignedAt: Date | null
    docConfirmationSignerId: string | null
    questionnaireStatus: $Enums.QuestionnaireStatus | null
    questionnaireCompletedAt: Date | null
    idStatus: $Enums.IdStatus | null
    idValidUntil: Date | null
    readyForPrep: boolean | null
    extensionRequested: boolean | null
    extensionFiled: boolean | null
    extendedDueDate: Date | null
    internalStatus: $Enums.InternalStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EntityTaxYearCountAggregateOutputType = {
    id: number
    clientEntityId: number
    taxYear: number
    taxReturnExpected: number
    inviteStatus: number
    inviteSentAt: number
    attemptCount: number
    lastError: number
    engagementStatus: number
    engagementSignedAt: number
    engagementSigner1Id: number
    engagementSigner2Id: number
    docsRequiredCount: number
    docsReceivedCount: number
    checklistCompleteAt: number
    docConfirmationStatus: number
    docConfirmationSignedAt: number
    docConfirmationSignerId: number
    questionnaireStatus: number
    questionnaireCompletedAt: number
    idStatus: number
    idValidUntil: number
    readyForPrep: number
    extensionRequested: number
    extensionFiled: number
    extendedDueDate: number
    internalStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EntityTaxYearAvgAggregateInputType = {
    taxYear?: true
    attemptCount?: true
    docsRequiredCount?: true
    docsReceivedCount?: true
  }

  export type EntityTaxYearSumAggregateInputType = {
    taxYear?: true
    attemptCount?: true
    docsRequiredCount?: true
    docsReceivedCount?: true
  }

  export type EntityTaxYearMinAggregateInputType = {
    id?: true
    clientEntityId?: true
    taxYear?: true
    taxReturnExpected?: true
    inviteStatus?: true
    inviteSentAt?: true
    attemptCount?: true
    lastError?: true
    engagementStatus?: true
    engagementSignedAt?: true
    engagementSigner1Id?: true
    engagementSigner2Id?: true
    docsRequiredCount?: true
    docsReceivedCount?: true
    checklistCompleteAt?: true
    docConfirmationStatus?: true
    docConfirmationSignedAt?: true
    docConfirmationSignerId?: true
    questionnaireStatus?: true
    questionnaireCompletedAt?: true
    idStatus?: true
    idValidUntil?: true
    readyForPrep?: true
    extensionRequested?: true
    extensionFiled?: true
    extendedDueDate?: true
    internalStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntityTaxYearMaxAggregateInputType = {
    id?: true
    clientEntityId?: true
    taxYear?: true
    taxReturnExpected?: true
    inviteStatus?: true
    inviteSentAt?: true
    attemptCount?: true
    lastError?: true
    engagementStatus?: true
    engagementSignedAt?: true
    engagementSigner1Id?: true
    engagementSigner2Id?: true
    docsRequiredCount?: true
    docsReceivedCount?: true
    checklistCompleteAt?: true
    docConfirmationStatus?: true
    docConfirmationSignedAt?: true
    docConfirmationSignerId?: true
    questionnaireStatus?: true
    questionnaireCompletedAt?: true
    idStatus?: true
    idValidUntil?: true
    readyForPrep?: true
    extensionRequested?: true
    extensionFiled?: true
    extendedDueDate?: true
    internalStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EntityTaxYearCountAggregateInputType = {
    id?: true
    clientEntityId?: true
    taxYear?: true
    taxReturnExpected?: true
    inviteStatus?: true
    inviteSentAt?: true
    attemptCount?: true
    lastError?: true
    engagementStatus?: true
    engagementSignedAt?: true
    engagementSigner1Id?: true
    engagementSigner2Id?: true
    docsRequiredCount?: true
    docsReceivedCount?: true
    checklistCompleteAt?: true
    docConfirmationStatus?: true
    docConfirmationSignedAt?: true
    docConfirmationSignerId?: true
    questionnaireStatus?: true
    questionnaireCompletedAt?: true
    idStatus?: true
    idValidUntil?: true
    readyForPrep?: true
    extensionRequested?: true
    extensionFiled?: true
    extendedDueDate?: true
    internalStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EntityTaxYearAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityTaxYear to aggregate.
     */
    where?: EntityTaxYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityTaxYears to fetch.
     */
    orderBy?: EntityTaxYearOrderByWithRelationInput | EntityTaxYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EntityTaxYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityTaxYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityTaxYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EntityTaxYears
    **/
    _count?: true | EntityTaxYearCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EntityTaxYearAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EntityTaxYearSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EntityTaxYearMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EntityTaxYearMaxAggregateInputType
  }

  export type GetEntityTaxYearAggregateType<T extends EntityTaxYearAggregateArgs> = {
        [P in keyof T & keyof AggregateEntityTaxYear]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEntityTaxYear[P]>
      : GetScalarType<T[P], AggregateEntityTaxYear[P]>
  }




  export type EntityTaxYearGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EntityTaxYearWhereInput
    orderBy?: EntityTaxYearOrderByWithAggregationInput | EntityTaxYearOrderByWithAggregationInput[]
    by: EntityTaxYearScalarFieldEnum[] | EntityTaxYearScalarFieldEnum
    having?: EntityTaxYearScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EntityTaxYearCountAggregateInputType | true
    _avg?: EntityTaxYearAvgAggregateInputType
    _sum?: EntityTaxYearSumAggregateInputType
    _min?: EntityTaxYearMinAggregateInputType
    _max?: EntityTaxYearMaxAggregateInputType
  }

  export type EntityTaxYearGroupByOutputType = {
    id: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected: boolean
    inviteStatus: $Enums.InviteStatus
    inviteSentAt: Date | null
    attemptCount: number
    lastError: string | null
    engagementStatus: $Enums.EngagementStatus
    engagementSignedAt: Date | null
    engagementSigner1Id: string | null
    engagementSigner2Id: string | null
    docsRequiredCount: number
    docsReceivedCount: number
    checklistCompleteAt: Date | null
    docConfirmationStatus: $Enums.ConfirmationStatus
    docConfirmationSignedAt: Date | null
    docConfirmationSignerId: string | null
    questionnaireStatus: $Enums.QuestionnaireStatus
    questionnaireCompletedAt: Date | null
    idStatus: $Enums.IdStatus
    idValidUntil: Date | null
    readyForPrep: boolean
    extensionRequested: boolean
    extensionFiled: boolean
    extendedDueDate: Date | null
    internalStatus: $Enums.InternalStatus
    createdAt: Date
    updatedAt: Date
    _count: EntityTaxYearCountAggregateOutputType | null
    _avg: EntityTaxYearAvgAggregateOutputType | null
    _sum: EntityTaxYearSumAggregateOutputType | null
    _min: EntityTaxYearMinAggregateOutputType | null
    _max: EntityTaxYearMaxAggregateOutputType | null
  }

  type GetEntityTaxYearGroupByPayload<T extends EntityTaxYearGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EntityTaxYearGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EntityTaxYearGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EntityTaxYearGroupByOutputType[P]>
            : GetScalarType<T[P], EntityTaxYearGroupByOutputType[P]>
        }
      >
    >


  export type EntityTaxYearSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientEntityId?: boolean
    taxYear?: boolean
    taxReturnExpected?: boolean
    inviteStatus?: boolean
    inviteSentAt?: boolean
    attemptCount?: boolean
    lastError?: boolean
    engagementStatus?: boolean
    engagementSignedAt?: boolean
    engagementSigner1Id?: boolean
    engagementSigner2Id?: boolean
    docsRequiredCount?: boolean
    docsReceivedCount?: boolean
    checklistCompleteAt?: boolean
    docConfirmationStatus?: boolean
    docConfirmationSignedAt?: boolean
    docConfirmationSignerId?: boolean
    questionnaireStatus?: boolean
    questionnaireCompletedAt?: boolean
    idStatus?: boolean
    idValidUntil?: boolean
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: boolean
    internalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    checklistItems?: boolean | EntityTaxYear$checklistItemsArgs<ExtArgs>
    questionnaireAnswers?: boolean | EntityTaxYear$questionnaireAnswersArgs<ExtArgs>
    messageThread?: boolean | EntityTaxYear$messageThreadArgs<ExtArgs>
    reminderState?: boolean | EntityTaxYear$reminderStateArgs<ExtArgs>
    statusAuditLogs?: boolean | EntityTaxYear$statusAuditLogsArgs<ExtArgs>
    documentEvents?: boolean | EntityTaxYear$documentEventsArgs<ExtArgs>
    engagementSignatures?: boolean | EntityTaxYear$engagementSignaturesArgs<ExtArgs>
    efileAuthorizations?: boolean | EntityTaxYear$efileAuthorizationsArgs<ExtArgs>
    _count?: boolean | EntityTaxYearCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entityTaxYear"]>

  export type EntityTaxYearSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientEntityId?: boolean
    taxYear?: boolean
    taxReturnExpected?: boolean
    inviteStatus?: boolean
    inviteSentAt?: boolean
    attemptCount?: boolean
    lastError?: boolean
    engagementStatus?: boolean
    engagementSignedAt?: boolean
    engagementSigner1Id?: boolean
    engagementSigner2Id?: boolean
    docsRequiredCount?: boolean
    docsReceivedCount?: boolean
    checklistCompleteAt?: boolean
    docConfirmationStatus?: boolean
    docConfirmationSignedAt?: boolean
    docConfirmationSignerId?: boolean
    questionnaireStatus?: boolean
    questionnaireCompletedAt?: boolean
    idStatus?: boolean
    idValidUntil?: boolean
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: boolean
    internalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entityTaxYear"]>

  export type EntityTaxYearSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientEntityId?: boolean
    taxYear?: boolean
    taxReturnExpected?: boolean
    inviteStatus?: boolean
    inviteSentAt?: boolean
    attemptCount?: boolean
    lastError?: boolean
    engagementStatus?: boolean
    engagementSignedAt?: boolean
    engagementSigner1Id?: boolean
    engagementSigner2Id?: boolean
    docsRequiredCount?: boolean
    docsReceivedCount?: boolean
    checklistCompleteAt?: boolean
    docConfirmationStatus?: boolean
    docConfirmationSignedAt?: boolean
    docConfirmationSignerId?: boolean
    questionnaireStatus?: boolean
    questionnaireCompletedAt?: boolean
    idStatus?: boolean
    idValidUntil?: boolean
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: boolean
    internalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["entityTaxYear"]>

  export type EntityTaxYearSelectScalar = {
    id?: boolean
    clientEntityId?: boolean
    taxYear?: boolean
    taxReturnExpected?: boolean
    inviteStatus?: boolean
    inviteSentAt?: boolean
    attemptCount?: boolean
    lastError?: boolean
    engagementStatus?: boolean
    engagementSignedAt?: boolean
    engagementSigner1Id?: boolean
    engagementSigner2Id?: boolean
    docsRequiredCount?: boolean
    docsReceivedCount?: boolean
    checklistCompleteAt?: boolean
    docConfirmationStatus?: boolean
    docConfirmationSignedAt?: boolean
    docConfirmationSignerId?: boolean
    questionnaireStatus?: boolean
    questionnaireCompletedAt?: boolean
    idStatus?: boolean
    idValidUntil?: boolean
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: boolean
    internalStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EntityTaxYearOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientEntityId" | "taxYear" | "taxReturnExpected" | "inviteStatus" | "inviteSentAt" | "attemptCount" | "lastError" | "engagementStatus" | "engagementSignedAt" | "engagementSigner1Id" | "engagementSigner2Id" | "docsRequiredCount" | "docsReceivedCount" | "checklistCompleteAt" | "docConfirmationStatus" | "docConfirmationSignedAt" | "docConfirmationSignerId" | "questionnaireStatus" | "questionnaireCompletedAt" | "idStatus" | "idValidUntil" | "readyForPrep" | "extensionRequested" | "extensionFiled" | "extendedDueDate" | "internalStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["entityTaxYear"]>
  export type EntityTaxYearInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    checklistItems?: boolean | EntityTaxYear$checklistItemsArgs<ExtArgs>
    questionnaireAnswers?: boolean | EntityTaxYear$questionnaireAnswersArgs<ExtArgs>
    messageThread?: boolean | EntityTaxYear$messageThreadArgs<ExtArgs>
    reminderState?: boolean | EntityTaxYear$reminderStateArgs<ExtArgs>
    statusAuditLogs?: boolean | EntityTaxYear$statusAuditLogsArgs<ExtArgs>
    documentEvents?: boolean | EntityTaxYear$documentEventsArgs<ExtArgs>
    engagementSignatures?: boolean | EntityTaxYear$engagementSignaturesArgs<ExtArgs>
    efileAuthorizations?: boolean | EntityTaxYear$efileAuthorizationsArgs<ExtArgs>
    _count?: boolean | EntityTaxYearCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EntityTaxYearIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
  }
  export type EntityTaxYearIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
  }

  export type $EntityTaxYearPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EntityTaxYear"
    objects: {
      clientEntity: Prisma.$ClientEntityPayload<ExtArgs>
      checklistItems: Prisma.$ChecklistItemPayload<ExtArgs>[]
      questionnaireAnswers: Prisma.$QuestionnaireAnswerPayload<ExtArgs>[]
      messageThread: Prisma.$MessageThreadPayload<ExtArgs> | null
      reminderState: Prisma.$ReminderStatePayload<ExtArgs> | null
      statusAuditLogs: Prisma.$StatusAuditLogPayload<ExtArgs>[]
      documentEvents: Prisma.$DocumentEventPayload<ExtArgs>[]
      engagementSignatures: Prisma.$EngagementSignaturePayload<ExtArgs>[]
      efileAuthorizations: Prisma.$EfileAuthorizationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientEntityId: string
      taxYear: number
      taxReturnExpected: boolean
      inviteStatus: $Enums.InviteStatus
      inviteSentAt: Date | null
      attemptCount: number
      lastError: string | null
      engagementStatus: $Enums.EngagementStatus
      engagementSignedAt: Date | null
      engagementSigner1Id: string | null
      engagementSigner2Id: string | null
      docsRequiredCount: number
      docsReceivedCount: number
      checklistCompleteAt: Date | null
      docConfirmationStatus: $Enums.ConfirmationStatus
      docConfirmationSignedAt: Date | null
      docConfirmationSignerId: string | null
      questionnaireStatus: $Enums.QuestionnaireStatus
      questionnaireCompletedAt: Date | null
      idStatus: $Enums.IdStatus
      idValidUntil: Date | null
      readyForPrep: boolean
      extensionRequested: boolean
      extensionFiled: boolean
      extendedDueDate: Date | null
      internalStatus: $Enums.InternalStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["entityTaxYear"]>
    composites: {}
  }

  type EntityTaxYearGetPayload<S extends boolean | null | undefined | EntityTaxYearDefaultArgs> = $Result.GetResult<Prisma.$EntityTaxYearPayload, S>

  type EntityTaxYearCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EntityTaxYearFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EntityTaxYearCountAggregateInputType | true
    }

  export interface EntityTaxYearDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EntityTaxYear'], meta: { name: 'EntityTaxYear' } }
    /**
     * Find zero or one EntityTaxYear that matches the filter.
     * @param {EntityTaxYearFindUniqueArgs} args - Arguments to find a EntityTaxYear
     * @example
     * // Get one EntityTaxYear
     * const entityTaxYear = await prisma.entityTaxYear.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EntityTaxYearFindUniqueArgs>(args: SelectSubset<T, EntityTaxYearFindUniqueArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EntityTaxYear that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EntityTaxYearFindUniqueOrThrowArgs} args - Arguments to find a EntityTaxYear
     * @example
     * // Get one EntityTaxYear
     * const entityTaxYear = await prisma.entityTaxYear.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EntityTaxYearFindUniqueOrThrowArgs>(args: SelectSubset<T, EntityTaxYearFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EntityTaxYear that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTaxYearFindFirstArgs} args - Arguments to find a EntityTaxYear
     * @example
     * // Get one EntityTaxYear
     * const entityTaxYear = await prisma.entityTaxYear.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EntityTaxYearFindFirstArgs>(args?: SelectSubset<T, EntityTaxYearFindFirstArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EntityTaxYear that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTaxYearFindFirstOrThrowArgs} args - Arguments to find a EntityTaxYear
     * @example
     * // Get one EntityTaxYear
     * const entityTaxYear = await prisma.entityTaxYear.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EntityTaxYearFindFirstOrThrowArgs>(args?: SelectSubset<T, EntityTaxYearFindFirstOrThrowArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EntityTaxYears that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTaxYearFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EntityTaxYears
     * const entityTaxYears = await prisma.entityTaxYear.findMany()
     * 
     * // Get first 10 EntityTaxYears
     * const entityTaxYears = await prisma.entityTaxYear.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const entityTaxYearWithIdOnly = await prisma.entityTaxYear.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EntityTaxYearFindManyArgs>(args?: SelectSubset<T, EntityTaxYearFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EntityTaxYear.
     * @param {EntityTaxYearCreateArgs} args - Arguments to create a EntityTaxYear.
     * @example
     * // Create one EntityTaxYear
     * const EntityTaxYear = await prisma.entityTaxYear.create({
     *   data: {
     *     // ... data to create a EntityTaxYear
     *   }
     * })
     * 
     */
    create<T extends EntityTaxYearCreateArgs>(args: SelectSubset<T, EntityTaxYearCreateArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EntityTaxYears.
     * @param {EntityTaxYearCreateManyArgs} args - Arguments to create many EntityTaxYears.
     * @example
     * // Create many EntityTaxYears
     * const entityTaxYear = await prisma.entityTaxYear.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EntityTaxYearCreateManyArgs>(args?: SelectSubset<T, EntityTaxYearCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EntityTaxYears and returns the data saved in the database.
     * @param {EntityTaxYearCreateManyAndReturnArgs} args - Arguments to create many EntityTaxYears.
     * @example
     * // Create many EntityTaxYears
     * const entityTaxYear = await prisma.entityTaxYear.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EntityTaxYears and only return the `id`
     * const entityTaxYearWithIdOnly = await prisma.entityTaxYear.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EntityTaxYearCreateManyAndReturnArgs>(args?: SelectSubset<T, EntityTaxYearCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EntityTaxYear.
     * @param {EntityTaxYearDeleteArgs} args - Arguments to delete one EntityTaxYear.
     * @example
     * // Delete one EntityTaxYear
     * const EntityTaxYear = await prisma.entityTaxYear.delete({
     *   where: {
     *     // ... filter to delete one EntityTaxYear
     *   }
     * })
     * 
     */
    delete<T extends EntityTaxYearDeleteArgs>(args: SelectSubset<T, EntityTaxYearDeleteArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EntityTaxYear.
     * @param {EntityTaxYearUpdateArgs} args - Arguments to update one EntityTaxYear.
     * @example
     * // Update one EntityTaxYear
     * const entityTaxYear = await prisma.entityTaxYear.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EntityTaxYearUpdateArgs>(args: SelectSubset<T, EntityTaxYearUpdateArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EntityTaxYears.
     * @param {EntityTaxYearDeleteManyArgs} args - Arguments to filter EntityTaxYears to delete.
     * @example
     * // Delete a few EntityTaxYears
     * const { count } = await prisma.entityTaxYear.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EntityTaxYearDeleteManyArgs>(args?: SelectSubset<T, EntityTaxYearDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityTaxYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTaxYearUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EntityTaxYears
     * const entityTaxYear = await prisma.entityTaxYear.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EntityTaxYearUpdateManyArgs>(args: SelectSubset<T, EntityTaxYearUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EntityTaxYears and returns the data updated in the database.
     * @param {EntityTaxYearUpdateManyAndReturnArgs} args - Arguments to update many EntityTaxYears.
     * @example
     * // Update many EntityTaxYears
     * const entityTaxYear = await prisma.entityTaxYear.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EntityTaxYears and only return the `id`
     * const entityTaxYearWithIdOnly = await prisma.entityTaxYear.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EntityTaxYearUpdateManyAndReturnArgs>(args: SelectSubset<T, EntityTaxYearUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EntityTaxYear.
     * @param {EntityTaxYearUpsertArgs} args - Arguments to update or create a EntityTaxYear.
     * @example
     * // Update or create a EntityTaxYear
     * const entityTaxYear = await prisma.entityTaxYear.upsert({
     *   create: {
     *     // ... data to create a EntityTaxYear
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EntityTaxYear we want to update
     *   }
     * })
     */
    upsert<T extends EntityTaxYearUpsertArgs>(args: SelectSubset<T, EntityTaxYearUpsertArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EntityTaxYears.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTaxYearCountArgs} args - Arguments to filter EntityTaxYears to count.
     * @example
     * // Count the number of EntityTaxYears
     * const count = await prisma.entityTaxYear.count({
     *   where: {
     *     // ... the filter for the EntityTaxYears we want to count
     *   }
     * })
    **/
    count<T extends EntityTaxYearCountArgs>(
      args?: Subset<T, EntityTaxYearCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EntityTaxYearCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EntityTaxYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTaxYearAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EntityTaxYearAggregateArgs>(args: Subset<T, EntityTaxYearAggregateArgs>): Prisma.PrismaPromise<GetEntityTaxYearAggregateType<T>>

    /**
     * Group by EntityTaxYear.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EntityTaxYearGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EntityTaxYearGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EntityTaxYearGroupByArgs['orderBy'] }
        : { orderBy?: EntityTaxYearGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EntityTaxYearGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEntityTaxYearGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EntityTaxYear model
   */
  readonly fields: EntityTaxYearFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EntityTaxYear.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EntityTaxYearClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientEntity<T extends ClientEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntityDefaultArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    checklistItems<T extends EntityTaxYear$checklistItemsArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYear$checklistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    questionnaireAnswers<T extends EntityTaxYear$questionnaireAnswersArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYear$questionnaireAnswersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messageThread<T extends EntityTaxYear$messageThreadArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYear$messageThreadArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    reminderState<T extends EntityTaxYear$reminderStateArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYear$reminderStateArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    statusAuditLogs<T extends EntityTaxYear$statusAuditLogsArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYear$statusAuditLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documentEvents<T extends EntityTaxYear$documentEventsArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYear$documentEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    engagementSignatures<T extends EntityTaxYear$engagementSignaturesArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYear$engagementSignaturesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    efileAuthorizations<T extends EntityTaxYear$efileAuthorizationsArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYear$efileAuthorizationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EntityTaxYear model
   */
  interface EntityTaxYearFieldRefs {
    readonly id: FieldRef<"EntityTaxYear", 'String'>
    readonly clientEntityId: FieldRef<"EntityTaxYear", 'String'>
    readonly taxYear: FieldRef<"EntityTaxYear", 'Int'>
    readonly taxReturnExpected: FieldRef<"EntityTaxYear", 'Boolean'>
    readonly inviteStatus: FieldRef<"EntityTaxYear", 'InviteStatus'>
    readonly inviteSentAt: FieldRef<"EntityTaxYear", 'DateTime'>
    readonly attemptCount: FieldRef<"EntityTaxYear", 'Int'>
    readonly lastError: FieldRef<"EntityTaxYear", 'String'>
    readonly engagementStatus: FieldRef<"EntityTaxYear", 'EngagementStatus'>
    readonly engagementSignedAt: FieldRef<"EntityTaxYear", 'DateTime'>
    readonly engagementSigner1Id: FieldRef<"EntityTaxYear", 'String'>
    readonly engagementSigner2Id: FieldRef<"EntityTaxYear", 'String'>
    readonly docsRequiredCount: FieldRef<"EntityTaxYear", 'Int'>
    readonly docsReceivedCount: FieldRef<"EntityTaxYear", 'Int'>
    readonly checklistCompleteAt: FieldRef<"EntityTaxYear", 'DateTime'>
    readonly docConfirmationStatus: FieldRef<"EntityTaxYear", 'ConfirmationStatus'>
    readonly docConfirmationSignedAt: FieldRef<"EntityTaxYear", 'DateTime'>
    readonly docConfirmationSignerId: FieldRef<"EntityTaxYear", 'String'>
    readonly questionnaireStatus: FieldRef<"EntityTaxYear", 'QuestionnaireStatus'>
    readonly questionnaireCompletedAt: FieldRef<"EntityTaxYear", 'DateTime'>
    readonly idStatus: FieldRef<"EntityTaxYear", 'IdStatus'>
    readonly idValidUntil: FieldRef<"EntityTaxYear", 'DateTime'>
    readonly readyForPrep: FieldRef<"EntityTaxYear", 'Boolean'>
    readonly extensionRequested: FieldRef<"EntityTaxYear", 'Boolean'>
    readonly extensionFiled: FieldRef<"EntityTaxYear", 'Boolean'>
    readonly extendedDueDate: FieldRef<"EntityTaxYear", 'DateTime'>
    readonly internalStatus: FieldRef<"EntityTaxYear", 'InternalStatus'>
    readonly createdAt: FieldRef<"EntityTaxYear", 'DateTime'>
    readonly updatedAt: FieldRef<"EntityTaxYear", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EntityTaxYear findUnique
   */
  export type EntityTaxYearFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * Filter, which EntityTaxYear to fetch.
     */
    where: EntityTaxYearWhereUniqueInput
  }

  /**
   * EntityTaxYear findUniqueOrThrow
   */
  export type EntityTaxYearFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * Filter, which EntityTaxYear to fetch.
     */
    where: EntityTaxYearWhereUniqueInput
  }

  /**
   * EntityTaxYear findFirst
   */
  export type EntityTaxYearFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * Filter, which EntityTaxYear to fetch.
     */
    where?: EntityTaxYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityTaxYears to fetch.
     */
    orderBy?: EntityTaxYearOrderByWithRelationInput | EntityTaxYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityTaxYears.
     */
    cursor?: EntityTaxYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityTaxYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityTaxYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityTaxYears.
     */
    distinct?: EntityTaxYearScalarFieldEnum | EntityTaxYearScalarFieldEnum[]
  }

  /**
   * EntityTaxYear findFirstOrThrow
   */
  export type EntityTaxYearFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * Filter, which EntityTaxYear to fetch.
     */
    where?: EntityTaxYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityTaxYears to fetch.
     */
    orderBy?: EntityTaxYearOrderByWithRelationInput | EntityTaxYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EntityTaxYears.
     */
    cursor?: EntityTaxYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityTaxYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityTaxYears.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EntityTaxYears.
     */
    distinct?: EntityTaxYearScalarFieldEnum | EntityTaxYearScalarFieldEnum[]
  }

  /**
   * EntityTaxYear findMany
   */
  export type EntityTaxYearFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * Filter, which EntityTaxYears to fetch.
     */
    where?: EntityTaxYearWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EntityTaxYears to fetch.
     */
    orderBy?: EntityTaxYearOrderByWithRelationInput | EntityTaxYearOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EntityTaxYears.
     */
    cursor?: EntityTaxYearWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EntityTaxYears from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EntityTaxYears.
     */
    skip?: number
    distinct?: EntityTaxYearScalarFieldEnum | EntityTaxYearScalarFieldEnum[]
  }

  /**
   * EntityTaxYear create
   */
  export type EntityTaxYearCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * The data needed to create a EntityTaxYear.
     */
    data: XOR<EntityTaxYearCreateInput, EntityTaxYearUncheckedCreateInput>
  }

  /**
   * EntityTaxYear createMany
   */
  export type EntityTaxYearCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EntityTaxYears.
     */
    data: EntityTaxYearCreateManyInput | EntityTaxYearCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EntityTaxYear createManyAndReturn
   */
  export type EntityTaxYearCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * The data used to create many EntityTaxYears.
     */
    data: EntityTaxYearCreateManyInput | EntityTaxYearCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EntityTaxYear update
   */
  export type EntityTaxYearUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * The data needed to update a EntityTaxYear.
     */
    data: XOR<EntityTaxYearUpdateInput, EntityTaxYearUncheckedUpdateInput>
    /**
     * Choose, which EntityTaxYear to update.
     */
    where: EntityTaxYearWhereUniqueInput
  }

  /**
   * EntityTaxYear updateMany
   */
  export type EntityTaxYearUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EntityTaxYears.
     */
    data: XOR<EntityTaxYearUpdateManyMutationInput, EntityTaxYearUncheckedUpdateManyInput>
    /**
     * Filter which EntityTaxYears to update
     */
    where?: EntityTaxYearWhereInput
    /**
     * Limit how many EntityTaxYears to update.
     */
    limit?: number
  }

  /**
   * EntityTaxYear updateManyAndReturn
   */
  export type EntityTaxYearUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * The data used to update EntityTaxYears.
     */
    data: XOR<EntityTaxYearUpdateManyMutationInput, EntityTaxYearUncheckedUpdateManyInput>
    /**
     * Filter which EntityTaxYears to update
     */
    where?: EntityTaxYearWhereInput
    /**
     * Limit how many EntityTaxYears to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EntityTaxYear upsert
   */
  export type EntityTaxYearUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * The filter to search for the EntityTaxYear to update in case it exists.
     */
    where: EntityTaxYearWhereUniqueInput
    /**
     * In case the EntityTaxYear found by the `where` argument doesn't exist, create a new EntityTaxYear with this data.
     */
    create: XOR<EntityTaxYearCreateInput, EntityTaxYearUncheckedCreateInput>
    /**
     * In case the EntityTaxYear was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EntityTaxYearUpdateInput, EntityTaxYearUncheckedUpdateInput>
  }

  /**
   * EntityTaxYear delete
   */
  export type EntityTaxYearDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
    /**
     * Filter which EntityTaxYear to delete.
     */
    where: EntityTaxYearWhereUniqueInput
  }

  /**
   * EntityTaxYear deleteMany
   */
  export type EntityTaxYearDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EntityTaxYears to delete
     */
    where?: EntityTaxYearWhereInput
    /**
     * Limit how many EntityTaxYears to delete.
     */
    limit?: number
  }

  /**
   * EntityTaxYear.checklistItems
   */
  export type EntityTaxYear$checklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    where?: ChecklistItemWhereInput
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    cursor?: ChecklistItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChecklistItemScalarFieldEnum | ChecklistItemScalarFieldEnum[]
  }

  /**
   * EntityTaxYear.questionnaireAnswers
   */
  export type EntityTaxYear$questionnaireAnswersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    where?: QuestionnaireAnswerWhereInput
    orderBy?: QuestionnaireAnswerOrderByWithRelationInput | QuestionnaireAnswerOrderByWithRelationInput[]
    cursor?: QuestionnaireAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionnaireAnswerScalarFieldEnum | QuestionnaireAnswerScalarFieldEnum[]
  }

  /**
   * EntityTaxYear.messageThread
   */
  export type EntityTaxYear$messageThreadArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    where?: MessageThreadWhereInput
  }

  /**
   * EntityTaxYear.reminderState
   */
  export type EntityTaxYear$reminderStateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    where?: ReminderStateWhereInput
  }

  /**
   * EntityTaxYear.statusAuditLogs
   */
  export type EntityTaxYear$statusAuditLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    where?: StatusAuditLogWhereInput
    orderBy?: StatusAuditLogOrderByWithRelationInput | StatusAuditLogOrderByWithRelationInput[]
    cursor?: StatusAuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StatusAuditLogScalarFieldEnum | StatusAuditLogScalarFieldEnum[]
  }

  /**
   * EntityTaxYear.documentEvents
   */
  export type EntityTaxYear$documentEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    where?: DocumentEventWhereInput
    orderBy?: DocumentEventOrderByWithRelationInput | DocumentEventOrderByWithRelationInput[]
    cursor?: DocumentEventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentEventScalarFieldEnum | DocumentEventScalarFieldEnum[]
  }

  /**
   * EntityTaxYear.engagementSignatures
   */
  export type EntityTaxYear$engagementSignaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    where?: EngagementSignatureWhereInput
    orderBy?: EngagementSignatureOrderByWithRelationInput | EngagementSignatureOrderByWithRelationInput[]
    cursor?: EngagementSignatureWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EngagementSignatureScalarFieldEnum | EngagementSignatureScalarFieldEnum[]
  }

  /**
   * EntityTaxYear.efileAuthorizations
   */
  export type EntityTaxYear$efileAuthorizationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    where?: EfileAuthorizationWhereInput
    orderBy?: EfileAuthorizationOrderByWithRelationInput | EfileAuthorizationOrderByWithRelationInput[]
    cursor?: EfileAuthorizationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EfileAuthorizationScalarFieldEnum | EfileAuthorizationScalarFieldEnum[]
  }

  /**
   * EntityTaxYear without action
   */
  export type EntityTaxYearDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EntityTaxYear
     */
    select?: EntityTaxYearSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EntityTaxYear
     */
    omit?: EntityTaxYearOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EntityTaxYearInclude<ExtArgs> | null
  }


  /**
   * Model ClientAcl
   */

  export type AggregateClientAcl = {
    _count: ClientAclCountAggregateOutputType | null
    _min: ClientAclMinAggregateOutputType | null
    _max: ClientAclMaxAggregateOutputType | null
  }

  export type ClientAclMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    staffUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientAclMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    staffUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientAclCountAggregateOutputType = {
    id: number
    clientId: number
    staffUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientAclMinAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientAclMaxAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientAclCountAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientAclAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAcl to aggregate.
     */
    where?: ClientAclWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAcls to fetch.
     */
    orderBy?: ClientAclOrderByWithRelationInput | ClientAclOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientAclWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAcls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAcls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientAcls
    **/
    _count?: true | ClientAclCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientAclMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientAclMaxAggregateInputType
  }

  export type GetClientAclAggregateType<T extends ClientAclAggregateArgs> = {
        [P in keyof T & keyof AggregateClientAcl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientAcl[P]>
      : GetScalarType<T[P], AggregateClientAcl[P]>
  }




  export type ClientAclGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientAclWhereInput
    orderBy?: ClientAclOrderByWithAggregationInput | ClientAclOrderByWithAggregationInput[]
    by: ClientAclScalarFieldEnum[] | ClientAclScalarFieldEnum
    having?: ClientAclScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientAclCountAggregateInputType | true
    _min?: ClientAclMinAggregateInputType
    _max?: ClientAclMaxAggregateInputType
  }

  export type ClientAclGroupByOutputType = {
    id: string
    clientId: string
    staffUserId: string
    createdAt: Date
    updatedAt: Date
    _count: ClientAclCountAggregateOutputType | null
    _min: ClientAclMinAggregateOutputType | null
    _max: ClientAclMaxAggregateOutputType | null
  }

  type GetClientAclGroupByPayload<T extends ClientAclGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientAclGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientAclGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientAclGroupByOutputType[P]>
            : GetScalarType<T[P], ClientAclGroupByOutputType[P]>
        }
      >
    >


  export type ClientAclSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAcl"]>

  export type ClientAclSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAcl"]>

  export type ClientAclSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientAcl"]>

  export type ClientAclSelectScalar = {
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientAclOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "staffUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["clientAcl"]>
  export type ClientAclInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type ClientAclIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type ClientAclIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $ClientAclPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientAcl"
    objects: {
      clientEntity: Prisma.$ClientEntityPayload<ExtArgs>
      staff: Prisma.$StaffProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      staffUserId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientAcl"]>
    composites: {}
  }

  type ClientAclGetPayload<S extends boolean | null | undefined | ClientAclDefaultArgs> = $Result.GetResult<Prisma.$ClientAclPayload, S>

  type ClientAclCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientAclFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientAclCountAggregateInputType | true
    }

  export interface ClientAclDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientAcl'], meta: { name: 'ClientAcl' } }
    /**
     * Find zero or one ClientAcl that matches the filter.
     * @param {ClientAclFindUniqueArgs} args - Arguments to find a ClientAcl
     * @example
     * // Get one ClientAcl
     * const clientAcl = await prisma.clientAcl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientAclFindUniqueArgs>(args: SelectSubset<T, ClientAclFindUniqueArgs<ExtArgs>>): Prisma__ClientAclClient<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientAcl that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientAclFindUniqueOrThrowArgs} args - Arguments to find a ClientAcl
     * @example
     * // Get one ClientAcl
     * const clientAcl = await prisma.clientAcl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientAclFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientAclFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientAclClient<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAcl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAclFindFirstArgs} args - Arguments to find a ClientAcl
     * @example
     * // Get one ClientAcl
     * const clientAcl = await prisma.clientAcl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientAclFindFirstArgs>(args?: SelectSubset<T, ClientAclFindFirstArgs<ExtArgs>>): Prisma__ClientAclClient<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientAcl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAclFindFirstOrThrowArgs} args - Arguments to find a ClientAcl
     * @example
     * // Get one ClientAcl
     * const clientAcl = await prisma.clientAcl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientAclFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientAclFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientAclClient<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientAcls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAclFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientAcls
     * const clientAcls = await prisma.clientAcl.findMany()
     * 
     * // Get first 10 ClientAcls
     * const clientAcls = await prisma.clientAcl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientAclWithIdOnly = await prisma.clientAcl.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientAclFindManyArgs>(args?: SelectSubset<T, ClientAclFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientAcl.
     * @param {ClientAclCreateArgs} args - Arguments to create a ClientAcl.
     * @example
     * // Create one ClientAcl
     * const ClientAcl = await prisma.clientAcl.create({
     *   data: {
     *     // ... data to create a ClientAcl
     *   }
     * })
     * 
     */
    create<T extends ClientAclCreateArgs>(args: SelectSubset<T, ClientAclCreateArgs<ExtArgs>>): Prisma__ClientAclClient<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientAcls.
     * @param {ClientAclCreateManyArgs} args - Arguments to create many ClientAcls.
     * @example
     * // Create many ClientAcls
     * const clientAcl = await prisma.clientAcl.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientAclCreateManyArgs>(args?: SelectSubset<T, ClientAclCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientAcls and returns the data saved in the database.
     * @param {ClientAclCreateManyAndReturnArgs} args - Arguments to create many ClientAcls.
     * @example
     * // Create many ClientAcls
     * const clientAcl = await prisma.clientAcl.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientAcls and only return the `id`
     * const clientAclWithIdOnly = await prisma.clientAcl.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientAclCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientAclCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientAcl.
     * @param {ClientAclDeleteArgs} args - Arguments to delete one ClientAcl.
     * @example
     * // Delete one ClientAcl
     * const ClientAcl = await prisma.clientAcl.delete({
     *   where: {
     *     // ... filter to delete one ClientAcl
     *   }
     * })
     * 
     */
    delete<T extends ClientAclDeleteArgs>(args: SelectSubset<T, ClientAclDeleteArgs<ExtArgs>>): Prisma__ClientAclClient<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientAcl.
     * @param {ClientAclUpdateArgs} args - Arguments to update one ClientAcl.
     * @example
     * // Update one ClientAcl
     * const clientAcl = await prisma.clientAcl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientAclUpdateArgs>(args: SelectSubset<T, ClientAclUpdateArgs<ExtArgs>>): Prisma__ClientAclClient<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientAcls.
     * @param {ClientAclDeleteManyArgs} args - Arguments to filter ClientAcls to delete.
     * @example
     * // Delete a few ClientAcls
     * const { count } = await prisma.clientAcl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientAclDeleteManyArgs>(args?: SelectSubset<T, ClientAclDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAcls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAclUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientAcls
     * const clientAcl = await prisma.clientAcl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientAclUpdateManyArgs>(args: SelectSubset<T, ClientAclUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientAcls and returns the data updated in the database.
     * @param {ClientAclUpdateManyAndReturnArgs} args - Arguments to update many ClientAcls.
     * @example
     * // Update many ClientAcls
     * const clientAcl = await prisma.clientAcl.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientAcls and only return the `id`
     * const clientAclWithIdOnly = await prisma.clientAcl.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientAclUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientAclUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientAcl.
     * @param {ClientAclUpsertArgs} args - Arguments to update or create a ClientAcl.
     * @example
     * // Update or create a ClientAcl
     * const clientAcl = await prisma.clientAcl.upsert({
     *   create: {
     *     // ... data to create a ClientAcl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientAcl we want to update
     *   }
     * })
     */
    upsert<T extends ClientAclUpsertArgs>(args: SelectSubset<T, ClientAclUpsertArgs<ExtArgs>>): Prisma__ClientAclClient<$Result.GetResult<Prisma.$ClientAclPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientAcls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAclCountArgs} args - Arguments to filter ClientAcls to count.
     * @example
     * // Count the number of ClientAcls
     * const count = await prisma.clientAcl.count({
     *   where: {
     *     // ... the filter for the ClientAcls we want to count
     *   }
     * })
    **/
    count<T extends ClientAclCountArgs>(
      args?: Subset<T, ClientAclCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientAclCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientAcl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAclAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientAclAggregateArgs>(args: Subset<T, ClientAclAggregateArgs>): Prisma.PrismaPromise<GetClientAclAggregateType<T>>

    /**
     * Group by ClientAcl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientAclGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientAclGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientAclGroupByArgs['orderBy'] }
        : { orderBy?: ClientAclGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientAclGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientAclGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientAcl model
   */
  readonly fields: ClientAclFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientAcl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientAclClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientEntity<T extends ClientEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntityDefaultArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientAcl model
   */
  interface ClientAclFieldRefs {
    readonly id: FieldRef<"ClientAcl", 'String'>
    readonly clientId: FieldRef<"ClientAcl", 'String'>
    readonly staffUserId: FieldRef<"ClientAcl", 'String'>
    readonly createdAt: FieldRef<"ClientAcl", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientAcl", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientAcl findUnique
   */
  export type ClientAclFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * Filter, which ClientAcl to fetch.
     */
    where: ClientAclWhereUniqueInput
  }

  /**
   * ClientAcl findUniqueOrThrow
   */
  export type ClientAclFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * Filter, which ClientAcl to fetch.
     */
    where: ClientAclWhereUniqueInput
  }

  /**
   * ClientAcl findFirst
   */
  export type ClientAclFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * Filter, which ClientAcl to fetch.
     */
    where?: ClientAclWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAcls to fetch.
     */
    orderBy?: ClientAclOrderByWithRelationInput | ClientAclOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAcls.
     */
    cursor?: ClientAclWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAcls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAcls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAcls.
     */
    distinct?: ClientAclScalarFieldEnum | ClientAclScalarFieldEnum[]
  }

  /**
   * ClientAcl findFirstOrThrow
   */
  export type ClientAclFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * Filter, which ClientAcl to fetch.
     */
    where?: ClientAclWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAcls to fetch.
     */
    orderBy?: ClientAclOrderByWithRelationInput | ClientAclOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientAcls.
     */
    cursor?: ClientAclWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAcls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAcls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientAcls.
     */
    distinct?: ClientAclScalarFieldEnum | ClientAclScalarFieldEnum[]
  }

  /**
   * ClientAcl findMany
   */
  export type ClientAclFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * Filter, which ClientAcls to fetch.
     */
    where?: ClientAclWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientAcls to fetch.
     */
    orderBy?: ClientAclOrderByWithRelationInput | ClientAclOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientAcls.
     */
    cursor?: ClientAclWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientAcls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientAcls.
     */
    skip?: number
    distinct?: ClientAclScalarFieldEnum | ClientAclScalarFieldEnum[]
  }

  /**
   * ClientAcl create
   */
  export type ClientAclCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientAcl.
     */
    data: XOR<ClientAclCreateInput, ClientAclUncheckedCreateInput>
  }

  /**
   * ClientAcl createMany
   */
  export type ClientAclCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientAcls.
     */
    data: ClientAclCreateManyInput | ClientAclCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientAcl createManyAndReturn
   */
  export type ClientAclCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * The data used to create many ClientAcls.
     */
    data: ClientAclCreateManyInput | ClientAclCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientAcl update
   */
  export type ClientAclUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientAcl.
     */
    data: XOR<ClientAclUpdateInput, ClientAclUncheckedUpdateInput>
    /**
     * Choose, which ClientAcl to update.
     */
    where: ClientAclWhereUniqueInput
  }

  /**
   * ClientAcl updateMany
   */
  export type ClientAclUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientAcls.
     */
    data: XOR<ClientAclUpdateManyMutationInput, ClientAclUncheckedUpdateManyInput>
    /**
     * Filter which ClientAcls to update
     */
    where?: ClientAclWhereInput
    /**
     * Limit how many ClientAcls to update.
     */
    limit?: number
  }

  /**
   * ClientAcl updateManyAndReturn
   */
  export type ClientAclUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * The data used to update ClientAcls.
     */
    data: XOR<ClientAclUpdateManyMutationInput, ClientAclUncheckedUpdateManyInput>
    /**
     * Filter which ClientAcls to update
     */
    where?: ClientAclWhereInput
    /**
     * Limit how many ClientAcls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientAcl upsert
   */
  export type ClientAclUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientAcl to update in case it exists.
     */
    where: ClientAclWhereUniqueInput
    /**
     * In case the ClientAcl found by the `where` argument doesn't exist, create a new ClientAcl with this data.
     */
    create: XOR<ClientAclCreateInput, ClientAclUncheckedCreateInput>
    /**
     * In case the ClientAcl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientAclUpdateInput, ClientAclUncheckedUpdateInput>
  }

  /**
   * ClientAcl delete
   */
  export type ClientAclDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
    /**
     * Filter which ClientAcl to delete.
     */
    where: ClientAclWhereUniqueInput
  }

  /**
   * ClientAcl deleteMany
   */
  export type ClientAclDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientAcls to delete
     */
    where?: ClientAclWhereInput
    /**
     * Limit how many ClientAcls to delete.
     */
    limit?: number
  }

  /**
   * ClientAcl without action
   */
  export type ClientAclDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientAcl
     */
    select?: ClientAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientAcl
     */
    omit?: ClientAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientAclInclude<ExtArgs> | null
  }


  /**
   * Model ClientStaffPermission
   */

  export type AggregateClientStaffPermission = {
    _count: ClientStaffPermissionCountAggregateOutputType | null
    _min: ClientStaffPermissionMinAggregateOutputType | null
    _max: ClientStaffPermissionMaxAggregateOutputType | null
  }

  export type ClientStaffPermissionMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    staffUserId: string | null
    canSeeTaxes: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientStaffPermissionMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    staffUserId: string | null
    canSeeTaxes: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientStaffPermissionCountAggregateOutputType = {
    id: number
    clientId: number
    staffUserId: number
    canSeeTaxes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientStaffPermissionMinAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    canSeeTaxes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientStaffPermissionMaxAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    canSeeTaxes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientStaffPermissionCountAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    canSeeTaxes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientStaffPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientStaffPermission to aggregate.
     */
    where?: ClientStaffPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientStaffPermissions to fetch.
     */
    orderBy?: ClientStaffPermissionOrderByWithRelationInput | ClientStaffPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientStaffPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientStaffPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientStaffPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientStaffPermissions
    **/
    _count?: true | ClientStaffPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientStaffPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientStaffPermissionMaxAggregateInputType
  }

  export type GetClientStaffPermissionAggregateType<T extends ClientStaffPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateClientStaffPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientStaffPermission[P]>
      : GetScalarType<T[P], AggregateClientStaffPermission[P]>
  }




  export type ClientStaffPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientStaffPermissionWhereInput
    orderBy?: ClientStaffPermissionOrderByWithAggregationInput | ClientStaffPermissionOrderByWithAggregationInput[]
    by: ClientStaffPermissionScalarFieldEnum[] | ClientStaffPermissionScalarFieldEnum
    having?: ClientStaffPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientStaffPermissionCountAggregateInputType | true
    _min?: ClientStaffPermissionMinAggregateInputType
    _max?: ClientStaffPermissionMaxAggregateInputType
  }

  export type ClientStaffPermissionGroupByOutputType = {
    id: string
    clientId: string
    staffUserId: string
    canSeeTaxes: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClientStaffPermissionCountAggregateOutputType | null
    _min: ClientStaffPermissionMinAggregateOutputType | null
    _max: ClientStaffPermissionMaxAggregateOutputType | null
  }

  type GetClientStaffPermissionGroupByPayload<T extends ClientStaffPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientStaffPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientStaffPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientStaffPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], ClientStaffPermissionGroupByOutputType[P]>
        }
      >
    >


  export type ClientStaffPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    canSeeTaxes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientStaffPermission"]>

  export type ClientStaffPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    canSeeTaxes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientStaffPermission"]>

  export type ClientStaffPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    canSeeTaxes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientStaffPermission"]>

  export type ClientStaffPermissionSelectScalar = {
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    canSeeTaxes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientStaffPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "staffUserId" | "canSeeTaxes" | "createdAt" | "updatedAt", ExtArgs["result"]["clientStaffPermission"]>
  export type ClientStaffPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type ClientStaffPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type ClientStaffPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $ClientStaffPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientStaffPermission"
    objects: {
      clientEntity: Prisma.$ClientEntityPayload<ExtArgs>
      staff: Prisma.$StaffProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      staffUserId: string
      canSeeTaxes: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientStaffPermission"]>
    composites: {}
  }

  type ClientStaffPermissionGetPayload<S extends boolean | null | undefined | ClientStaffPermissionDefaultArgs> = $Result.GetResult<Prisma.$ClientStaffPermissionPayload, S>

  type ClientStaffPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientStaffPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientStaffPermissionCountAggregateInputType | true
    }

  export interface ClientStaffPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientStaffPermission'], meta: { name: 'ClientStaffPermission' } }
    /**
     * Find zero or one ClientStaffPermission that matches the filter.
     * @param {ClientStaffPermissionFindUniqueArgs} args - Arguments to find a ClientStaffPermission
     * @example
     * // Get one ClientStaffPermission
     * const clientStaffPermission = await prisma.clientStaffPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientStaffPermissionFindUniqueArgs>(args: SelectSubset<T, ClientStaffPermissionFindUniqueArgs<ExtArgs>>): Prisma__ClientStaffPermissionClient<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientStaffPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientStaffPermissionFindUniqueOrThrowArgs} args - Arguments to find a ClientStaffPermission
     * @example
     * // Get one ClientStaffPermission
     * const clientStaffPermission = await prisma.clientStaffPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientStaffPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientStaffPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientStaffPermissionClient<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientStaffPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffPermissionFindFirstArgs} args - Arguments to find a ClientStaffPermission
     * @example
     * // Get one ClientStaffPermission
     * const clientStaffPermission = await prisma.clientStaffPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientStaffPermissionFindFirstArgs>(args?: SelectSubset<T, ClientStaffPermissionFindFirstArgs<ExtArgs>>): Prisma__ClientStaffPermissionClient<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientStaffPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffPermissionFindFirstOrThrowArgs} args - Arguments to find a ClientStaffPermission
     * @example
     * // Get one ClientStaffPermission
     * const clientStaffPermission = await prisma.clientStaffPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientStaffPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientStaffPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientStaffPermissionClient<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientStaffPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientStaffPermissions
     * const clientStaffPermissions = await prisma.clientStaffPermission.findMany()
     * 
     * // Get first 10 ClientStaffPermissions
     * const clientStaffPermissions = await prisma.clientStaffPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientStaffPermissionWithIdOnly = await prisma.clientStaffPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientStaffPermissionFindManyArgs>(args?: SelectSubset<T, ClientStaffPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientStaffPermission.
     * @param {ClientStaffPermissionCreateArgs} args - Arguments to create a ClientStaffPermission.
     * @example
     * // Create one ClientStaffPermission
     * const ClientStaffPermission = await prisma.clientStaffPermission.create({
     *   data: {
     *     // ... data to create a ClientStaffPermission
     *   }
     * })
     * 
     */
    create<T extends ClientStaffPermissionCreateArgs>(args: SelectSubset<T, ClientStaffPermissionCreateArgs<ExtArgs>>): Prisma__ClientStaffPermissionClient<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientStaffPermissions.
     * @param {ClientStaffPermissionCreateManyArgs} args - Arguments to create many ClientStaffPermissions.
     * @example
     * // Create many ClientStaffPermissions
     * const clientStaffPermission = await prisma.clientStaffPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientStaffPermissionCreateManyArgs>(args?: SelectSubset<T, ClientStaffPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientStaffPermissions and returns the data saved in the database.
     * @param {ClientStaffPermissionCreateManyAndReturnArgs} args - Arguments to create many ClientStaffPermissions.
     * @example
     * // Create many ClientStaffPermissions
     * const clientStaffPermission = await prisma.clientStaffPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientStaffPermissions and only return the `id`
     * const clientStaffPermissionWithIdOnly = await prisma.clientStaffPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientStaffPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientStaffPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientStaffPermission.
     * @param {ClientStaffPermissionDeleteArgs} args - Arguments to delete one ClientStaffPermission.
     * @example
     * // Delete one ClientStaffPermission
     * const ClientStaffPermission = await prisma.clientStaffPermission.delete({
     *   where: {
     *     // ... filter to delete one ClientStaffPermission
     *   }
     * })
     * 
     */
    delete<T extends ClientStaffPermissionDeleteArgs>(args: SelectSubset<T, ClientStaffPermissionDeleteArgs<ExtArgs>>): Prisma__ClientStaffPermissionClient<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientStaffPermission.
     * @param {ClientStaffPermissionUpdateArgs} args - Arguments to update one ClientStaffPermission.
     * @example
     * // Update one ClientStaffPermission
     * const clientStaffPermission = await prisma.clientStaffPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientStaffPermissionUpdateArgs>(args: SelectSubset<T, ClientStaffPermissionUpdateArgs<ExtArgs>>): Prisma__ClientStaffPermissionClient<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientStaffPermissions.
     * @param {ClientStaffPermissionDeleteManyArgs} args - Arguments to filter ClientStaffPermissions to delete.
     * @example
     * // Delete a few ClientStaffPermissions
     * const { count } = await prisma.clientStaffPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientStaffPermissionDeleteManyArgs>(args?: SelectSubset<T, ClientStaffPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientStaffPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientStaffPermissions
     * const clientStaffPermission = await prisma.clientStaffPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientStaffPermissionUpdateManyArgs>(args: SelectSubset<T, ClientStaffPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientStaffPermissions and returns the data updated in the database.
     * @param {ClientStaffPermissionUpdateManyAndReturnArgs} args - Arguments to update many ClientStaffPermissions.
     * @example
     * // Update many ClientStaffPermissions
     * const clientStaffPermission = await prisma.clientStaffPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientStaffPermissions and only return the `id`
     * const clientStaffPermissionWithIdOnly = await prisma.clientStaffPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientStaffPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientStaffPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientStaffPermission.
     * @param {ClientStaffPermissionUpsertArgs} args - Arguments to update or create a ClientStaffPermission.
     * @example
     * // Update or create a ClientStaffPermission
     * const clientStaffPermission = await prisma.clientStaffPermission.upsert({
     *   create: {
     *     // ... data to create a ClientStaffPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientStaffPermission we want to update
     *   }
     * })
     */
    upsert<T extends ClientStaffPermissionUpsertArgs>(args: SelectSubset<T, ClientStaffPermissionUpsertArgs<ExtArgs>>): Prisma__ClientStaffPermissionClient<$Result.GetResult<Prisma.$ClientStaffPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientStaffPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffPermissionCountArgs} args - Arguments to filter ClientStaffPermissions to count.
     * @example
     * // Count the number of ClientStaffPermissions
     * const count = await prisma.clientStaffPermission.count({
     *   where: {
     *     // ... the filter for the ClientStaffPermissions we want to count
     *   }
     * })
    **/
    count<T extends ClientStaffPermissionCountArgs>(
      args?: Subset<T, ClientStaffPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientStaffPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientStaffPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientStaffPermissionAggregateArgs>(args: Subset<T, ClientStaffPermissionAggregateArgs>): Prisma.PrismaPromise<GetClientStaffPermissionAggregateType<T>>

    /**
     * Group by ClientStaffPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientStaffPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientStaffPermissionGroupByArgs['orderBy'] }
        : { orderBy?: ClientStaffPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientStaffPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientStaffPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientStaffPermission model
   */
  readonly fields: ClientStaffPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientStaffPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientStaffPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientEntity<T extends ClientEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntityDefaultArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientStaffPermission model
   */
  interface ClientStaffPermissionFieldRefs {
    readonly id: FieldRef<"ClientStaffPermission", 'String'>
    readonly clientId: FieldRef<"ClientStaffPermission", 'String'>
    readonly staffUserId: FieldRef<"ClientStaffPermission", 'String'>
    readonly canSeeTaxes: FieldRef<"ClientStaffPermission", 'Boolean'>
    readonly createdAt: FieldRef<"ClientStaffPermission", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientStaffPermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientStaffPermission findUnique
   */
  export type ClientStaffPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffPermission to fetch.
     */
    where: ClientStaffPermissionWhereUniqueInput
  }

  /**
   * ClientStaffPermission findUniqueOrThrow
   */
  export type ClientStaffPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffPermission to fetch.
     */
    where: ClientStaffPermissionWhereUniqueInput
  }

  /**
   * ClientStaffPermission findFirst
   */
  export type ClientStaffPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffPermission to fetch.
     */
    where?: ClientStaffPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientStaffPermissions to fetch.
     */
    orderBy?: ClientStaffPermissionOrderByWithRelationInput | ClientStaffPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientStaffPermissions.
     */
    cursor?: ClientStaffPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientStaffPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientStaffPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientStaffPermissions.
     */
    distinct?: ClientStaffPermissionScalarFieldEnum | ClientStaffPermissionScalarFieldEnum[]
  }

  /**
   * ClientStaffPermission findFirstOrThrow
   */
  export type ClientStaffPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffPermission to fetch.
     */
    where?: ClientStaffPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientStaffPermissions to fetch.
     */
    orderBy?: ClientStaffPermissionOrderByWithRelationInput | ClientStaffPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientStaffPermissions.
     */
    cursor?: ClientStaffPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientStaffPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientStaffPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientStaffPermissions.
     */
    distinct?: ClientStaffPermissionScalarFieldEnum | ClientStaffPermissionScalarFieldEnum[]
  }

  /**
   * ClientStaffPermission findMany
   */
  export type ClientStaffPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffPermissions to fetch.
     */
    where?: ClientStaffPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientStaffPermissions to fetch.
     */
    orderBy?: ClientStaffPermissionOrderByWithRelationInput | ClientStaffPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientStaffPermissions.
     */
    cursor?: ClientStaffPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientStaffPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientStaffPermissions.
     */
    skip?: number
    distinct?: ClientStaffPermissionScalarFieldEnum | ClientStaffPermissionScalarFieldEnum[]
  }

  /**
   * ClientStaffPermission create
   */
  export type ClientStaffPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientStaffPermission.
     */
    data: XOR<ClientStaffPermissionCreateInput, ClientStaffPermissionUncheckedCreateInput>
  }

  /**
   * ClientStaffPermission createMany
   */
  export type ClientStaffPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientStaffPermissions.
     */
    data: ClientStaffPermissionCreateManyInput | ClientStaffPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientStaffPermission createManyAndReturn
   */
  export type ClientStaffPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many ClientStaffPermissions.
     */
    data: ClientStaffPermissionCreateManyInput | ClientStaffPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientStaffPermission update
   */
  export type ClientStaffPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientStaffPermission.
     */
    data: XOR<ClientStaffPermissionUpdateInput, ClientStaffPermissionUncheckedUpdateInput>
    /**
     * Choose, which ClientStaffPermission to update.
     */
    where: ClientStaffPermissionWhereUniqueInput
  }

  /**
   * ClientStaffPermission updateMany
   */
  export type ClientStaffPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientStaffPermissions.
     */
    data: XOR<ClientStaffPermissionUpdateManyMutationInput, ClientStaffPermissionUncheckedUpdateManyInput>
    /**
     * Filter which ClientStaffPermissions to update
     */
    where?: ClientStaffPermissionWhereInput
    /**
     * Limit how many ClientStaffPermissions to update.
     */
    limit?: number
  }

  /**
   * ClientStaffPermission updateManyAndReturn
   */
  export type ClientStaffPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * The data used to update ClientStaffPermissions.
     */
    data: XOR<ClientStaffPermissionUpdateManyMutationInput, ClientStaffPermissionUncheckedUpdateManyInput>
    /**
     * Filter which ClientStaffPermissions to update
     */
    where?: ClientStaffPermissionWhereInput
    /**
     * Limit how many ClientStaffPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientStaffPermission upsert
   */
  export type ClientStaffPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientStaffPermission to update in case it exists.
     */
    where: ClientStaffPermissionWhereUniqueInput
    /**
     * In case the ClientStaffPermission found by the `where` argument doesn't exist, create a new ClientStaffPermission with this data.
     */
    create: XOR<ClientStaffPermissionCreateInput, ClientStaffPermissionUncheckedCreateInput>
    /**
     * In case the ClientStaffPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientStaffPermissionUpdateInput, ClientStaffPermissionUncheckedUpdateInput>
  }

  /**
   * ClientStaffPermission delete
   */
  export type ClientStaffPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
    /**
     * Filter which ClientStaffPermission to delete.
     */
    where: ClientStaffPermissionWhereUniqueInput
  }

  /**
   * ClientStaffPermission deleteMany
   */
  export type ClientStaffPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientStaffPermissions to delete
     */
    where?: ClientStaffPermissionWhereInput
    /**
     * Limit how many ClientStaffPermissions to delete.
     */
    limit?: number
  }

  /**
   * ClientStaffPermission without action
   */
  export type ClientStaffPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffPermission
     */
    select?: ClientStaffPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffPermission
     */
    omit?: ClientStaffPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffPermissionInclude<ExtArgs> | null
  }


  /**
   * Model ClientStaffAssignment
   */

  export type AggregateClientStaffAssignment = {
    _count: ClientStaffAssignmentCountAggregateOutputType | null
    _min: ClientStaffAssignmentMinAggregateOutputType | null
    _max: ClientStaffAssignmentMaxAggregateOutputType | null
  }

  export type ClientStaffAssignmentMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    staffUserId: string | null
    roleOnClient: string | null
    active: boolean | null
    assignedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientStaffAssignmentMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    staffUserId: string | null
    roleOnClient: string | null
    active: boolean | null
    assignedBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClientStaffAssignmentCountAggregateOutputType = {
    id: number
    clientId: number
    staffUserId: number
    roleOnClient: number
    active: number
    assignedBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClientStaffAssignmentMinAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    roleOnClient?: true
    active?: true
    assignedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientStaffAssignmentMaxAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    roleOnClient?: true
    active?: true
    assignedBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClientStaffAssignmentCountAggregateInputType = {
    id?: true
    clientId?: true
    staffUserId?: true
    roleOnClient?: true
    active?: true
    assignedBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClientStaffAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientStaffAssignment to aggregate.
     */
    where?: ClientStaffAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientStaffAssignments to fetch.
     */
    orderBy?: ClientStaffAssignmentOrderByWithRelationInput | ClientStaffAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClientStaffAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientStaffAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientStaffAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClientStaffAssignments
    **/
    _count?: true | ClientStaffAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClientStaffAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClientStaffAssignmentMaxAggregateInputType
  }

  export type GetClientStaffAssignmentAggregateType<T extends ClientStaffAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateClientStaffAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClientStaffAssignment[P]>
      : GetScalarType<T[P], AggregateClientStaffAssignment[P]>
  }




  export type ClientStaffAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClientStaffAssignmentWhereInput
    orderBy?: ClientStaffAssignmentOrderByWithAggregationInput | ClientStaffAssignmentOrderByWithAggregationInput[]
    by: ClientStaffAssignmentScalarFieldEnum[] | ClientStaffAssignmentScalarFieldEnum
    having?: ClientStaffAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClientStaffAssignmentCountAggregateInputType | true
    _min?: ClientStaffAssignmentMinAggregateInputType
    _max?: ClientStaffAssignmentMaxAggregateInputType
  }

  export type ClientStaffAssignmentGroupByOutputType = {
    id: string
    clientId: string
    staffUserId: string
    roleOnClient: string
    active: boolean
    assignedBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ClientStaffAssignmentCountAggregateOutputType | null
    _min: ClientStaffAssignmentMinAggregateOutputType | null
    _max: ClientStaffAssignmentMaxAggregateOutputType | null
  }

  type GetClientStaffAssignmentGroupByPayload<T extends ClientStaffAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClientStaffAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClientStaffAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClientStaffAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ClientStaffAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ClientStaffAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    roleOnClient?: boolean
    active?: boolean
    assignedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientStaffAssignment"]>

  export type ClientStaffAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    roleOnClient?: boolean
    active?: boolean
    assignedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientStaffAssignment"]>

  export type ClientStaffAssignmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    roleOnClient?: boolean
    active?: boolean
    assignedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clientStaffAssignment"]>

  export type ClientStaffAssignmentSelectScalar = {
    id?: boolean
    clientId?: boolean
    staffUserId?: boolean
    roleOnClient?: boolean
    active?: boolean
    assignedBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClientStaffAssignmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "staffUserId" | "roleOnClient" | "active" | "assignedBy" | "createdAt" | "updatedAt", ExtArgs["result"]["clientStaffAssignment"]>
  export type ClientStaffAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type ClientStaffAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type ClientStaffAssignmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $ClientStaffAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClientStaffAssignment"
    objects: {
      clientEntity: Prisma.$ClientEntityPayload<ExtArgs>
      staff: Prisma.$StaffProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      staffUserId: string
      roleOnClient: string
      active: boolean
      assignedBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clientStaffAssignment"]>
    composites: {}
  }

  type ClientStaffAssignmentGetPayload<S extends boolean | null | undefined | ClientStaffAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ClientStaffAssignmentPayload, S>

  type ClientStaffAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClientStaffAssignmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClientStaffAssignmentCountAggregateInputType | true
    }

  export interface ClientStaffAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClientStaffAssignment'], meta: { name: 'ClientStaffAssignment' } }
    /**
     * Find zero or one ClientStaffAssignment that matches the filter.
     * @param {ClientStaffAssignmentFindUniqueArgs} args - Arguments to find a ClientStaffAssignment
     * @example
     * // Get one ClientStaffAssignment
     * const clientStaffAssignment = await prisma.clientStaffAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClientStaffAssignmentFindUniqueArgs>(args: SelectSubset<T, ClientStaffAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ClientStaffAssignmentClient<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ClientStaffAssignment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClientStaffAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ClientStaffAssignment
     * @example
     * // Get one ClientStaffAssignment
     * const clientStaffAssignment = await prisma.clientStaffAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClientStaffAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ClientStaffAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClientStaffAssignmentClient<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientStaffAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffAssignmentFindFirstArgs} args - Arguments to find a ClientStaffAssignment
     * @example
     * // Get one ClientStaffAssignment
     * const clientStaffAssignment = await prisma.clientStaffAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClientStaffAssignmentFindFirstArgs>(args?: SelectSubset<T, ClientStaffAssignmentFindFirstArgs<ExtArgs>>): Prisma__ClientStaffAssignmentClient<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ClientStaffAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffAssignmentFindFirstOrThrowArgs} args - Arguments to find a ClientStaffAssignment
     * @example
     * // Get one ClientStaffAssignment
     * const clientStaffAssignment = await prisma.clientStaffAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClientStaffAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ClientStaffAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClientStaffAssignmentClient<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ClientStaffAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClientStaffAssignments
     * const clientStaffAssignments = await prisma.clientStaffAssignment.findMany()
     * 
     * // Get first 10 ClientStaffAssignments
     * const clientStaffAssignments = await prisma.clientStaffAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clientStaffAssignmentWithIdOnly = await prisma.clientStaffAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClientStaffAssignmentFindManyArgs>(args?: SelectSubset<T, ClientStaffAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ClientStaffAssignment.
     * @param {ClientStaffAssignmentCreateArgs} args - Arguments to create a ClientStaffAssignment.
     * @example
     * // Create one ClientStaffAssignment
     * const ClientStaffAssignment = await prisma.clientStaffAssignment.create({
     *   data: {
     *     // ... data to create a ClientStaffAssignment
     *   }
     * })
     * 
     */
    create<T extends ClientStaffAssignmentCreateArgs>(args: SelectSubset<T, ClientStaffAssignmentCreateArgs<ExtArgs>>): Prisma__ClientStaffAssignmentClient<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ClientStaffAssignments.
     * @param {ClientStaffAssignmentCreateManyArgs} args - Arguments to create many ClientStaffAssignments.
     * @example
     * // Create many ClientStaffAssignments
     * const clientStaffAssignment = await prisma.clientStaffAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClientStaffAssignmentCreateManyArgs>(args?: SelectSubset<T, ClientStaffAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClientStaffAssignments and returns the data saved in the database.
     * @param {ClientStaffAssignmentCreateManyAndReturnArgs} args - Arguments to create many ClientStaffAssignments.
     * @example
     * // Create many ClientStaffAssignments
     * const clientStaffAssignment = await prisma.clientStaffAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClientStaffAssignments and only return the `id`
     * const clientStaffAssignmentWithIdOnly = await prisma.clientStaffAssignment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClientStaffAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ClientStaffAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ClientStaffAssignment.
     * @param {ClientStaffAssignmentDeleteArgs} args - Arguments to delete one ClientStaffAssignment.
     * @example
     * // Delete one ClientStaffAssignment
     * const ClientStaffAssignment = await prisma.clientStaffAssignment.delete({
     *   where: {
     *     // ... filter to delete one ClientStaffAssignment
     *   }
     * })
     * 
     */
    delete<T extends ClientStaffAssignmentDeleteArgs>(args: SelectSubset<T, ClientStaffAssignmentDeleteArgs<ExtArgs>>): Prisma__ClientStaffAssignmentClient<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ClientStaffAssignment.
     * @param {ClientStaffAssignmentUpdateArgs} args - Arguments to update one ClientStaffAssignment.
     * @example
     * // Update one ClientStaffAssignment
     * const clientStaffAssignment = await prisma.clientStaffAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClientStaffAssignmentUpdateArgs>(args: SelectSubset<T, ClientStaffAssignmentUpdateArgs<ExtArgs>>): Prisma__ClientStaffAssignmentClient<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ClientStaffAssignments.
     * @param {ClientStaffAssignmentDeleteManyArgs} args - Arguments to filter ClientStaffAssignments to delete.
     * @example
     * // Delete a few ClientStaffAssignments
     * const { count } = await prisma.clientStaffAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClientStaffAssignmentDeleteManyArgs>(args?: SelectSubset<T, ClientStaffAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientStaffAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClientStaffAssignments
     * const clientStaffAssignment = await prisma.clientStaffAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClientStaffAssignmentUpdateManyArgs>(args: SelectSubset<T, ClientStaffAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClientStaffAssignments and returns the data updated in the database.
     * @param {ClientStaffAssignmentUpdateManyAndReturnArgs} args - Arguments to update many ClientStaffAssignments.
     * @example
     * // Update many ClientStaffAssignments
     * const clientStaffAssignment = await prisma.clientStaffAssignment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ClientStaffAssignments and only return the `id`
     * const clientStaffAssignmentWithIdOnly = await prisma.clientStaffAssignment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClientStaffAssignmentUpdateManyAndReturnArgs>(args: SelectSubset<T, ClientStaffAssignmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ClientStaffAssignment.
     * @param {ClientStaffAssignmentUpsertArgs} args - Arguments to update or create a ClientStaffAssignment.
     * @example
     * // Update or create a ClientStaffAssignment
     * const clientStaffAssignment = await prisma.clientStaffAssignment.upsert({
     *   create: {
     *     // ... data to create a ClientStaffAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClientStaffAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ClientStaffAssignmentUpsertArgs>(args: SelectSubset<T, ClientStaffAssignmentUpsertArgs<ExtArgs>>): Prisma__ClientStaffAssignmentClient<$Result.GetResult<Prisma.$ClientStaffAssignmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ClientStaffAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffAssignmentCountArgs} args - Arguments to filter ClientStaffAssignments to count.
     * @example
     * // Count the number of ClientStaffAssignments
     * const count = await prisma.clientStaffAssignment.count({
     *   where: {
     *     // ... the filter for the ClientStaffAssignments we want to count
     *   }
     * })
    **/
    count<T extends ClientStaffAssignmentCountArgs>(
      args?: Subset<T, ClientStaffAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClientStaffAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClientStaffAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClientStaffAssignmentAggregateArgs>(args: Subset<T, ClientStaffAssignmentAggregateArgs>): Prisma.PrismaPromise<GetClientStaffAssignmentAggregateType<T>>

    /**
     * Group by ClientStaffAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClientStaffAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClientStaffAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClientStaffAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ClientStaffAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClientStaffAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClientStaffAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClientStaffAssignment model
   */
  readonly fields: ClientStaffAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClientStaffAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClientStaffAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientEntity<T extends ClientEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntityDefaultArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClientStaffAssignment model
   */
  interface ClientStaffAssignmentFieldRefs {
    readonly id: FieldRef<"ClientStaffAssignment", 'String'>
    readonly clientId: FieldRef<"ClientStaffAssignment", 'String'>
    readonly staffUserId: FieldRef<"ClientStaffAssignment", 'String'>
    readonly roleOnClient: FieldRef<"ClientStaffAssignment", 'String'>
    readonly active: FieldRef<"ClientStaffAssignment", 'Boolean'>
    readonly assignedBy: FieldRef<"ClientStaffAssignment", 'String'>
    readonly createdAt: FieldRef<"ClientStaffAssignment", 'DateTime'>
    readonly updatedAt: FieldRef<"ClientStaffAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClientStaffAssignment findUnique
   */
  export type ClientStaffAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffAssignment to fetch.
     */
    where: ClientStaffAssignmentWhereUniqueInput
  }

  /**
   * ClientStaffAssignment findUniqueOrThrow
   */
  export type ClientStaffAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffAssignment to fetch.
     */
    where: ClientStaffAssignmentWhereUniqueInput
  }

  /**
   * ClientStaffAssignment findFirst
   */
  export type ClientStaffAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffAssignment to fetch.
     */
    where?: ClientStaffAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientStaffAssignments to fetch.
     */
    orderBy?: ClientStaffAssignmentOrderByWithRelationInput | ClientStaffAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientStaffAssignments.
     */
    cursor?: ClientStaffAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientStaffAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientStaffAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientStaffAssignments.
     */
    distinct?: ClientStaffAssignmentScalarFieldEnum | ClientStaffAssignmentScalarFieldEnum[]
  }

  /**
   * ClientStaffAssignment findFirstOrThrow
   */
  export type ClientStaffAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffAssignment to fetch.
     */
    where?: ClientStaffAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientStaffAssignments to fetch.
     */
    orderBy?: ClientStaffAssignmentOrderByWithRelationInput | ClientStaffAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClientStaffAssignments.
     */
    cursor?: ClientStaffAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientStaffAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientStaffAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClientStaffAssignments.
     */
    distinct?: ClientStaffAssignmentScalarFieldEnum | ClientStaffAssignmentScalarFieldEnum[]
  }

  /**
   * ClientStaffAssignment findMany
   */
  export type ClientStaffAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ClientStaffAssignments to fetch.
     */
    where?: ClientStaffAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClientStaffAssignments to fetch.
     */
    orderBy?: ClientStaffAssignmentOrderByWithRelationInput | ClientStaffAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClientStaffAssignments.
     */
    cursor?: ClientStaffAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClientStaffAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClientStaffAssignments.
     */
    skip?: number
    distinct?: ClientStaffAssignmentScalarFieldEnum | ClientStaffAssignmentScalarFieldEnum[]
  }

  /**
   * ClientStaffAssignment create
   */
  export type ClientStaffAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ClientStaffAssignment.
     */
    data: XOR<ClientStaffAssignmentCreateInput, ClientStaffAssignmentUncheckedCreateInput>
  }

  /**
   * ClientStaffAssignment createMany
   */
  export type ClientStaffAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClientStaffAssignments.
     */
    data: ClientStaffAssignmentCreateManyInput | ClientStaffAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClientStaffAssignment createManyAndReturn
   */
  export type ClientStaffAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * The data used to create many ClientStaffAssignments.
     */
    data: ClientStaffAssignmentCreateManyInput | ClientStaffAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientStaffAssignment update
   */
  export type ClientStaffAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ClientStaffAssignment.
     */
    data: XOR<ClientStaffAssignmentUpdateInput, ClientStaffAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ClientStaffAssignment to update.
     */
    where: ClientStaffAssignmentWhereUniqueInput
  }

  /**
   * ClientStaffAssignment updateMany
   */
  export type ClientStaffAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClientStaffAssignments.
     */
    data: XOR<ClientStaffAssignmentUpdateManyMutationInput, ClientStaffAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ClientStaffAssignments to update
     */
    where?: ClientStaffAssignmentWhereInput
    /**
     * Limit how many ClientStaffAssignments to update.
     */
    limit?: number
  }

  /**
   * ClientStaffAssignment updateManyAndReturn
   */
  export type ClientStaffAssignmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * The data used to update ClientStaffAssignments.
     */
    data: XOR<ClientStaffAssignmentUpdateManyMutationInput, ClientStaffAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ClientStaffAssignments to update
     */
    where?: ClientStaffAssignmentWhereInput
    /**
     * Limit how many ClientStaffAssignments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClientStaffAssignment upsert
   */
  export type ClientStaffAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ClientStaffAssignment to update in case it exists.
     */
    where: ClientStaffAssignmentWhereUniqueInput
    /**
     * In case the ClientStaffAssignment found by the `where` argument doesn't exist, create a new ClientStaffAssignment with this data.
     */
    create: XOR<ClientStaffAssignmentCreateInput, ClientStaffAssignmentUncheckedCreateInput>
    /**
     * In case the ClientStaffAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClientStaffAssignmentUpdateInput, ClientStaffAssignmentUncheckedUpdateInput>
  }

  /**
   * ClientStaffAssignment delete
   */
  export type ClientStaffAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ClientStaffAssignment to delete.
     */
    where: ClientStaffAssignmentWhereUniqueInput
  }

  /**
   * ClientStaffAssignment deleteMany
   */
  export type ClientStaffAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClientStaffAssignments to delete
     */
    where?: ClientStaffAssignmentWhereInput
    /**
     * Limit how many ClientStaffAssignments to delete.
     */
    limit?: number
  }

  /**
   * ClientStaffAssignment without action
   */
  export type ClientStaffAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClientStaffAssignment
     */
    select?: ClientStaffAssignmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ClientStaffAssignment
     */
    omit?: ClientStaffAssignmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClientStaffAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Folder
   */

  export type AggregateFolder = {
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  export type FolderMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    name: string | null
    parentId: string | null
    folderType: string | null
    isSystem: boolean | null
    clientVisible: boolean | null
    staffOnly: boolean | null
    adminOnly: boolean | null
    superAdminOnly: boolean | null
    restrictedAcl: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    name: string | null
    parentId: string | null
    folderType: string | null
    isSystem: boolean | null
    clientVisible: boolean | null
    staffOnly: boolean | null
    adminOnly: boolean | null
    superAdminOnly: boolean | null
    restrictedAcl: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderCountAggregateOutputType = {
    id: number
    clientId: number
    name: number
    parentId: number
    folderType: number
    isSystem: number
    clientVisible: number
    staffOnly: number
    adminOnly: number
    superAdminOnly: number
    restrictedAcl: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FolderMinAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    parentId?: true
    folderType?: true
    isSystem?: true
    clientVisible?: true
    staffOnly?: true
    adminOnly?: true
    superAdminOnly?: true
    restrictedAcl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderMaxAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    parentId?: true
    folderType?: true
    isSystem?: true
    clientVisible?: true
    staffOnly?: true
    adminOnly?: true
    superAdminOnly?: true
    restrictedAcl?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderCountAggregateInputType = {
    id?: true
    clientId?: true
    name?: true
    parentId?: true
    folderType?: true
    isSystem?: true
    clientVisible?: true
    staffOnly?: true
    adminOnly?: true
    superAdminOnly?: true
    restrictedAcl?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FolderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folder to aggregate.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Folders
    **/
    _count?: true | FolderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderMaxAggregateInputType
  }

  export type GetFolderAggregateType<T extends FolderAggregateArgs> = {
        [P in keyof T & keyof AggregateFolder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolder[P]>
      : GetScalarType<T[P], AggregateFolder[P]>
  }




  export type FolderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithAggregationInput | FolderOrderByWithAggregationInput[]
    by: FolderScalarFieldEnum[] | FolderScalarFieldEnum
    having?: FolderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderCountAggregateInputType | true
    _min?: FolderMinAggregateInputType
    _max?: FolderMaxAggregateInputType
  }

  export type FolderGroupByOutputType = {
    id: string
    clientId: string
    name: string
    parentId: string | null
    folderType: string | null
    isSystem: boolean
    clientVisible: boolean
    staffOnly: boolean
    adminOnly: boolean
    superAdminOnly: boolean
    restrictedAcl: boolean
    createdAt: Date
    updatedAt: Date
    _count: FolderCountAggregateOutputType | null
    _min: FolderMinAggregateOutputType | null
    _max: FolderMaxAggregateOutputType | null
  }

  type GetFolderGroupByPayload<T extends FolderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderGroupByOutputType[P]>
            : GetScalarType<T[P], FolderGroupByOutputType[P]>
        }
      >
    >


  export type FolderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    name?: boolean
    parentId?: boolean
    folderType?: boolean
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    parent?: boolean | Folder$parentArgs<ExtArgs>
    children?: boolean | Folder$childrenArgs<ExtArgs>
    documents?: boolean | Folder$documentsArgs<ExtArgs>
    folderAcl?: boolean | Folder$folderAclArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    name?: boolean
    parentId?: boolean
    folderType?: boolean
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    name?: boolean
    parentId?: boolean
    folderType?: boolean
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }, ExtArgs["result"]["folder"]>

  export type FolderSelectScalar = {
    id?: boolean
    clientId?: boolean
    name?: boolean
    parentId?: boolean
    folderType?: boolean
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FolderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "name" | "parentId" | "folderType" | "isSystem" | "clientVisible" | "staffOnly" | "adminOnly" | "superAdminOnly" | "restrictedAcl" | "createdAt" | "updatedAt", ExtArgs["result"]["folder"]>
  export type FolderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    parent?: boolean | Folder$parentArgs<ExtArgs>
    children?: boolean | Folder$childrenArgs<ExtArgs>
    documents?: boolean | Folder$documentsArgs<ExtArgs>
    folderAcl?: boolean | Folder$folderAclArgs<ExtArgs>
    _count?: boolean | FolderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FolderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }
  export type FolderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    parent?: boolean | Folder$parentArgs<ExtArgs>
  }

  export type $FolderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Folder"
    objects: {
      clientEntity: Prisma.$ClientEntityPayload<ExtArgs>
      parent: Prisma.$FolderPayload<ExtArgs> | null
      children: Prisma.$FolderPayload<ExtArgs>[]
      documents: Prisma.$DocumentPayload<ExtArgs>[]
      folderAcl: Prisma.$FolderAclPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      name: string
      parentId: string | null
      folderType: string | null
      isSystem: boolean
      clientVisible: boolean
      staffOnly: boolean
      adminOnly: boolean
      superAdminOnly: boolean
      restrictedAcl: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["folder"]>
    composites: {}
  }

  type FolderGetPayload<S extends boolean | null | undefined | FolderDefaultArgs> = $Result.GetResult<Prisma.$FolderPayload, S>

  type FolderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderCountAggregateInputType | true
    }

  export interface FolderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Folder'], meta: { name: 'Folder' } }
    /**
     * Find zero or one Folder that matches the filter.
     * @param {FolderFindUniqueArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderFindUniqueArgs>(args: SelectSubset<T, FolderFindUniqueArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Folder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderFindUniqueOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderFindFirstArgs>(args?: SelectSubset<T, FolderFindFirstArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Folder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindFirstOrThrowArgs} args - Arguments to find a Folder
     * @example
     * // Get one Folder
     * const folder = await prisma.folder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Folders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Folders
     * const folders = await prisma.folder.findMany()
     * 
     * // Get first 10 Folders
     * const folders = await prisma.folder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderWithIdOnly = await prisma.folder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderFindManyArgs>(args?: SelectSubset<T, FolderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Folder.
     * @param {FolderCreateArgs} args - Arguments to create a Folder.
     * @example
     * // Create one Folder
     * const Folder = await prisma.folder.create({
     *   data: {
     *     // ... data to create a Folder
     *   }
     * })
     * 
     */
    create<T extends FolderCreateArgs>(args: SelectSubset<T, FolderCreateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Folders.
     * @param {FolderCreateManyArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderCreateManyArgs>(args?: SelectSubset<T, FolderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Folders and returns the data saved in the database.
     * @param {FolderCreateManyAndReturnArgs} args - Arguments to create many Folders.
     * @example
     * // Create many Folders
     * const folder = await prisma.folder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Folder.
     * @param {FolderDeleteArgs} args - Arguments to delete one Folder.
     * @example
     * // Delete one Folder
     * const Folder = await prisma.folder.delete({
     *   where: {
     *     // ... filter to delete one Folder
     *   }
     * })
     * 
     */
    delete<T extends FolderDeleteArgs>(args: SelectSubset<T, FolderDeleteArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Folder.
     * @param {FolderUpdateArgs} args - Arguments to update one Folder.
     * @example
     * // Update one Folder
     * const folder = await prisma.folder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderUpdateArgs>(args: SelectSubset<T, FolderUpdateArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Folders.
     * @param {FolderDeleteManyArgs} args - Arguments to filter Folders to delete.
     * @example
     * // Delete a few Folders
     * const { count } = await prisma.folder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderDeleteManyArgs>(args?: SelectSubset<T, FolderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderUpdateManyArgs>(args: SelectSubset<T, FolderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Folders and returns the data updated in the database.
     * @param {FolderUpdateManyAndReturnArgs} args - Arguments to update many Folders.
     * @example
     * // Update many Folders
     * const folder = await prisma.folder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Folders and only return the `id`
     * const folderWithIdOnly = await prisma.folder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Folder.
     * @param {FolderUpsertArgs} args - Arguments to update or create a Folder.
     * @example
     * // Update or create a Folder
     * const folder = await prisma.folder.upsert({
     *   create: {
     *     // ... data to create a Folder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Folder we want to update
     *   }
     * })
     */
    upsert<T extends FolderUpsertArgs>(args: SelectSubset<T, FolderUpsertArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Folders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderCountArgs} args - Arguments to filter Folders to count.
     * @example
     * // Count the number of Folders
     * const count = await prisma.folder.count({
     *   where: {
     *     // ... the filter for the Folders we want to count
     *   }
     * })
    **/
    count<T extends FolderCountArgs>(
      args?: Subset<T, FolderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAggregateArgs>(args: Subset<T, FolderAggregateArgs>): Prisma.PrismaPromise<GetFolderAggregateType<T>>

    /**
     * Group by Folder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderGroupByArgs['orderBy'] }
        : { orderBy?: FolderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Folder model
   */
  readonly fields: FolderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Folder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientEntity<T extends ClientEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntityDefaultArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends Folder$parentArgs<ExtArgs> = {}>(args?: Subset<T, Folder$parentArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends Folder$childrenArgs<ExtArgs> = {}>(args?: Subset<T, Folder$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    documents<T extends Folder$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Folder$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    folderAcl<T extends Folder$folderAclArgs<ExtArgs> = {}>(args?: Subset<T, Folder$folderAclArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Folder model
   */
  interface FolderFieldRefs {
    readonly id: FieldRef<"Folder", 'String'>
    readonly clientId: FieldRef<"Folder", 'String'>
    readonly name: FieldRef<"Folder", 'String'>
    readonly parentId: FieldRef<"Folder", 'String'>
    readonly folderType: FieldRef<"Folder", 'String'>
    readonly isSystem: FieldRef<"Folder", 'Boolean'>
    readonly clientVisible: FieldRef<"Folder", 'Boolean'>
    readonly staffOnly: FieldRef<"Folder", 'Boolean'>
    readonly adminOnly: FieldRef<"Folder", 'Boolean'>
    readonly superAdminOnly: FieldRef<"Folder", 'Boolean'>
    readonly restrictedAcl: FieldRef<"Folder", 'Boolean'>
    readonly createdAt: FieldRef<"Folder", 'DateTime'>
    readonly updatedAt: FieldRef<"Folder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Folder findUnique
   */
  export type FolderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findUniqueOrThrow
   */
  export type FolderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder findFirst
   */
  export type FolderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findFirstOrThrow
   */
  export type FolderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folder to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Folders.
     */
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder findMany
   */
  export type FolderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter, which Folders to fetch.
     */
    where?: FolderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Folders to fetch.
     */
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Folders.
     */
    cursor?: FolderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Folders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Folders.
     */
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder create
   */
  export type FolderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to create a Folder.
     */
    data: XOR<FolderCreateInput, FolderUncheckedCreateInput>
  }

  /**
   * Folder createMany
   */
  export type FolderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Folder createManyAndReturn
   */
  export type FolderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to create many Folders.
     */
    data: FolderCreateManyInput | FolderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder update
   */
  export type FolderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The data needed to update a Folder.
     */
    data: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
    /**
     * Choose, which Folder to update.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder updateMany
   */
  export type FolderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
  }

  /**
   * Folder updateManyAndReturn
   */
  export type FolderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * The data used to update Folders.
     */
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyInput>
    /**
     * Filter which Folders to update
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Folder upsert
   */
  export type FolderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * The filter to search for the Folder to update in case it exists.
     */
    where: FolderWhereUniqueInput
    /**
     * In case the Folder found by the `where` argument doesn't exist, create a new Folder with this data.
     */
    create: XOR<FolderCreateInput, FolderUncheckedCreateInput>
    /**
     * In case the Folder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderUpdateInput, FolderUncheckedUpdateInput>
  }

  /**
   * Folder delete
   */
  export type FolderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    /**
     * Filter which Folder to delete.
     */
    where: FolderWhereUniqueInput
  }

  /**
   * Folder deleteMany
   */
  export type FolderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Folders to delete
     */
    where?: FolderWhereInput
    /**
     * Limit how many Folders to delete.
     */
    limit?: number
  }

  /**
   * Folder.parent
   */
  export type Folder$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Folder.children
   */
  export type Folder$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
    orderBy?: FolderOrderByWithRelationInput | FolderOrderByWithRelationInput[]
    cursor?: FolderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderScalarFieldEnum | FolderScalarFieldEnum[]
  }

  /**
   * Folder.documents
   */
  export type Folder$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    cursor?: DocumentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Folder.folderAcl
   */
  export type Folder$folderAclArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    where?: FolderAclWhereInput
    orderBy?: FolderAclOrderByWithRelationInput | FolderAclOrderByWithRelationInput[]
    cursor?: FolderAclWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FolderAclScalarFieldEnum | FolderAclScalarFieldEnum[]
  }

  /**
   * Folder without action
   */
  export type FolderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
  }


  /**
   * Model FolderAcl
   */

  export type AggregateFolderAcl = {
    _count: FolderAclCountAggregateOutputType | null
    _min: FolderAclMinAggregateOutputType | null
    _max: FolderAclMaxAggregateOutputType | null
  }

  export type FolderAclMinAggregateOutputType = {
    id: string | null
    folderId: string | null
    staffUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderAclMaxAggregateOutputType = {
    id: string | null
    folderId: string | null
    staffUserId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FolderAclCountAggregateOutputType = {
    id: number
    folderId: number
    staffUserId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FolderAclMinAggregateInputType = {
    id?: true
    folderId?: true
    staffUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderAclMaxAggregateInputType = {
    id?: true
    folderId?: true
    staffUserId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FolderAclCountAggregateInputType = {
    id?: true
    folderId?: true
    staffUserId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FolderAclAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FolderAcl to aggregate.
     */
    where?: FolderAclWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FolderAcls to fetch.
     */
    orderBy?: FolderAclOrderByWithRelationInput | FolderAclOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FolderAclWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FolderAcls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FolderAcls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FolderAcls
    **/
    _count?: true | FolderAclCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FolderAclMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FolderAclMaxAggregateInputType
  }

  export type GetFolderAclAggregateType<T extends FolderAclAggregateArgs> = {
        [P in keyof T & keyof AggregateFolderAcl]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFolderAcl[P]>
      : GetScalarType<T[P], AggregateFolderAcl[P]>
  }




  export type FolderAclGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FolderAclWhereInput
    orderBy?: FolderAclOrderByWithAggregationInput | FolderAclOrderByWithAggregationInput[]
    by: FolderAclScalarFieldEnum[] | FolderAclScalarFieldEnum
    having?: FolderAclScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FolderAclCountAggregateInputType | true
    _min?: FolderAclMinAggregateInputType
    _max?: FolderAclMaxAggregateInputType
  }

  export type FolderAclGroupByOutputType = {
    id: string
    folderId: string
    staffUserId: string
    createdAt: Date
    updatedAt: Date
    _count: FolderAclCountAggregateOutputType | null
    _min: FolderAclMinAggregateOutputType | null
    _max: FolderAclMaxAggregateOutputType | null
  }

  type GetFolderAclGroupByPayload<T extends FolderAclGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FolderAclGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FolderAclGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FolderAclGroupByOutputType[P]>
            : GetScalarType<T[P], FolderAclGroupByOutputType[P]>
        }
      >
    >


  export type FolderAclSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderId?: boolean
    staffUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folder?: boolean | FolderDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folderAcl"]>

  export type FolderAclSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderId?: boolean
    staffUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folder?: boolean | FolderDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folderAcl"]>

  export type FolderAclSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    folderId?: boolean
    staffUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    folder?: boolean | FolderDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["folderAcl"]>

  export type FolderAclSelectScalar = {
    id?: boolean
    folderId?: boolean
    staffUserId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FolderAclOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "folderId" | "staffUserId" | "createdAt" | "updatedAt", ExtArgs["result"]["folderAcl"]>
  export type FolderAclInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | FolderDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type FolderAclIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | FolderDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type FolderAclIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    folder?: boolean | FolderDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $FolderAclPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FolderAcl"
    objects: {
      folder: Prisma.$FolderPayload<ExtArgs>
      staff: Prisma.$StaffProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      folderId: string
      staffUserId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["folderAcl"]>
    composites: {}
  }

  type FolderAclGetPayload<S extends boolean | null | undefined | FolderAclDefaultArgs> = $Result.GetResult<Prisma.$FolderAclPayload, S>

  type FolderAclCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FolderAclFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FolderAclCountAggregateInputType | true
    }

  export interface FolderAclDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FolderAcl'], meta: { name: 'FolderAcl' } }
    /**
     * Find zero or one FolderAcl that matches the filter.
     * @param {FolderAclFindUniqueArgs} args - Arguments to find a FolderAcl
     * @example
     * // Get one FolderAcl
     * const folderAcl = await prisma.folderAcl.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FolderAclFindUniqueArgs>(args: SelectSubset<T, FolderAclFindUniqueArgs<ExtArgs>>): Prisma__FolderAclClient<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FolderAcl that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FolderAclFindUniqueOrThrowArgs} args - Arguments to find a FolderAcl
     * @example
     * // Get one FolderAcl
     * const folderAcl = await prisma.folderAcl.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FolderAclFindUniqueOrThrowArgs>(args: SelectSubset<T, FolderAclFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FolderAclClient<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FolderAcl that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAclFindFirstArgs} args - Arguments to find a FolderAcl
     * @example
     * // Get one FolderAcl
     * const folderAcl = await prisma.folderAcl.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FolderAclFindFirstArgs>(args?: SelectSubset<T, FolderAclFindFirstArgs<ExtArgs>>): Prisma__FolderAclClient<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FolderAcl that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAclFindFirstOrThrowArgs} args - Arguments to find a FolderAcl
     * @example
     * // Get one FolderAcl
     * const folderAcl = await prisma.folderAcl.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FolderAclFindFirstOrThrowArgs>(args?: SelectSubset<T, FolderAclFindFirstOrThrowArgs<ExtArgs>>): Prisma__FolderAclClient<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FolderAcls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAclFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FolderAcls
     * const folderAcls = await prisma.folderAcl.findMany()
     * 
     * // Get first 10 FolderAcls
     * const folderAcls = await prisma.folderAcl.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const folderAclWithIdOnly = await prisma.folderAcl.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FolderAclFindManyArgs>(args?: SelectSubset<T, FolderAclFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FolderAcl.
     * @param {FolderAclCreateArgs} args - Arguments to create a FolderAcl.
     * @example
     * // Create one FolderAcl
     * const FolderAcl = await prisma.folderAcl.create({
     *   data: {
     *     // ... data to create a FolderAcl
     *   }
     * })
     * 
     */
    create<T extends FolderAclCreateArgs>(args: SelectSubset<T, FolderAclCreateArgs<ExtArgs>>): Prisma__FolderAclClient<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FolderAcls.
     * @param {FolderAclCreateManyArgs} args - Arguments to create many FolderAcls.
     * @example
     * // Create many FolderAcls
     * const folderAcl = await prisma.folderAcl.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FolderAclCreateManyArgs>(args?: SelectSubset<T, FolderAclCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FolderAcls and returns the data saved in the database.
     * @param {FolderAclCreateManyAndReturnArgs} args - Arguments to create many FolderAcls.
     * @example
     * // Create many FolderAcls
     * const folderAcl = await prisma.folderAcl.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FolderAcls and only return the `id`
     * const folderAclWithIdOnly = await prisma.folderAcl.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FolderAclCreateManyAndReturnArgs>(args?: SelectSubset<T, FolderAclCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FolderAcl.
     * @param {FolderAclDeleteArgs} args - Arguments to delete one FolderAcl.
     * @example
     * // Delete one FolderAcl
     * const FolderAcl = await prisma.folderAcl.delete({
     *   where: {
     *     // ... filter to delete one FolderAcl
     *   }
     * })
     * 
     */
    delete<T extends FolderAclDeleteArgs>(args: SelectSubset<T, FolderAclDeleteArgs<ExtArgs>>): Prisma__FolderAclClient<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FolderAcl.
     * @param {FolderAclUpdateArgs} args - Arguments to update one FolderAcl.
     * @example
     * // Update one FolderAcl
     * const folderAcl = await prisma.folderAcl.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FolderAclUpdateArgs>(args: SelectSubset<T, FolderAclUpdateArgs<ExtArgs>>): Prisma__FolderAclClient<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FolderAcls.
     * @param {FolderAclDeleteManyArgs} args - Arguments to filter FolderAcls to delete.
     * @example
     * // Delete a few FolderAcls
     * const { count } = await prisma.folderAcl.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FolderAclDeleteManyArgs>(args?: SelectSubset<T, FolderAclDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FolderAcls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAclUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FolderAcls
     * const folderAcl = await prisma.folderAcl.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FolderAclUpdateManyArgs>(args: SelectSubset<T, FolderAclUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FolderAcls and returns the data updated in the database.
     * @param {FolderAclUpdateManyAndReturnArgs} args - Arguments to update many FolderAcls.
     * @example
     * // Update many FolderAcls
     * const folderAcl = await prisma.folderAcl.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FolderAcls and only return the `id`
     * const folderAclWithIdOnly = await prisma.folderAcl.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FolderAclUpdateManyAndReturnArgs>(args: SelectSubset<T, FolderAclUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FolderAcl.
     * @param {FolderAclUpsertArgs} args - Arguments to update or create a FolderAcl.
     * @example
     * // Update or create a FolderAcl
     * const folderAcl = await prisma.folderAcl.upsert({
     *   create: {
     *     // ... data to create a FolderAcl
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FolderAcl we want to update
     *   }
     * })
     */
    upsert<T extends FolderAclUpsertArgs>(args: SelectSubset<T, FolderAclUpsertArgs<ExtArgs>>): Prisma__FolderAclClient<$Result.GetResult<Prisma.$FolderAclPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FolderAcls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAclCountArgs} args - Arguments to filter FolderAcls to count.
     * @example
     * // Count the number of FolderAcls
     * const count = await prisma.folderAcl.count({
     *   where: {
     *     // ... the filter for the FolderAcls we want to count
     *   }
     * })
    **/
    count<T extends FolderAclCountArgs>(
      args?: Subset<T, FolderAclCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FolderAclCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FolderAcl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAclAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FolderAclAggregateArgs>(args: Subset<T, FolderAclAggregateArgs>): Prisma.PrismaPromise<GetFolderAclAggregateType<T>>

    /**
     * Group by FolderAcl.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FolderAclGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FolderAclGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FolderAclGroupByArgs['orderBy'] }
        : { orderBy?: FolderAclGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FolderAclGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFolderAclGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FolderAcl model
   */
  readonly fields: FolderAclFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FolderAcl.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FolderAclClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    folder<T extends FolderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, FolderDefaultArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FolderAcl model
   */
  interface FolderAclFieldRefs {
    readonly id: FieldRef<"FolderAcl", 'String'>
    readonly folderId: FieldRef<"FolderAcl", 'String'>
    readonly staffUserId: FieldRef<"FolderAcl", 'String'>
    readonly createdAt: FieldRef<"FolderAcl", 'DateTime'>
    readonly updatedAt: FieldRef<"FolderAcl", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FolderAcl findUnique
   */
  export type FolderAclFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * Filter, which FolderAcl to fetch.
     */
    where: FolderAclWhereUniqueInput
  }

  /**
   * FolderAcl findUniqueOrThrow
   */
  export type FolderAclFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * Filter, which FolderAcl to fetch.
     */
    where: FolderAclWhereUniqueInput
  }

  /**
   * FolderAcl findFirst
   */
  export type FolderAclFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * Filter, which FolderAcl to fetch.
     */
    where?: FolderAclWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FolderAcls to fetch.
     */
    orderBy?: FolderAclOrderByWithRelationInput | FolderAclOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FolderAcls.
     */
    cursor?: FolderAclWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FolderAcls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FolderAcls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FolderAcls.
     */
    distinct?: FolderAclScalarFieldEnum | FolderAclScalarFieldEnum[]
  }

  /**
   * FolderAcl findFirstOrThrow
   */
  export type FolderAclFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * Filter, which FolderAcl to fetch.
     */
    where?: FolderAclWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FolderAcls to fetch.
     */
    orderBy?: FolderAclOrderByWithRelationInput | FolderAclOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FolderAcls.
     */
    cursor?: FolderAclWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FolderAcls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FolderAcls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FolderAcls.
     */
    distinct?: FolderAclScalarFieldEnum | FolderAclScalarFieldEnum[]
  }

  /**
   * FolderAcl findMany
   */
  export type FolderAclFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * Filter, which FolderAcls to fetch.
     */
    where?: FolderAclWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FolderAcls to fetch.
     */
    orderBy?: FolderAclOrderByWithRelationInput | FolderAclOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FolderAcls.
     */
    cursor?: FolderAclWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FolderAcls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FolderAcls.
     */
    skip?: number
    distinct?: FolderAclScalarFieldEnum | FolderAclScalarFieldEnum[]
  }

  /**
   * FolderAcl create
   */
  export type FolderAclCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * The data needed to create a FolderAcl.
     */
    data: XOR<FolderAclCreateInput, FolderAclUncheckedCreateInput>
  }

  /**
   * FolderAcl createMany
   */
  export type FolderAclCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FolderAcls.
     */
    data: FolderAclCreateManyInput | FolderAclCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FolderAcl createManyAndReturn
   */
  export type FolderAclCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * The data used to create many FolderAcls.
     */
    data: FolderAclCreateManyInput | FolderAclCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FolderAcl update
   */
  export type FolderAclUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * The data needed to update a FolderAcl.
     */
    data: XOR<FolderAclUpdateInput, FolderAclUncheckedUpdateInput>
    /**
     * Choose, which FolderAcl to update.
     */
    where: FolderAclWhereUniqueInput
  }

  /**
   * FolderAcl updateMany
   */
  export type FolderAclUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FolderAcls.
     */
    data: XOR<FolderAclUpdateManyMutationInput, FolderAclUncheckedUpdateManyInput>
    /**
     * Filter which FolderAcls to update
     */
    where?: FolderAclWhereInput
    /**
     * Limit how many FolderAcls to update.
     */
    limit?: number
  }

  /**
   * FolderAcl updateManyAndReturn
   */
  export type FolderAclUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * The data used to update FolderAcls.
     */
    data: XOR<FolderAclUpdateManyMutationInput, FolderAclUncheckedUpdateManyInput>
    /**
     * Filter which FolderAcls to update
     */
    where?: FolderAclWhereInput
    /**
     * Limit how many FolderAcls to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FolderAcl upsert
   */
  export type FolderAclUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * The filter to search for the FolderAcl to update in case it exists.
     */
    where: FolderAclWhereUniqueInput
    /**
     * In case the FolderAcl found by the `where` argument doesn't exist, create a new FolderAcl with this data.
     */
    create: XOR<FolderAclCreateInput, FolderAclUncheckedCreateInput>
    /**
     * In case the FolderAcl was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FolderAclUpdateInput, FolderAclUncheckedUpdateInput>
  }

  /**
   * FolderAcl delete
   */
  export type FolderAclDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
    /**
     * Filter which FolderAcl to delete.
     */
    where: FolderAclWhereUniqueInput
  }

  /**
   * FolderAcl deleteMany
   */
  export type FolderAclDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FolderAcls to delete
     */
    where?: FolderAclWhereInput
    /**
     * Limit how many FolderAcls to delete.
     */
    limit?: number
  }

  /**
   * FolderAcl without action
   */
  export type FolderAclDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FolderAcl
     */
    select?: FolderAclSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FolderAcl
     */
    omit?: FolderAclOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderAclInclude<ExtArgs> | null
  }


  /**
   * Model Document
   */

  export type AggregateDocument = {
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  export type DocumentAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentSumAggregateOutputType = {
    fileSize: number | null
  }

  export type DocumentMinAggregateOutputType = {
    id: string | null
    clientId: string | null
    folderId: string | null
    storagePath: string | null
    displayName: string | null
    uploadedBy: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentMaxAggregateOutputType = {
    id: string | null
    clientId: string | null
    folderId: string | null
    storagePath: string | null
    displayName: string | null
    uploadedBy: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DocumentCountAggregateOutputType = {
    id: number
    clientId: number
    folderId: number
    storagePath: number
    displayName: number
    uploadedBy: number
    fileSize: number
    mimeType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DocumentAvgAggregateInputType = {
    fileSize?: true
  }

  export type DocumentSumAggregateInputType = {
    fileSize?: true
  }

  export type DocumentMinAggregateInputType = {
    id?: true
    clientId?: true
    folderId?: true
    storagePath?: true
    displayName?: true
    uploadedBy?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentMaxAggregateInputType = {
    id?: true
    clientId?: true
    folderId?: true
    storagePath?: true
    displayName?: true
    uploadedBy?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DocumentCountAggregateInputType = {
    id?: true
    clientId?: true
    folderId?: true
    storagePath?: true
    displayName?: true
    uploadedBy?: true
    fileSize?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DocumentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Document to aggregate.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documents
    **/
    _count?: true | DocumentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentMaxAggregateInputType
  }

  export type GetDocumentAggregateType<T extends DocumentAggregateArgs> = {
        [P in keyof T & keyof AggregateDocument]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocument[P]>
      : GetScalarType<T[P], AggregateDocument[P]>
  }




  export type DocumentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentWhereInput
    orderBy?: DocumentOrderByWithAggregationInput | DocumentOrderByWithAggregationInput[]
    by: DocumentScalarFieldEnum[] | DocumentScalarFieldEnum
    having?: DocumentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentCountAggregateInputType | true
    _avg?: DocumentAvgAggregateInputType
    _sum?: DocumentSumAggregateInputType
    _min?: DocumentMinAggregateInputType
    _max?: DocumentMaxAggregateInputType
  }

  export type DocumentGroupByOutputType = {
    id: string
    clientId: string
    folderId: string | null
    storagePath: string
    displayName: string
    uploadedBy: string | null
    fileSize: number | null
    mimeType: string | null
    createdAt: Date
    updatedAt: Date
    _count: DocumentCountAggregateOutputType | null
    _avg: DocumentAvgAggregateOutputType | null
    _sum: DocumentSumAggregateOutputType | null
    _min: DocumentMinAggregateOutputType | null
    _max: DocumentMaxAggregateOutputType | null
  }

  type GetDocumentGroupByPayload<T extends DocumentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentGroupByOutputType[P]>
        }
      >
    >


  export type DocumentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    folderId?: boolean
    storagePath?: boolean
    displayName?: boolean
    uploadedBy?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
    uploader?: boolean | Document$uploaderArgs<ExtArgs>
    checklistItems?: boolean | Document$checklistItemsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    folderId?: boolean
    storagePath?: boolean
    displayName?: boolean
    uploadedBy?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
    uploader?: boolean | Document$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clientId?: boolean
    folderId?: boolean
    storagePath?: boolean
    displayName?: boolean
    uploadedBy?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
    uploader?: boolean | Document$uploaderArgs<ExtArgs>
  }, ExtArgs["result"]["document"]>

  export type DocumentSelectScalar = {
    id?: boolean
    clientId?: boolean
    folderId?: boolean
    storagePath?: boolean
    displayName?: boolean
    uploadedBy?: boolean
    fileSize?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DocumentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "clientId" | "folderId" | "storagePath" | "displayName" | "uploadedBy" | "fileSize" | "mimeType" | "createdAt" | "updatedAt", ExtArgs["result"]["document"]>
  export type DocumentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
    uploader?: boolean | Document$uploaderArgs<ExtArgs>
    checklistItems?: boolean | Document$checklistItemsArgs<ExtArgs>
    _count?: boolean | DocumentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
    uploader?: boolean | Document$uploaderArgs<ExtArgs>
  }
  export type DocumentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clientEntity?: boolean | ClientEntityDefaultArgs<ExtArgs>
    folder?: boolean | Document$folderArgs<ExtArgs>
    uploader?: boolean | Document$uploaderArgs<ExtArgs>
  }

  export type $DocumentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Document"
    objects: {
      clientEntity: Prisma.$ClientEntityPayload<ExtArgs>
      folder: Prisma.$FolderPayload<ExtArgs> | null
      uploader: Prisma.$StaffProfilePayload<ExtArgs> | null
      checklistItems: Prisma.$ChecklistItemFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clientId: string
      folderId: string | null
      storagePath: string
      displayName: string
      uploadedBy: string | null
      fileSize: number | null
      mimeType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["document"]>
    composites: {}
  }

  type DocumentGetPayload<S extends boolean | null | undefined | DocumentDefaultArgs> = $Result.GetResult<Prisma.$DocumentPayload, S>

  type DocumentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentCountAggregateInputType | true
    }

  export interface DocumentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Document'], meta: { name: 'Document' } }
    /**
     * Find zero or one Document that matches the filter.
     * @param {DocumentFindUniqueArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentFindUniqueArgs>(args: SelectSubset<T, DocumentFindUniqueArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Document that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentFindUniqueOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentFindFirstArgs>(args?: SelectSubset<T, DocumentFindFirstArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Document that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindFirstOrThrowArgs} args - Arguments to find a Document
     * @example
     * // Get one Document
     * const document = await prisma.document.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Documents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documents
     * const documents = await prisma.document.findMany()
     * 
     * // Get first 10 Documents
     * const documents = await prisma.document.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentWithIdOnly = await prisma.document.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentFindManyArgs>(args?: SelectSubset<T, DocumentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Document.
     * @param {DocumentCreateArgs} args - Arguments to create a Document.
     * @example
     * // Create one Document
     * const Document = await prisma.document.create({
     *   data: {
     *     // ... data to create a Document
     *   }
     * })
     * 
     */
    create<T extends DocumentCreateArgs>(args: SelectSubset<T, DocumentCreateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Documents.
     * @param {DocumentCreateManyArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentCreateManyArgs>(args?: SelectSubset<T, DocumentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documents and returns the data saved in the database.
     * @param {DocumentCreateManyAndReturnArgs} args - Arguments to create many Documents.
     * @example
     * // Create many Documents
     * const document = await prisma.document.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Document.
     * @param {DocumentDeleteArgs} args - Arguments to delete one Document.
     * @example
     * // Delete one Document
     * const Document = await prisma.document.delete({
     *   where: {
     *     // ... filter to delete one Document
     *   }
     * })
     * 
     */
    delete<T extends DocumentDeleteArgs>(args: SelectSubset<T, DocumentDeleteArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Document.
     * @param {DocumentUpdateArgs} args - Arguments to update one Document.
     * @example
     * // Update one Document
     * const document = await prisma.document.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentUpdateArgs>(args: SelectSubset<T, DocumentUpdateArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Documents.
     * @param {DocumentDeleteManyArgs} args - Arguments to filter Documents to delete.
     * @example
     * // Delete a few Documents
     * const { count } = await prisma.document.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentDeleteManyArgs>(args?: SelectSubset<T, DocumentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentUpdateManyArgs>(args: SelectSubset<T, DocumentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documents and returns the data updated in the database.
     * @param {DocumentUpdateManyAndReturnArgs} args - Arguments to update many Documents.
     * @example
     * // Update many Documents
     * const document = await prisma.document.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Documents and only return the `id`
     * const documentWithIdOnly = await prisma.document.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Document.
     * @param {DocumentUpsertArgs} args - Arguments to update or create a Document.
     * @example
     * // Update or create a Document
     * const document = await prisma.document.upsert({
     *   create: {
     *     // ... data to create a Document
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Document we want to update
     *   }
     * })
     */
    upsert<T extends DocumentUpsertArgs>(args: SelectSubset<T, DocumentUpsertArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Documents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentCountArgs} args - Arguments to filter Documents to count.
     * @example
     * // Count the number of Documents
     * const count = await prisma.document.count({
     *   where: {
     *     // ... the filter for the Documents we want to count
     *   }
     * })
    **/
    count<T extends DocumentCountArgs>(
      args?: Subset<T, DocumentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentAggregateArgs>(args: Subset<T, DocumentAggregateArgs>): Prisma.PrismaPromise<GetDocumentAggregateType<T>>

    /**
     * Group by Document.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentGroupByArgs['orderBy'] }
        : { orderBy?: DocumentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Document model
   */
  readonly fields: DocumentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Document.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clientEntity<T extends ClientEntityDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClientEntityDefaultArgs<ExtArgs>>): Prisma__ClientEntityClient<$Result.GetResult<Prisma.$ClientEntityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    folder<T extends Document$folderArgs<ExtArgs> = {}>(args?: Subset<T, Document$folderArgs<ExtArgs>>): Prisma__FolderClient<$Result.GetResult<Prisma.$FolderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    uploader<T extends Document$uploaderArgs<ExtArgs> = {}>(args?: Subset<T, Document$uploaderArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    checklistItems<T extends Document$checklistItemsArgs<ExtArgs> = {}>(args?: Subset<T, Document$checklistItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Document model
   */
  interface DocumentFieldRefs {
    readonly id: FieldRef<"Document", 'String'>
    readonly clientId: FieldRef<"Document", 'String'>
    readonly folderId: FieldRef<"Document", 'String'>
    readonly storagePath: FieldRef<"Document", 'String'>
    readonly displayName: FieldRef<"Document", 'String'>
    readonly uploadedBy: FieldRef<"Document", 'String'>
    readonly fileSize: FieldRef<"Document", 'Int'>
    readonly mimeType: FieldRef<"Document", 'String'>
    readonly createdAt: FieldRef<"Document", 'DateTime'>
    readonly updatedAt: FieldRef<"Document", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Document findUnique
   */
  export type DocumentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findUniqueOrThrow
   */
  export type DocumentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document findFirst
   */
  export type DocumentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findFirstOrThrow
   */
  export type DocumentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Document to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documents.
     */
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document findMany
   */
  export type DocumentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter, which Documents to fetch.
     */
    where?: DocumentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documents to fetch.
     */
    orderBy?: DocumentOrderByWithRelationInput | DocumentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documents.
     */
    cursor?: DocumentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documents.
     */
    skip?: number
    distinct?: DocumentScalarFieldEnum | DocumentScalarFieldEnum[]
  }

  /**
   * Document create
   */
  export type DocumentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to create a Document.
     */
    data: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
  }

  /**
   * Document createMany
   */
  export type DocumentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Document createManyAndReturn
   */
  export type DocumentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to create many Documents.
     */
    data: DocumentCreateManyInput | DocumentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document update
   */
  export type DocumentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The data needed to update a Document.
     */
    data: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
    /**
     * Choose, which Document to update.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document updateMany
   */
  export type DocumentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
  }

  /**
   * Document updateManyAndReturn
   */
  export type DocumentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * The data used to update Documents.
     */
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyInput>
    /**
     * Filter which Documents to update
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Document upsert
   */
  export type DocumentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * The filter to search for the Document to update in case it exists.
     */
    where: DocumentWhereUniqueInput
    /**
     * In case the Document found by the `where` argument doesn't exist, create a new Document with this data.
     */
    create: XOR<DocumentCreateInput, DocumentUncheckedCreateInput>
    /**
     * In case the Document was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentUpdateInput, DocumentUncheckedUpdateInput>
  }

  /**
   * Document delete
   */
  export type DocumentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
    /**
     * Filter which Document to delete.
     */
    where: DocumentWhereUniqueInput
  }

  /**
   * Document deleteMany
   */
  export type DocumentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documents to delete
     */
    where?: DocumentWhereInput
    /**
     * Limit how many Documents to delete.
     */
    limit?: number
  }

  /**
   * Document.folder
   */
  export type Document$folderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Folder
     */
    select?: FolderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Folder
     */
    omit?: FolderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FolderInclude<ExtArgs> | null
    where?: FolderWhereInput
  }

  /**
   * Document.uploader
   */
  export type Document$uploaderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * Document.checklistItems
   */
  export type Document$checklistItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    where?: ChecklistItemFileWhereInput
    orderBy?: ChecklistItemFileOrderByWithRelationInput | ChecklistItemFileOrderByWithRelationInput[]
    cursor?: ChecklistItemFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChecklistItemFileScalarFieldEnum | ChecklistItemFileScalarFieldEnum[]
  }

  /**
   * Document without action
   */
  export type DocumentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Document
     */
    select?: DocumentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Document
     */
    omit?: DocumentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentInclude<ExtArgs> | null
  }


  /**
   * Model ChecklistItem
   */

  export type AggregateChecklistItem = {
    _count: ChecklistItemCountAggregateOutputType | null
    _min: ChecklistItemMinAggregateOutputType | null
    _max: ChecklistItemMaxAggregateOutputType | null
  }

  export type ChecklistItemMinAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    itemName: string | null
    itemType: string | null
    required: boolean | null
    status: $Enums.ChecklistItemStatus | null
    receivedAt: Date | null
    markedNotApplicableAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChecklistItemMaxAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    itemName: string | null
    itemType: string | null
    required: boolean | null
    status: $Enums.ChecklistItemStatus | null
    receivedAt: Date | null
    markedNotApplicableAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChecklistItemCountAggregateOutputType = {
    id: number
    entityTaxYearId: number
    itemName: number
    itemType: number
    required: number
    status: number
    receivedAt: number
    markedNotApplicableAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChecklistItemMinAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    itemName?: true
    itemType?: true
    required?: true
    status?: true
    receivedAt?: true
    markedNotApplicableAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChecklistItemMaxAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    itemName?: true
    itemType?: true
    required?: true
    status?: true
    receivedAt?: true
    markedNotApplicableAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChecklistItemCountAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    itemName?: true
    itemType?: true
    required?: true
    status?: true
    receivedAt?: true
    markedNotApplicableAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChecklistItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChecklistItem to aggregate.
     */
    where?: ChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItems to fetch.
     */
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChecklistItems
    **/
    _count?: true | ChecklistItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChecklistItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChecklistItemMaxAggregateInputType
  }

  export type GetChecklistItemAggregateType<T extends ChecklistItemAggregateArgs> = {
        [P in keyof T & keyof AggregateChecklistItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChecklistItem[P]>
      : GetScalarType<T[P], AggregateChecklistItem[P]>
  }




  export type ChecklistItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistItemWhereInput
    orderBy?: ChecklistItemOrderByWithAggregationInput | ChecklistItemOrderByWithAggregationInput[]
    by: ChecklistItemScalarFieldEnum[] | ChecklistItemScalarFieldEnum
    having?: ChecklistItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChecklistItemCountAggregateInputType | true
    _min?: ChecklistItemMinAggregateInputType
    _max?: ChecklistItemMaxAggregateInputType
  }

  export type ChecklistItemGroupByOutputType = {
    id: string
    entityTaxYearId: string
    itemName: string
    itemType: string | null
    required: boolean
    status: $Enums.ChecklistItemStatus
    receivedAt: Date | null
    markedNotApplicableAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChecklistItemCountAggregateOutputType | null
    _min: ChecklistItemMinAggregateOutputType | null
    _max: ChecklistItemMaxAggregateOutputType | null
  }

  type GetChecklistItemGroupByPayload<T extends ChecklistItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChecklistItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChecklistItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChecklistItemGroupByOutputType[P]>
            : GetScalarType<T[P], ChecklistItemGroupByOutputType[P]>
        }
      >
    >


  export type ChecklistItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    itemName?: boolean
    itemType?: boolean
    required?: boolean
    status?: boolean
    receivedAt?: boolean
    markedNotApplicableAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    files?: boolean | ChecklistItem$filesArgs<ExtArgs>
    _count?: boolean | ChecklistItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItem"]>

  export type ChecklistItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    itemName?: boolean
    itemType?: boolean
    required?: boolean
    status?: boolean
    receivedAt?: boolean
    markedNotApplicableAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItem"]>

  export type ChecklistItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    itemName?: boolean
    itemType?: boolean
    required?: boolean
    status?: boolean
    receivedAt?: boolean
    markedNotApplicableAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItem"]>

  export type ChecklistItemSelectScalar = {
    id?: boolean
    entityTaxYearId?: boolean
    itemName?: boolean
    itemType?: boolean
    required?: boolean
    status?: boolean
    receivedAt?: boolean
    markedNotApplicableAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChecklistItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityTaxYearId" | "itemName" | "itemType" | "required" | "status" | "receivedAt" | "markedNotApplicableAt" | "notes" | "createdAt" | "updatedAt", ExtArgs["result"]["checklistItem"]>
  export type ChecklistItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    files?: boolean | ChecklistItem$filesArgs<ExtArgs>
    _count?: boolean | ChecklistItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChecklistItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type ChecklistItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }

  export type $ChecklistItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChecklistItem"
    objects: {
      entityTaxYear: Prisma.$EntityTaxYearPayload<ExtArgs>
      files: Prisma.$ChecklistItemFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityTaxYearId: string
      itemName: string
      itemType: string | null
      required: boolean
      status: $Enums.ChecklistItemStatus
      receivedAt: Date | null
      markedNotApplicableAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["checklistItem"]>
    composites: {}
  }

  type ChecklistItemGetPayload<S extends boolean | null | undefined | ChecklistItemDefaultArgs> = $Result.GetResult<Prisma.$ChecklistItemPayload, S>

  type ChecklistItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChecklistItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChecklistItemCountAggregateInputType | true
    }

  export interface ChecklistItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChecklistItem'], meta: { name: 'ChecklistItem' } }
    /**
     * Find zero or one ChecklistItem that matches the filter.
     * @param {ChecklistItemFindUniqueArgs} args - Arguments to find a ChecklistItem
     * @example
     * // Get one ChecklistItem
     * const checklistItem = await prisma.checklistItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChecklistItemFindUniqueArgs>(args: SelectSubset<T, ChecklistItemFindUniqueArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChecklistItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChecklistItemFindUniqueOrThrowArgs} args - Arguments to find a ChecklistItem
     * @example
     * // Get one ChecklistItem
     * const checklistItem = await prisma.checklistItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChecklistItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ChecklistItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChecklistItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFindFirstArgs} args - Arguments to find a ChecklistItem
     * @example
     * // Get one ChecklistItem
     * const checklistItem = await prisma.checklistItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChecklistItemFindFirstArgs>(args?: SelectSubset<T, ChecklistItemFindFirstArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChecklistItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFindFirstOrThrowArgs} args - Arguments to find a ChecklistItem
     * @example
     * // Get one ChecklistItem
     * const checklistItem = await prisma.checklistItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChecklistItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ChecklistItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChecklistItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChecklistItems
     * const checklistItems = await prisma.checklistItem.findMany()
     * 
     * // Get first 10 ChecklistItems
     * const checklistItems = await prisma.checklistItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checklistItemWithIdOnly = await prisma.checklistItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChecklistItemFindManyArgs>(args?: SelectSubset<T, ChecklistItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChecklistItem.
     * @param {ChecklistItemCreateArgs} args - Arguments to create a ChecklistItem.
     * @example
     * // Create one ChecklistItem
     * const ChecklistItem = await prisma.checklistItem.create({
     *   data: {
     *     // ... data to create a ChecklistItem
     *   }
     * })
     * 
     */
    create<T extends ChecklistItemCreateArgs>(args: SelectSubset<T, ChecklistItemCreateArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChecklistItems.
     * @param {ChecklistItemCreateManyArgs} args - Arguments to create many ChecklistItems.
     * @example
     * // Create many ChecklistItems
     * const checklistItem = await prisma.checklistItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChecklistItemCreateManyArgs>(args?: SelectSubset<T, ChecklistItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChecklistItems and returns the data saved in the database.
     * @param {ChecklistItemCreateManyAndReturnArgs} args - Arguments to create many ChecklistItems.
     * @example
     * // Create many ChecklistItems
     * const checklistItem = await prisma.checklistItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChecklistItems and only return the `id`
     * const checklistItemWithIdOnly = await prisma.checklistItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChecklistItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ChecklistItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChecklistItem.
     * @param {ChecklistItemDeleteArgs} args - Arguments to delete one ChecklistItem.
     * @example
     * // Delete one ChecklistItem
     * const ChecklistItem = await prisma.checklistItem.delete({
     *   where: {
     *     // ... filter to delete one ChecklistItem
     *   }
     * })
     * 
     */
    delete<T extends ChecklistItemDeleteArgs>(args: SelectSubset<T, ChecklistItemDeleteArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChecklistItem.
     * @param {ChecklistItemUpdateArgs} args - Arguments to update one ChecklistItem.
     * @example
     * // Update one ChecklistItem
     * const checklistItem = await prisma.checklistItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChecklistItemUpdateArgs>(args: SelectSubset<T, ChecklistItemUpdateArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChecklistItems.
     * @param {ChecklistItemDeleteManyArgs} args - Arguments to filter ChecklistItems to delete.
     * @example
     * // Delete a few ChecklistItems
     * const { count } = await prisma.checklistItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChecklistItemDeleteManyArgs>(args?: SelectSubset<T, ChecklistItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChecklistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChecklistItems
     * const checklistItem = await prisma.checklistItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChecklistItemUpdateManyArgs>(args: SelectSubset<T, ChecklistItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChecklistItems and returns the data updated in the database.
     * @param {ChecklistItemUpdateManyAndReturnArgs} args - Arguments to update many ChecklistItems.
     * @example
     * // Update many ChecklistItems
     * const checklistItem = await prisma.checklistItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChecklistItems and only return the `id`
     * const checklistItemWithIdOnly = await prisma.checklistItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChecklistItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ChecklistItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChecklistItem.
     * @param {ChecklistItemUpsertArgs} args - Arguments to update or create a ChecklistItem.
     * @example
     * // Update or create a ChecklistItem
     * const checklistItem = await prisma.checklistItem.upsert({
     *   create: {
     *     // ... data to create a ChecklistItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChecklistItem we want to update
     *   }
     * })
     */
    upsert<T extends ChecklistItemUpsertArgs>(args: SelectSubset<T, ChecklistItemUpsertArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChecklistItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemCountArgs} args - Arguments to filter ChecklistItems to count.
     * @example
     * // Count the number of ChecklistItems
     * const count = await prisma.checklistItem.count({
     *   where: {
     *     // ... the filter for the ChecklistItems we want to count
     *   }
     * })
    **/
    count<T extends ChecklistItemCountArgs>(
      args?: Subset<T, ChecklistItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChecklistItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChecklistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChecklistItemAggregateArgs>(args: Subset<T, ChecklistItemAggregateArgs>): Prisma.PrismaPromise<GetChecklistItemAggregateType<T>>

    /**
     * Group by ChecklistItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChecklistItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChecklistItemGroupByArgs['orderBy'] }
        : { orderBy?: ChecklistItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChecklistItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChecklistItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChecklistItem model
   */
  readonly fields: ChecklistItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChecklistItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChecklistItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityTaxYear<T extends EntityTaxYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYearDefaultArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends ChecklistItem$filesArgs<ExtArgs> = {}>(args?: Subset<T, ChecklistItem$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChecklistItem model
   */
  interface ChecklistItemFieldRefs {
    readonly id: FieldRef<"ChecklistItem", 'String'>
    readonly entityTaxYearId: FieldRef<"ChecklistItem", 'String'>
    readonly itemName: FieldRef<"ChecklistItem", 'String'>
    readonly itemType: FieldRef<"ChecklistItem", 'String'>
    readonly required: FieldRef<"ChecklistItem", 'Boolean'>
    readonly status: FieldRef<"ChecklistItem", 'ChecklistItemStatus'>
    readonly receivedAt: FieldRef<"ChecklistItem", 'DateTime'>
    readonly markedNotApplicableAt: FieldRef<"ChecklistItem", 'DateTime'>
    readonly notes: FieldRef<"ChecklistItem", 'String'>
    readonly createdAt: FieldRef<"ChecklistItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ChecklistItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChecklistItem findUnique
   */
  export type ChecklistItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItem to fetch.
     */
    where: ChecklistItemWhereUniqueInput
  }

  /**
   * ChecklistItem findUniqueOrThrow
   */
  export type ChecklistItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItem to fetch.
     */
    where: ChecklistItemWhereUniqueInput
  }

  /**
   * ChecklistItem findFirst
   */
  export type ChecklistItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItem to fetch.
     */
    where?: ChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItems to fetch.
     */
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChecklistItems.
     */
    cursor?: ChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChecklistItems.
     */
    distinct?: ChecklistItemScalarFieldEnum | ChecklistItemScalarFieldEnum[]
  }

  /**
   * ChecklistItem findFirstOrThrow
   */
  export type ChecklistItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItem to fetch.
     */
    where?: ChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItems to fetch.
     */
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChecklistItems.
     */
    cursor?: ChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChecklistItems.
     */
    distinct?: ChecklistItemScalarFieldEnum | ChecklistItemScalarFieldEnum[]
  }

  /**
   * ChecklistItem findMany
   */
  export type ChecklistItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItems to fetch.
     */
    where?: ChecklistItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItems to fetch.
     */
    orderBy?: ChecklistItemOrderByWithRelationInput | ChecklistItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChecklistItems.
     */
    cursor?: ChecklistItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItems.
     */
    skip?: number
    distinct?: ChecklistItemScalarFieldEnum | ChecklistItemScalarFieldEnum[]
  }

  /**
   * ChecklistItem create
   */
  export type ChecklistItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ChecklistItem.
     */
    data: XOR<ChecklistItemCreateInput, ChecklistItemUncheckedCreateInput>
  }

  /**
   * ChecklistItem createMany
   */
  export type ChecklistItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChecklistItems.
     */
    data: ChecklistItemCreateManyInput | ChecklistItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChecklistItem createManyAndReturn
   */
  export type ChecklistItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * The data used to create many ChecklistItems.
     */
    data: ChecklistItemCreateManyInput | ChecklistItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChecklistItem update
   */
  export type ChecklistItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ChecklistItem.
     */
    data: XOR<ChecklistItemUpdateInput, ChecklistItemUncheckedUpdateInput>
    /**
     * Choose, which ChecklistItem to update.
     */
    where: ChecklistItemWhereUniqueInput
  }

  /**
   * ChecklistItem updateMany
   */
  export type ChecklistItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChecklistItems.
     */
    data: XOR<ChecklistItemUpdateManyMutationInput, ChecklistItemUncheckedUpdateManyInput>
    /**
     * Filter which ChecklistItems to update
     */
    where?: ChecklistItemWhereInput
    /**
     * Limit how many ChecklistItems to update.
     */
    limit?: number
  }

  /**
   * ChecklistItem updateManyAndReturn
   */
  export type ChecklistItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * The data used to update ChecklistItems.
     */
    data: XOR<ChecklistItemUpdateManyMutationInput, ChecklistItemUncheckedUpdateManyInput>
    /**
     * Filter which ChecklistItems to update
     */
    where?: ChecklistItemWhereInput
    /**
     * Limit how many ChecklistItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChecklistItem upsert
   */
  export type ChecklistItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ChecklistItem to update in case it exists.
     */
    where: ChecklistItemWhereUniqueInput
    /**
     * In case the ChecklistItem found by the `where` argument doesn't exist, create a new ChecklistItem with this data.
     */
    create: XOR<ChecklistItemCreateInput, ChecklistItemUncheckedCreateInput>
    /**
     * In case the ChecklistItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChecklistItemUpdateInput, ChecklistItemUncheckedUpdateInput>
  }

  /**
   * ChecklistItem delete
   */
  export type ChecklistItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
    /**
     * Filter which ChecklistItem to delete.
     */
    where: ChecklistItemWhereUniqueInput
  }

  /**
   * ChecklistItem deleteMany
   */
  export type ChecklistItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChecklistItems to delete
     */
    where?: ChecklistItemWhereInput
    /**
     * Limit how many ChecklistItems to delete.
     */
    limit?: number
  }

  /**
   * ChecklistItem.files
   */
  export type ChecklistItem$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    where?: ChecklistItemFileWhereInput
    orderBy?: ChecklistItemFileOrderByWithRelationInput | ChecklistItemFileOrderByWithRelationInput[]
    cursor?: ChecklistItemFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChecklistItemFileScalarFieldEnum | ChecklistItemFileScalarFieldEnum[]
  }

  /**
   * ChecklistItem without action
   */
  export type ChecklistItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItem
     */
    select?: ChecklistItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItem
     */
    omit?: ChecklistItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemInclude<ExtArgs> | null
  }


  /**
   * Model ChecklistItemFile
   */

  export type AggregateChecklistItemFile = {
    _count: ChecklistItemFileCountAggregateOutputType | null
    _min: ChecklistItemFileMinAggregateOutputType | null
    _max: ChecklistItemFileMaxAggregateOutputType | null
  }

  export type ChecklistItemFileMinAggregateOutputType = {
    id: string | null
    checklistItemId: string | null
    documentId: string | null
    createdAt: Date | null
  }

  export type ChecklistItemFileMaxAggregateOutputType = {
    id: string | null
    checklistItemId: string | null
    documentId: string | null
    createdAt: Date | null
  }

  export type ChecklistItemFileCountAggregateOutputType = {
    id: number
    checklistItemId: number
    documentId: number
    createdAt: number
    _all: number
  }


  export type ChecklistItemFileMinAggregateInputType = {
    id?: true
    checklistItemId?: true
    documentId?: true
    createdAt?: true
  }

  export type ChecklistItemFileMaxAggregateInputType = {
    id?: true
    checklistItemId?: true
    documentId?: true
    createdAt?: true
  }

  export type ChecklistItemFileCountAggregateInputType = {
    id?: true
    checklistItemId?: true
    documentId?: true
    createdAt?: true
    _all?: true
  }

  export type ChecklistItemFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChecklistItemFile to aggregate.
     */
    where?: ChecklistItemFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItemFiles to fetch.
     */
    orderBy?: ChecklistItemFileOrderByWithRelationInput | ChecklistItemFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChecklistItemFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItemFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItemFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChecklistItemFiles
    **/
    _count?: true | ChecklistItemFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChecklistItemFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChecklistItemFileMaxAggregateInputType
  }

  export type GetChecklistItemFileAggregateType<T extends ChecklistItemFileAggregateArgs> = {
        [P in keyof T & keyof AggregateChecklistItemFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChecklistItemFile[P]>
      : GetScalarType<T[P], AggregateChecklistItemFile[P]>
  }




  export type ChecklistItemFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChecklistItemFileWhereInput
    orderBy?: ChecklistItemFileOrderByWithAggregationInput | ChecklistItemFileOrderByWithAggregationInput[]
    by: ChecklistItemFileScalarFieldEnum[] | ChecklistItemFileScalarFieldEnum
    having?: ChecklistItemFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChecklistItemFileCountAggregateInputType | true
    _min?: ChecklistItemFileMinAggregateInputType
    _max?: ChecklistItemFileMaxAggregateInputType
  }

  export type ChecklistItemFileGroupByOutputType = {
    id: string
    checklistItemId: string
    documentId: string
    createdAt: Date
    _count: ChecklistItemFileCountAggregateOutputType | null
    _min: ChecklistItemFileMinAggregateOutputType | null
    _max: ChecklistItemFileMaxAggregateOutputType | null
  }

  type GetChecklistItemFileGroupByPayload<T extends ChecklistItemFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChecklistItemFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChecklistItemFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChecklistItemFileGroupByOutputType[P]>
            : GetScalarType<T[P], ChecklistItemFileGroupByOutputType[P]>
        }
      >
    >


  export type ChecklistItemFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checklistItemId?: boolean
    documentId?: boolean
    createdAt?: boolean
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItemFile"]>

  export type ChecklistItemFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checklistItemId?: boolean
    documentId?: boolean
    createdAt?: boolean
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItemFile"]>

  export type ChecklistItemFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checklistItemId?: boolean
    documentId?: boolean
    createdAt?: boolean
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklistItemFile"]>

  export type ChecklistItemFileSelectScalar = {
    id?: boolean
    checklistItemId?: boolean
    documentId?: boolean
    createdAt?: boolean
  }

  export type ChecklistItemFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "checklistItemId" | "documentId" | "createdAt", ExtArgs["result"]["checklistItemFile"]>
  export type ChecklistItemFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type ChecklistItemFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }
  export type ChecklistItemFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklistItem?: boolean | ChecklistItemDefaultArgs<ExtArgs>
    document?: boolean | DocumentDefaultArgs<ExtArgs>
  }

  export type $ChecklistItemFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChecklistItemFile"
    objects: {
      checklistItem: Prisma.$ChecklistItemPayload<ExtArgs>
      document: Prisma.$DocumentPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      checklistItemId: string
      documentId: string
      createdAt: Date
    }, ExtArgs["result"]["checklistItemFile"]>
    composites: {}
  }

  type ChecklistItemFileGetPayload<S extends boolean | null | undefined | ChecklistItemFileDefaultArgs> = $Result.GetResult<Prisma.$ChecklistItemFilePayload, S>

  type ChecklistItemFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChecklistItemFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChecklistItemFileCountAggregateInputType | true
    }

  export interface ChecklistItemFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChecklistItemFile'], meta: { name: 'ChecklistItemFile' } }
    /**
     * Find zero or one ChecklistItemFile that matches the filter.
     * @param {ChecklistItemFileFindUniqueArgs} args - Arguments to find a ChecklistItemFile
     * @example
     * // Get one ChecklistItemFile
     * const checklistItemFile = await prisma.checklistItemFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChecklistItemFileFindUniqueArgs>(args: SelectSubset<T, ChecklistItemFileFindUniqueArgs<ExtArgs>>): Prisma__ChecklistItemFileClient<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChecklistItemFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChecklistItemFileFindUniqueOrThrowArgs} args - Arguments to find a ChecklistItemFile
     * @example
     * // Get one ChecklistItemFile
     * const checklistItemFile = await prisma.checklistItemFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChecklistItemFileFindUniqueOrThrowArgs>(args: SelectSubset<T, ChecklistItemFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChecklistItemFileClient<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChecklistItemFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFileFindFirstArgs} args - Arguments to find a ChecklistItemFile
     * @example
     * // Get one ChecklistItemFile
     * const checklistItemFile = await prisma.checklistItemFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChecklistItemFileFindFirstArgs>(args?: SelectSubset<T, ChecklistItemFileFindFirstArgs<ExtArgs>>): Prisma__ChecklistItemFileClient<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChecklistItemFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFileFindFirstOrThrowArgs} args - Arguments to find a ChecklistItemFile
     * @example
     * // Get one ChecklistItemFile
     * const checklistItemFile = await prisma.checklistItemFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChecklistItemFileFindFirstOrThrowArgs>(args?: SelectSubset<T, ChecklistItemFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChecklistItemFileClient<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChecklistItemFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChecklistItemFiles
     * const checklistItemFiles = await prisma.checklistItemFile.findMany()
     * 
     * // Get first 10 ChecklistItemFiles
     * const checklistItemFiles = await prisma.checklistItemFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checklistItemFileWithIdOnly = await prisma.checklistItemFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChecklistItemFileFindManyArgs>(args?: SelectSubset<T, ChecklistItemFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChecklistItemFile.
     * @param {ChecklistItemFileCreateArgs} args - Arguments to create a ChecklistItemFile.
     * @example
     * // Create one ChecklistItemFile
     * const ChecklistItemFile = await prisma.checklistItemFile.create({
     *   data: {
     *     // ... data to create a ChecklistItemFile
     *   }
     * })
     * 
     */
    create<T extends ChecklistItemFileCreateArgs>(args: SelectSubset<T, ChecklistItemFileCreateArgs<ExtArgs>>): Prisma__ChecklistItemFileClient<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChecklistItemFiles.
     * @param {ChecklistItemFileCreateManyArgs} args - Arguments to create many ChecklistItemFiles.
     * @example
     * // Create many ChecklistItemFiles
     * const checklistItemFile = await prisma.checklistItemFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChecklistItemFileCreateManyArgs>(args?: SelectSubset<T, ChecklistItemFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChecklistItemFiles and returns the data saved in the database.
     * @param {ChecklistItemFileCreateManyAndReturnArgs} args - Arguments to create many ChecklistItemFiles.
     * @example
     * // Create many ChecklistItemFiles
     * const checklistItemFile = await prisma.checklistItemFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChecklistItemFiles and only return the `id`
     * const checklistItemFileWithIdOnly = await prisma.checklistItemFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChecklistItemFileCreateManyAndReturnArgs>(args?: SelectSubset<T, ChecklistItemFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChecklistItemFile.
     * @param {ChecklistItemFileDeleteArgs} args - Arguments to delete one ChecklistItemFile.
     * @example
     * // Delete one ChecklistItemFile
     * const ChecklistItemFile = await prisma.checklistItemFile.delete({
     *   where: {
     *     // ... filter to delete one ChecklistItemFile
     *   }
     * })
     * 
     */
    delete<T extends ChecklistItemFileDeleteArgs>(args: SelectSubset<T, ChecklistItemFileDeleteArgs<ExtArgs>>): Prisma__ChecklistItemFileClient<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChecklistItemFile.
     * @param {ChecklistItemFileUpdateArgs} args - Arguments to update one ChecklistItemFile.
     * @example
     * // Update one ChecklistItemFile
     * const checklistItemFile = await prisma.checklistItemFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChecklistItemFileUpdateArgs>(args: SelectSubset<T, ChecklistItemFileUpdateArgs<ExtArgs>>): Prisma__ChecklistItemFileClient<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChecklistItemFiles.
     * @param {ChecklistItemFileDeleteManyArgs} args - Arguments to filter ChecklistItemFiles to delete.
     * @example
     * // Delete a few ChecklistItemFiles
     * const { count } = await prisma.checklistItemFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChecklistItemFileDeleteManyArgs>(args?: SelectSubset<T, ChecklistItemFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChecklistItemFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChecklistItemFiles
     * const checklistItemFile = await prisma.checklistItemFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChecklistItemFileUpdateManyArgs>(args: SelectSubset<T, ChecklistItemFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChecklistItemFiles and returns the data updated in the database.
     * @param {ChecklistItemFileUpdateManyAndReturnArgs} args - Arguments to update many ChecklistItemFiles.
     * @example
     * // Update many ChecklistItemFiles
     * const checklistItemFile = await prisma.checklistItemFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChecklistItemFiles and only return the `id`
     * const checklistItemFileWithIdOnly = await prisma.checklistItemFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChecklistItemFileUpdateManyAndReturnArgs>(args: SelectSubset<T, ChecklistItemFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChecklistItemFile.
     * @param {ChecklistItemFileUpsertArgs} args - Arguments to update or create a ChecklistItemFile.
     * @example
     * // Update or create a ChecklistItemFile
     * const checklistItemFile = await prisma.checklistItemFile.upsert({
     *   create: {
     *     // ... data to create a ChecklistItemFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChecklistItemFile we want to update
     *   }
     * })
     */
    upsert<T extends ChecklistItemFileUpsertArgs>(args: SelectSubset<T, ChecklistItemFileUpsertArgs<ExtArgs>>): Prisma__ChecklistItemFileClient<$Result.GetResult<Prisma.$ChecklistItemFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChecklistItemFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFileCountArgs} args - Arguments to filter ChecklistItemFiles to count.
     * @example
     * // Count the number of ChecklistItemFiles
     * const count = await prisma.checklistItemFile.count({
     *   where: {
     *     // ... the filter for the ChecklistItemFiles we want to count
     *   }
     * })
    **/
    count<T extends ChecklistItemFileCountArgs>(
      args?: Subset<T, ChecklistItemFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChecklistItemFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChecklistItemFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChecklistItemFileAggregateArgs>(args: Subset<T, ChecklistItemFileAggregateArgs>): Prisma.PrismaPromise<GetChecklistItemFileAggregateType<T>>

    /**
     * Group by ChecklistItemFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChecklistItemFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChecklistItemFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChecklistItemFileGroupByArgs['orderBy'] }
        : { orderBy?: ChecklistItemFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChecklistItemFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChecklistItemFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChecklistItemFile model
   */
  readonly fields: ChecklistItemFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChecklistItemFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChecklistItemFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checklistItem<T extends ChecklistItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChecklistItemDefaultArgs<ExtArgs>>): Prisma__ChecklistItemClient<$Result.GetResult<Prisma.$ChecklistItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    document<T extends DocumentDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentDefaultArgs<ExtArgs>>): Prisma__DocumentClient<$Result.GetResult<Prisma.$DocumentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChecklistItemFile model
   */
  interface ChecklistItemFileFieldRefs {
    readonly id: FieldRef<"ChecklistItemFile", 'String'>
    readonly checklistItemId: FieldRef<"ChecklistItemFile", 'String'>
    readonly documentId: FieldRef<"ChecklistItemFile", 'String'>
    readonly createdAt: FieldRef<"ChecklistItemFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChecklistItemFile findUnique
   */
  export type ChecklistItemFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItemFile to fetch.
     */
    where: ChecklistItemFileWhereUniqueInput
  }

  /**
   * ChecklistItemFile findUniqueOrThrow
   */
  export type ChecklistItemFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItemFile to fetch.
     */
    where: ChecklistItemFileWhereUniqueInput
  }

  /**
   * ChecklistItemFile findFirst
   */
  export type ChecklistItemFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItemFile to fetch.
     */
    where?: ChecklistItemFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItemFiles to fetch.
     */
    orderBy?: ChecklistItemFileOrderByWithRelationInput | ChecklistItemFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChecklistItemFiles.
     */
    cursor?: ChecklistItemFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItemFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItemFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChecklistItemFiles.
     */
    distinct?: ChecklistItemFileScalarFieldEnum | ChecklistItemFileScalarFieldEnum[]
  }

  /**
   * ChecklistItemFile findFirstOrThrow
   */
  export type ChecklistItemFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItemFile to fetch.
     */
    where?: ChecklistItemFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItemFiles to fetch.
     */
    orderBy?: ChecklistItemFileOrderByWithRelationInput | ChecklistItemFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChecklistItemFiles.
     */
    cursor?: ChecklistItemFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItemFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItemFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChecklistItemFiles.
     */
    distinct?: ChecklistItemFileScalarFieldEnum | ChecklistItemFileScalarFieldEnum[]
  }

  /**
   * ChecklistItemFile findMany
   */
  export type ChecklistItemFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * Filter, which ChecklistItemFiles to fetch.
     */
    where?: ChecklistItemFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChecklistItemFiles to fetch.
     */
    orderBy?: ChecklistItemFileOrderByWithRelationInput | ChecklistItemFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChecklistItemFiles.
     */
    cursor?: ChecklistItemFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChecklistItemFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChecklistItemFiles.
     */
    skip?: number
    distinct?: ChecklistItemFileScalarFieldEnum | ChecklistItemFileScalarFieldEnum[]
  }

  /**
   * ChecklistItemFile create
   */
  export type ChecklistItemFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * The data needed to create a ChecklistItemFile.
     */
    data: XOR<ChecklistItemFileCreateInput, ChecklistItemFileUncheckedCreateInput>
  }

  /**
   * ChecklistItemFile createMany
   */
  export type ChecklistItemFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChecklistItemFiles.
     */
    data: ChecklistItemFileCreateManyInput | ChecklistItemFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChecklistItemFile createManyAndReturn
   */
  export type ChecklistItemFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * The data used to create many ChecklistItemFiles.
     */
    data: ChecklistItemFileCreateManyInput | ChecklistItemFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChecklistItemFile update
   */
  export type ChecklistItemFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * The data needed to update a ChecklistItemFile.
     */
    data: XOR<ChecklistItemFileUpdateInput, ChecklistItemFileUncheckedUpdateInput>
    /**
     * Choose, which ChecklistItemFile to update.
     */
    where: ChecklistItemFileWhereUniqueInput
  }

  /**
   * ChecklistItemFile updateMany
   */
  export type ChecklistItemFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChecklistItemFiles.
     */
    data: XOR<ChecklistItemFileUpdateManyMutationInput, ChecklistItemFileUncheckedUpdateManyInput>
    /**
     * Filter which ChecklistItemFiles to update
     */
    where?: ChecklistItemFileWhereInput
    /**
     * Limit how many ChecklistItemFiles to update.
     */
    limit?: number
  }

  /**
   * ChecklistItemFile updateManyAndReturn
   */
  export type ChecklistItemFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * The data used to update ChecklistItemFiles.
     */
    data: XOR<ChecklistItemFileUpdateManyMutationInput, ChecklistItemFileUncheckedUpdateManyInput>
    /**
     * Filter which ChecklistItemFiles to update
     */
    where?: ChecklistItemFileWhereInput
    /**
     * Limit how many ChecklistItemFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChecklistItemFile upsert
   */
  export type ChecklistItemFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * The filter to search for the ChecklistItemFile to update in case it exists.
     */
    where: ChecklistItemFileWhereUniqueInput
    /**
     * In case the ChecklistItemFile found by the `where` argument doesn't exist, create a new ChecklistItemFile with this data.
     */
    create: XOR<ChecklistItemFileCreateInput, ChecklistItemFileUncheckedCreateInput>
    /**
     * In case the ChecklistItemFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChecklistItemFileUpdateInput, ChecklistItemFileUncheckedUpdateInput>
  }

  /**
   * ChecklistItemFile delete
   */
  export type ChecklistItemFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
    /**
     * Filter which ChecklistItemFile to delete.
     */
    where: ChecklistItemFileWhereUniqueInput
  }

  /**
   * ChecklistItemFile deleteMany
   */
  export type ChecklistItemFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChecklistItemFiles to delete
     */
    where?: ChecklistItemFileWhereInput
    /**
     * Limit how many ChecklistItemFiles to delete.
     */
    limit?: number
  }

  /**
   * ChecklistItemFile without action
   */
  export type ChecklistItemFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChecklistItemFile
     */
    select?: ChecklistItemFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChecklistItemFile
     */
    omit?: ChecklistItemFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChecklistItemFileInclude<ExtArgs> | null
  }


  /**
   * Model QuestionnaireSection
   */

  export type AggregateQuestionnaireSection = {
    _count: QuestionnaireSectionCountAggregateOutputType | null
    _avg: QuestionnaireSectionAvgAggregateOutputType | null
    _sum: QuestionnaireSectionSumAggregateOutputType | null
    _min: QuestionnaireSectionMinAggregateOutputType | null
    _max: QuestionnaireSectionMaxAggregateOutputType | null
  }

  export type QuestionnaireSectionAvgAggregateOutputType = {
    order: number | null
  }

  export type QuestionnaireSectionSumAggregateOutputType = {
    order: number | null
  }

  export type QuestionnaireSectionMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireSectionMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    order: number | null
    active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireSectionCountAggregateOutputType = {
    id: number
    name: number
    description: number
    order: number
    active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionnaireSectionAvgAggregateInputType = {
    order?: true
  }

  export type QuestionnaireSectionSumAggregateInputType = {
    order?: true
  }

  export type QuestionnaireSectionMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireSectionMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireSectionCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    order?: true
    active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionnaireSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireSection to aggregate.
     */
    where?: QuestionnaireSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireSections to fetch.
     */
    orderBy?: QuestionnaireSectionOrderByWithRelationInput | QuestionnaireSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionnaireSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionnaireSections
    **/
    _count?: true | QuestionnaireSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionnaireSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionnaireSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionnaireSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionnaireSectionMaxAggregateInputType
  }

  export type GetQuestionnaireSectionAggregateType<T extends QuestionnaireSectionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionnaireSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionnaireSection[P]>
      : GetScalarType<T[P], AggregateQuestionnaireSection[P]>
  }




  export type QuestionnaireSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireSectionWhereInput
    orderBy?: QuestionnaireSectionOrderByWithAggregationInput | QuestionnaireSectionOrderByWithAggregationInput[]
    by: QuestionnaireSectionScalarFieldEnum[] | QuestionnaireSectionScalarFieldEnum
    having?: QuestionnaireSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionnaireSectionCountAggregateInputType | true
    _avg?: QuestionnaireSectionAvgAggregateInputType
    _sum?: QuestionnaireSectionSumAggregateInputType
    _min?: QuestionnaireSectionMinAggregateInputType
    _max?: QuestionnaireSectionMaxAggregateInputType
  }

  export type QuestionnaireSectionGroupByOutputType = {
    id: string
    name: string
    description: string | null
    order: number
    active: boolean
    createdAt: Date
    updatedAt: Date
    _count: QuestionnaireSectionCountAggregateOutputType | null
    _avg: QuestionnaireSectionAvgAggregateOutputType | null
    _sum: QuestionnaireSectionSumAggregateOutputType | null
    _min: QuestionnaireSectionMinAggregateOutputType | null
    _max: QuestionnaireSectionMaxAggregateOutputType | null
  }

  type GetQuestionnaireSectionGroupByPayload<T extends QuestionnaireSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionnaireSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionnaireSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionnaireSectionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionnaireSectionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionnaireSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    questions?: boolean | QuestionnaireSection$questionsArgs<ExtArgs>
    _count?: boolean | QuestionnaireSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireSection"]>

  export type QuestionnaireSectionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["questionnaireSection"]>

  export type QuestionnaireSectionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["questionnaireSection"]>

  export type QuestionnaireSectionSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    order?: boolean
    active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionnaireSectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "order" | "active" | "createdAt" | "updatedAt", ExtArgs["result"]["questionnaireSection"]>
  export type QuestionnaireSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    questions?: boolean | QuestionnaireSection$questionsArgs<ExtArgs>
    _count?: boolean | QuestionnaireSectionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionnaireSectionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type QuestionnaireSectionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $QuestionnaireSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionnaireSection"
    objects: {
      questions: Prisma.$QuestionnaireQuestionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      order: number
      active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionnaireSection"]>
    composites: {}
  }

  type QuestionnaireSectionGetPayload<S extends boolean | null | undefined | QuestionnaireSectionDefaultArgs> = $Result.GetResult<Prisma.$QuestionnaireSectionPayload, S>

  type QuestionnaireSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionnaireSectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionnaireSectionCountAggregateInputType | true
    }

  export interface QuestionnaireSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionnaireSection'], meta: { name: 'QuestionnaireSection' } }
    /**
     * Find zero or one QuestionnaireSection that matches the filter.
     * @param {QuestionnaireSectionFindUniqueArgs} args - Arguments to find a QuestionnaireSection
     * @example
     * // Get one QuestionnaireSection
     * const questionnaireSection = await prisma.questionnaireSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionnaireSectionFindUniqueArgs>(args: SelectSubset<T, QuestionnaireSectionFindUniqueArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionnaireSection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionnaireSectionFindUniqueOrThrowArgs} args - Arguments to find a QuestionnaireSection
     * @example
     * // Get one QuestionnaireSection
     * const questionnaireSection = await prisma.questionnaireSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionnaireSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionnaireSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionnaireSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireSectionFindFirstArgs} args - Arguments to find a QuestionnaireSection
     * @example
     * // Get one QuestionnaireSection
     * const questionnaireSection = await prisma.questionnaireSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionnaireSectionFindFirstArgs>(args?: SelectSubset<T, QuestionnaireSectionFindFirstArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionnaireSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireSectionFindFirstOrThrowArgs} args - Arguments to find a QuestionnaireSection
     * @example
     * // Get one QuestionnaireSection
     * const questionnaireSection = await prisma.questionnaireSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionnaireSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionnaireSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionnaireSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionnaireSections
     * const questionnaireSections = await prisma.questionnaireSection.findMany()
     * 
     * // Get first 10 QuestionnaireSections
     * const questionnaireSections = await prisma.questionnaireSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionnaireSectionWithIdOnly = await prisma.questionnaireSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionnaireSectionFindManyArgs>(args?: SelectSubset<T, QuestionnaireSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionnaireSection.
     * @param {QuestionnaireSectionCreateArgs} args - Arguments to create a QuestionnaireSection.
     * @example
     * // Create one QuestionnaireSection
     * const QuestionnaireSection = await prisma.questionnaireSection.create({
     *   data: {
     *     // ... data to create a QuestionnaireSection
     *   }
     * })
     * 
     */
    create<T extends QuestionnaireSectionCreateArgs>(args: SelectSubset<T, QuestionnaireSectionCreateArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionnaireSections.
     * @param {QuestionnaireSectionCreateManyArgs} args - Arguments to create many QuestionnaireSections.
     * @example
     * // Create many QuestionnaireSections
     * const questionnaireSection = await prisma.questionnaireSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionnaireSectionCreateManyArgs>(args?: SelectSubset<T, QuestionnaireSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionnaireSections and returns the data saved in the database.
     * @param {QuestionnaireSectionCreateManyAndReturnArgs} args - Arguments to create many QuestionnaireSections.
     * @example
     * // Create many QuestionnaireSections
     * const questionnaireSection = await prisma.questionnaireSection.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionnaireSections and only return the `id`
     * const questionnaireSectionWithIdOnly = await prisma.questionnaireSection.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionnaireSectionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionnaireSectionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionnaireSection.
     * @param {QuestionnaireSectionDeleteArgs} args - Arguments to delete one QuestionnaireSection.
     * @example
     * // Delete one QuestionnaireSection
     * const QuestionnaireSection = await prisma.questionnaireSection.delete({
     *   where: {
     *     // ... filter to delete one QuestionnaireSection
     *   }
     * })
     * 
     */
    delete<T extends QuestionnaireSectionDeleteArgs>(args: SelectSubset<T, QuestionnaireSectionDeleteArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionnaireSection.
     * @param {QuestionnaireSectionUpdateArgs} args - Arguments to update one QuestionnaireSection.
     * @example
     * // Update one QuestionnaireSection
     * const questionnaireSection = await prisma.questionnaireSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionnaireSectionUpdateArgs>(args: SelectSubset<T, QuestionnaireSectionUpdateArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionnaireSections.
     * @param {QuestionnaireSectionDeleteManyArgs} args - Arguments to filter QuestionnaireSections to delete.
     * @example
     * // Delete a few QuestionnaireSections
     * const { count } = await prisma.questionnaireSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionnaireSectionDeleteManyArgs>(args?: SelectSubset<T, QuestionnaireSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionnaireSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionnaireSections
     * const questionnaireSection = await prisma.questionnaireSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionnaireSectionUpdateManyArgs>(args: SelectSubset<T, QuestionnaireSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionnaireSections and returns the data updated in the database.
     * @param {QuestionnaireSectionUpdateManyAndReturnArgs} args - Arguments to update many QuestionnaireSections.
     * @example
     * // Update many QuestionnaireSections
     * const questionnaireSection = await prisma.questionnaireSection.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionnaireSections and only return the `id`
     * const questionnaireSectionWithIdOnly = await prisma.questionnaireSection.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionnaireSectionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionnaireSectionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionnaireSection.
     * @param {QuestionnaireSectionUpsertArgs} args - Arguments to update or create a QuestionnaireSection.
     * @example
     * // Update or create a QuestionnaireSection
     * const questionnaireSection = await prisma.questionnaireSection.upsert({
     *   create: {
     *     // ... data to create a QuestionnaireSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionnaireSection we want to update
     *   }
     * })
     */
    upsert<T extends QuestionnaireSectionUpsertArgs>(args: SelectSubset<T, QuestionnaireSectionUpsertArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionnaireSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireSectionCountArgs} args - Arguments to filter QuestionnaireSections to count.
     * @example
     * // Count the number of QuestionnaireSections
     * const count = await prisma.questionnaireSection.count({
     *   where: {
     *     // ... the filter for the QuestionnaireSections we want to count
     *   }
     * })
    **/
    count<T extends QuestionnaireSectionCountArgs>(
      args?: Subset<T, QuestionnaireSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionnaireSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionnaireSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionnaireSectionAggregateArgs>(args: Subset<T, QuestionnaireSectionAggregateArgs>): Prisma.PrismaPromise<GetQuestionnaireSectionAggregateType<T>>

    /**
     * Group by QuestionnaireSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionnaireSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionnaireSectionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionnaireSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionnaireSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionnaireSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionnaireSection model
   */
  readonly fields: QuestionnaireSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionnaireSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionnaireSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    questions<T extends QuestionnaireSection$questionsArgs<ExtArgs> = {}>(args?: Subset<T, QuestionnaireSection$questionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionnaireSection model
   */
  interface QuestionnaireSectionFieldRefs {
    readonly id: FieldRef<"QuestionnaireSection", 'String'>
    readonly name: FieldRef<"QuestionnaireSection", 'String'>
    readonly description: FieldRef<"QuestionnaireSection", 'String'>
    readonly order: FieldRef<"QuestionnaireSection", 'Int'>
    readonly active: FieldRef<"QuestionnaireSection", 'Boolean'>
    readonly createdAt: FieldRef<"QuestionnaireSection", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionnaireSection", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionnaireSection findUnique
   */
  export type QuestionnaireSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireSection to fetch.
     */
    where: QuestionnaireSectionWhereUniqueInput
  }

  /**
   * QuestionnaireSection findUniqueOrThrow
   */
  export type QuestionnaireSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireSection to fetch.
     */
    where: QuestionnaireSectionWhereUniqueInput
  }

  /**
   * QuestionnaireSection findFirst
   */
  export type QuestionnaireSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireSection to fetch.
     */
    where?: QuestionnaireSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireSections to fetch.
     */
    orderBy?: QuestionnaireSectionOrderByWithRelationInput | QuestionnaireSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireSections.
     */
    cursor?: QuestionnaireSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireSections.
     */
    distinct?: QuestionnaireSectionScalarFieldEnum | QuestionnaireSectionScalarFieldEnum[]
  }

  /**
   * QuestionnaireSection findFirstOrThrow
   */
  export type QuestionnaireSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireSection to fetch.
     */
    where?: QuestionnaireSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireSections to fetch.
     */
    orderBy?: QuestionnaireSectionOrderByWithRelationInput | QuestionnaireSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireSections.
     */
    cursor?: QuestionnaireSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireSections.
     */
    distinct?: QuestionnaireSectionScalarFieldEnum | QuestionnaireSectionScalarFieldEnum[]
  }

  /**
   * QuestionnaireSection findMany
   */
  export type QuestionnaireSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireSections to fetch.
     */
    where?: QuestionnaireSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireSections to fetch.
     */
    orderBy?: QuestionnaireSectionOrderByWithRelationInput | QuestionnaireSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionnaireSections.
     */
    cursor?: QuestionnaireSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireSections.
     */
    skip?: number
    distinct?: QuestionnaireSectionScalarFieldEnum | QuestionnaireSectionScalarFieldEnum[]
  }

  /**
   * QuestionnaireSection create
   */
  export type QuestionnaireSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionnaireSection.
     */
    data: XOR<QuestionnaireSectionCreateInput, QuestionnaireSectionUncheckedCreateInput>
  }

  /**
   * QuestionnaireSection createMany
   */
  export type QuestionnaireSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionnaireSections.
     */
    data: QuestionnaireSectionCreateManyInput | QuestionnaireSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionnaireSection createManyAndReturn
   */
  export type QuestionnaireSectionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionnaireSections.
     */
    data: QuestionnaireSectionCreateManyInput | QuestionnaireSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionnaireSection update
   */
  export type QuestionnaireSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionnaireSection.
     */
    data: XOR<QuestionnaireSectionUpdateInput, QuestionnaireSectionUncheckedUpdateInput>
    /**
     * Choose, which QuestionnaireSection to update.
     */
    where: QuestionnaireSectionWhereUniqueInput
  }

  /**
   * QuestionnaireSection updateMany
   */
  export type QuestionnaireSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionnaireSections.
     */
    data: XOR<QuestionnaireSectionUpdateManyMutationInput, QuestionnaireSectionUncheckedUpdateManyInput>
    /**
     * Filter which QuestionnaireSections to update
     */
    where?: QuestionnaireSectionWhereInput
    /**
     * Limit how many QuestionnaireSections to update.
     */
    limit?: number
  }

  /**
   * QuestionnaireSection updateManyAndReturn
   */
  export type QuestionnaireSectionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * The data used to update QuestionnaireSections.
     */
    data: XOR<QuestionnaireSectionUpdateManyMutationInput, QuestionnaireSectionUncheckedUpdateManyInput>
    /**
     * Filter which QuestionnaireSections to update
     */
    where?: QuestionnaireSectionWhereInput
    /**
     * Limit how many QuestionnaireSections to update.
     */
    limit?: number
  }

  /**
   * QuestionnaireSection upsert
   */
  export type QuestionnaireSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionnaireSection to update in case it exists.
     */
    where: QuestionnaireSectionWhereUniqueInput
    /**
     * In case the QuestionnaireSection found by the `where` argument doesn't exist, create a new QuestionnaireSection with this data.
     */
    create: XOR<QuestionnaireSectionCreateInput, QuestionnaireSectionUncheckedCreateInput>
    /**
     * In case the QuestionnaireSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionnaireSectionUpdateInput, QuestionnaireSectionUncheckedUpdateInput>
  }

  /**
   * QuestionnaireSection delete
   */
  export type QuestionnaireSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
    /**
     * Filter which QuestionnaireSection to delete.
     */
    where: QuestionnaireSectionWhereUniqueInput
  }

  /**
   * QuestionnaireSection deleteMany
   */
  export type QuestionnaireSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireSections to delete
     */
    where?: QuestionnaireSectionWhereInput
    /**
     * Limit how many QuestionnaireSections to delete.
     */
    limit?: number
  }

  /**
   * QuestionnaireSection.questions
   */
  export type QuestionnaireSection$questionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    where?: QuestionnaireQuestionWhereInput
    orderBy?: QuestionnaireQuestionOrderByWithRelationInput | QuestionnaireQuestionOrderByWithRelationInput[]
    cursor?: QuestionnaireQuestionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionnaireQuestionScalarFieldEnum | QuestionnaireQuestionScalarFieldEnum[]
  }

  /**
   * QuestionnaireSection without action
   */
  export type QuestionnaireSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireSection
     */
    select?: QuestionnaireSectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireSection
     */
    omit?: QuestionnaireSectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireSectionInclude<ExtArgs> | null
  }


  /**
   * Model QuestionnaireQuestion
   */

  export type AggregateQuestionnaireQuestion = {
    _count: QuestionnaireQuestionCountAggregateOutputType | null
    _avg: QuestionnaireQuestionAvgAggregateOutputType | null
    _sum: QuestionnaireQuestionSumAggregateOutputType | null
    _min: QuestionnaireQuestionMinAggregateOutputType | null
    _max: QuestionnaireQuestionMaxAggregateOutputType | null
  }

  export type QuestionnaireQuestionAvgAggregateOutputType = {
    order: number | null
  }

  export type QuestionnaireQuestionSumAggregateOutputType = {
    order: number | null
  }

  export type QuestionnaireQuestionMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    questionText: string | null
    questionType: $Enums.QuestionType | null
    required: boolean | null
    order: number | null
    conditionalLogic: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireQuestionMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    questionText: string | null
    questionType: $Enums.QuestionType | null
    required: boolean | null
    order: number | null
    conditionalLogic: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireQuestionCountAggregateOutputType = {
    id: number
    sectionId: number
    questionText: number
    questionType: number
    required: number
    order: number
    conditionalLogic: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionnaireQuestionAvgAggregateInputType = {
    order?: true
  }

  export type QuestionnaireQuestionSumAggregateInputType = {
    order?: true
  }

  export type QuestionnaireQuestionMinAggregateInputType = {
    id?: true
    sectionId?: true
    questionText?: true
    questionType?: true
    required?: true
    order?: true
    conditionalLogic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireQuestionMaxAggregateInputType = {
    id?: true
    sectionId?: true
    questionText?: true
    questionType?: true
    required?: true
    order?: true
    conditionalLogic?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireQuestionCountAggregateInputType = {
    id?: true
    sectionId?: true
    questionText?: true
    questionType?: true
    required?: true
    order?: true
    conditionalLogic?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionnaireQuestionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireQuestion to aggregate.
     */
    where?: QuestionnaireQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireQuestions to fetch.
     */
    orderBy?: QuestionnaireQuestionOrderByWithRelationInput | QuestionnaireQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionnaireQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionnaireQuestions
    **/
    _count?: true | QuestionnaireQuestionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: QuestionnaireQuestionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: QuestionnaireQuestionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionnaireQuestionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionnaireQuestionMaxAggregateInputType
  }

  export type GetQuestionnaireQuestionAggregateType<T extends QuestionnaireQuestionAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionnaireQuestion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionnaireQuestion[P]>
      : GetScalarType<T[P], AggregateQuestionnaireQuestion[P]>
  }




  export type QuestionnaireQuestionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireQuestionWhereInput
    orderBy?: QuestionnaireQuestionOrderByWithAggregationInput | QuestionnaireQuestionOrderByWithAggregationInput[]
    by: QuestionnaireQuestionScalarFieldEnum[] | QuestionnaireQuestionScalarFieldEnum
    having?: QuestionnaireQuestionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionnaireQuestionCountAggregateInputType | true
    _avg?: QuestionnaireQuestionAvgAggregateInputType
    _sum?: QuestionnaireQuestionSumAggregateInputType
    _min?: QuestionnaireQuestionMinAggregateInputType
    _max?: QuestionnaireQuestionMaxAggregateInputType
  }

  export type QuestionnaireQuestionGroupByOutputType = {
    id: string
    sectionId: string
    questionText: string
    questionType: $Enums.QuestionType
    required: boolean
    order: number
    conditionalLogic: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuestionnaireQuestionCountAggregateOutputType | null
    _avg: QuestionnaireQuestionAvgAggregateOutputType | null
    _sum: QuestionnaireQuestionSumAggregateOutputType | null
    _min: QuestionnaireQuestionMinAggregateOutputType | null
    _max: QuestionnaireQuestionMaxAggregateOutputType | null
  }

  type GetQuestionnaireQuestionGroupByPayload<T extends QuestionnaireQuestionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionnaireQuestionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionnaireQuestionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionnaireQuestionGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionnaireQuestionGroupByOutputType[P]>
        }
      >
    >


  export type QuestionnaireQuestionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    questionText?: boolean
    questionType?: boolean
    required?: boolean
    order?: boolean
    conditionalLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | QuestionnaireSectionDefaultArgs<ExtArgs>
    answers?: boolean | QuestionnaireQuestion$answersArgs<ExtArgs>
    _count?: boolean | QuestionnaireQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireQuestion"]>

  export type QuestionnaireQuestionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    questionText?: boolean
    questionType?: boolean
    required?: boolean
    order?: boolean
    conditionalLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | QuestionnaireSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireQuestion"]>

  export type QuestionnaireQuestionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    questionText?: boolean
    questionType?: boolean
    required?: boolean
    order?: boolean
    conditionalLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    section?: boolean | QuestionnaireSectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireQuestion"]>

  export type QuestionnaireQuestionSelectScalar = {
    id?: boolean
    sectionId?: boolean
    questionText?: boolean
    questionType?: boolean
    required?: boolean
    order?: boolean
    conditionalLogic?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionnaireQuestionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sectionId" | "questionText" | "questionType" | "required" | "order" | "conditionalLogic" | "createdAt" | "updatedAt", ExtArgs["result"]["questionnaireQuestion"]>
  export type QuestionnaireQuestionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | QuestionnaireSectionDefaultArgs<ExtArgs>
    answers?: boolean | QuestionnaireQuestion$answersArgs<ExtArgs>
    _count?: boolean | QuestionnaireQuestionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type QuestionnaireQuestionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | QuestionnaireSectionDefaultArgs<ExtArgs>
  }
  export type QuestionnaireQuestionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | QuestionnaireSectionDefaultArgs<ExtArgs>
  }

  export type $QuestionnaireQuestionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionnaireQuestion"
    objects: {
      section: Prisma.$QuestionnaireSectionPayload<ExtArgs>
      answers: Prisma.$QuestionnaireAnswerPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      questionText: string
      questionType: $Enums.QuestionType
      required: boolean
      order: number
      conditionalLogic: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionnaireQuestion"]>
    composites: {}
  }

  type QuestionnaireQuestionGetPayload<S extends boolean | null | undefined | QuestionnaireQuestionDefaultArgs> = $Result.GetResult<Prisma.$QuestionnaireQuestionPayload, S>

  type QuestionnaireQuestionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionnaireQuestionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionnaireQuestionCountAggregateInputType | true
    }

  export interface QuestionnaireQuestionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionnaireQuestion'], meta: { name: 'QuestionnaireQuestion' } }
    /**
     * Find zero or one QuestionnaireQuestion that matches the filter.
     * @param {QuestionnaireQuestionFindUniqueArgs} args - Arguments to find a QuestionnaireQuestion
     * @example
     * // Get one QuestionnaireQuestion
     * const questionnaireQuestion = await prisma.questionnaireQuestion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionnaireQuestionFindUniqueArgs>(args: SelectSubset<T, QuestionnaireQuestionFindUniqueArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionnaireQuestion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionnaireQuestionFindUniqueOrThrowArgs} args - Arguments to find a QuestionnaireQuestion
     * @example
     * // Get one QuestionnaireQuestion
     * const questionnaireQuestion = await prisma.questionnaireQuestion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionnaireQuestionFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionnaireQuestionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionnaireQuestion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireQuestionFindFirstArgs} args - Arguments to find a QuestionnaireQuestion
     * @example
     * // Get one QuestionnaireQuestion
     * const questionnaireQuestion = await prisma.questionnaireQuestion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionnaireQuestionFindFirstArgs>(args?: SelectSubset<T, QuestionnaireQuestionFindFirstArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionnaireQuestion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireQuestionFindFirstOrThrowArgs} args - Arguments to find a QuestionnaireQuestion
     * @example
     * // Get one QuestionnaireQuestion
     * const questionnaireQuestion = await prisma.questionnaireQuestion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionnaireQuestionFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionnaireQuestionFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionnaireQuestions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireQuestionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionnaireQuestions
     * const questionnaireQuestions = await prisma.questionnaireQuestion.findMany()
     * 
     * // Get first 10 QuestionnaireQuestions
     * const questionnaireQuestions = await prisma.questionnaireQuestion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionnaireQuestionWithIdOnly = await prisma.questionnaireQuestion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionnaireQuestionFindManyArgs>(args?: SelectSubset<T, QuestionnaireQuestionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionnaireQuestion.
     * @param {QuestionnaireQuestionCreateArgs} args - Arguments to create a QuestionnaireQuestion.
     * @example
     * // Create one QuestionnaireQuestion
     * const QuestionnaireQuestion = await prisma.questionnaireQuestion.create({
     *   data: {
     *     // ... data to create a QuestionnaireQuestion
     *   }
     * })
     * 
     */
    create<T extends QuestionnaireQuestionCreateArgs>(args: SelectSubset<T, QuestionnaireQuestionCreateArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionnaireQuestions.
     * @param {QuestionnaireQuestionCreateManyArgs} args - Arguments to create many QuestionnaireQuestions.
     * @example
     * // Create many QuestionnaireQuestions
     * const questionnaireQuestion = await prisma.questionnaireQuestion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionnaireQuestionCreateManyArgs>(args?: SelectSubset<T, QuestionnaireQuestionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionnaireQuestions and returns the data saved in the database.
     * @param {QuestionnaireQuestionCreateManyAndReturnArgs} args - Arguments to create many QuestionnaireQuestions.
     * @example
     * // Create many QuestionnaireQuestions
     * const questionnaireQuestion = await prisma.questionnaireQuestion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionnaireQuestions and only return the `id`
     * const questionnaireQuestionWithIdOnly = await prisma.questionnaireQuestion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionnaireQuestionCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionnaireQuestionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionnaireQuestion.
     * @param {QuestionnaireQuestionDeleteArgs} args - Arguments to delete one QuestionnaireQuestion.
     * @example
     * // Delete one QuestionnaireQuestion
     * const QuestionnaireQuestion = await prisma.questionnaireQuestion.delete({
     *   where: {
     *     // ... filter to delete one QuestionnaireQuestion
     *   }
     * })
     * 
     */
    delete<T extends QuestionnaireQuestionDeleteArgs>(args: SelectSubset<T, QuestionnaireQuestionDeleteArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionnaireQuestion.
     * @param {QuestionnaireQuestionUpdateArgs} args - Arguments to update one QuestionnaireQuestion.
     * @example
     * // Update one QuestionnaireQuestion
     * const questionnaireQuestion = await prisma.questionnaireQuestion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionnaireQuestionUpdateArgs>(args: SelectSubset<T, QuestionnaireQuestionUpdateArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionnaireQuestions.
     * @param {QuestionnaireQuestionDeleteManyArgs} args - Arguments to filter QuestionnaireQuestions to delete.
     * @example
     * // Delete a few QuestionnaireQuestions
     * const { count } = await prisma.questionnaireQuestion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionnaireQuestionDeleteManyArgs>(args?: SelectSubset<T, QuestionnaireQuestionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionnaireQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireQuestionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionnaireQuestions
     * const questionnaireQuestion = await prisma.questionnaireQuestion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionnaireQuestionUpdateManyArgs>(args: SelectSubset<T, QuestionnaireQuestionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionnaireQuestions and returns the data updated in the database.
     * @param {QuestionnaireQuestionUpdateManyAndReturnArgs} args - Arguments to update many QuestionnaireQuestions.
     * @example
     * // Update many QuestionnaireQuestions
     * const questionnaireQuestion = await prisma.questionnaireQuestion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionnaireQuestions and only return the `id`
     * const questionnaireQuestionWithIdOnly = await prisma.questionnaireQuestion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionnaireQuestionUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionnaireQuestionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionnaireQuestion.
     * @param {QuestionnaireQuestionUpsertArgs} args - Arguments to update or create a QuestionnaireQuestion.
     * @example
     * // Update or create a QuestionnaireQuestion
     * const questionnaireQuestion = await prisma.questionnaireQuestion.upsert({
     *   create: {
     *     // ... data to create a QuestionnaireQuestion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionnaireQuestion we want to update
     *   }
     * })
     */
    upsert<T extends QuestionnaireQuestionUpsertArgs>(args: SelectSubset<T, QuestionnaireQuestionUpsertArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionnaireQuestions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireQuestionCountArgs} args - Arguments to filter QuestionnaireQuestions to count.
     * @example
     * // Count the number of QuestionnaireQuestions
     * const count = await prisma.questionnaireQuestion.count({
     *   where: {
     *     // ... the filter for the QuestionnaireQuestions we want to count
     *   }
     * })
    **/
    count<T extends QuestionnaireQuestionCountArgs>(
      args?: Subset<T, QuestionnaireQuestionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionnaireQuestionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionnaireQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireQuestionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionnaireQuestionAggregateArgs>(args: Subset<T, QuestionnaireQuestionAggregateArgs>): Prisma.PrismaPromise<GetQuestionnaireQuestionAggregateType<T>>

    /**
     * Group by QuestionnaireQuestion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireQuestionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionnaireQuestionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionnaireQuestionGroupByArgs['orderBy'] }
        : { orderBy?: QuestionnaireQuestionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionnaireQuestionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionnaireQuestionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionnaireQuestion model
   */
  readonly fields: QuestionnaireQuestionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionnaireQuestion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionnaireQuestionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends QuestionnaireSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionnaireSectionDefaultArgs<ExtArgs>>): Prisma__QuestionnaireSectionClient<$Result.GetResult<Prisma.$QuestionnaireSectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    answers<T extends QuestionnaireQuestion$answersArgs<ExtArgs> = {}>(args?: Subset<T, QuestionnaireQuestion$answersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionnaireQuestion model
   */
  interface QuestionnaireQuestionFieldRefs {
    readonly id: FieldRef<"QuestionnaireQuestion", 'String'>
    readonly sectionId: FieldRef<"QuestionnaireQuestion", 'String'>
    readonly questionText: FieldRef<"QuestionnaireQuestion", 'String'>
    readonly questionType: FieldRef<"QuestionnaireQuestion", 'QuestionType'>
    readonly required: FieldRef<"QuestionnaireQuestion", 'Boolean'>
    readonly order: FieldRef<"QuestionnaireQuestion", 'Int'>
    readonly conditionalLogic: FieldRef<"QuestionnaireQuestion", 'String'>
    readonly createdAt: FieldRef<"QuestionnaireQuestion", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionnaireQuestion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionnaireQuestion findUnique
   */
  export type QuestionnaireQuestionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireQuestion to fetch.
     */
    where: QuestionnaireQuestionWhereUniqueInput
  }

  /**
   * QuestionnaireQuestion findUniqueOrThrow
   */
  export type QuestionnaireQuestionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireQuestion to fetch.
     */
    where: QuestionnaireQuestionWhereUniqueInput
  }

  /**
   * QuestionnaireQuestion findFirst
   */
  export type QuestionnaireQuestionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireQuestion to fetch.
     */
    where?: QuestionnaireQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireQuestions to fetch.
     */
    orderBy?: QuestionnaireQuestionOrderByWithRelationInput | QuestionnaireQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireQuestions.
     */
    cursor?: QuestionnaireQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireQuestions.
     */
    distinct?: QuestionnaireQuestionScalarFieldEnum | QuestionnaireQuestionScalarFieldEnum[]
  }

  /**
   * QuestionnaireQuestion findFirstOrThrow
   */
  export type QuestionnaireQuestionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireQuestion to fetch.
     */
    where?: QuestionnaireQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireQuestions to fetch.
     */
    orderBy?: QuestionnaireQuestionOrderByWithRelationInput | QuestionnaireQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireQuestions.
     */
    cursor?: QuestionnaireQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireQuestions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireQuestions.
     */
    distinct?: QuestionnaireQuestionScalarFieldEnum | QuestionnaireQuestionScalarFieldEnum[]
  }

  /**
   * QuestionnaireQuestion findMany
   */
  export type QuestionnaireQuestionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireQuestions to fetch.
     */
    where?: QuestionnaireQuestionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireQuestions to fetch.
     */
    orderBy?: QuestionnaireQuestionOrderByWithRelationInput | QuestionnaireQuestionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionnaireQuestions.
     */
    cursor?: QuestionnaireQuestionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireQuestions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireQuestions.
     */
    skip?: number
    distinct?: QuestionnaireQuestionScalarFieldEnum | QuestionnaireQuestionScalarFieldEnum[]
  }

  /**
   * QuestionnaireQuestion create
   */
  export type QuestionnaireQuestionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionnaireQuestion.
     */
    data: XOR<QuestionnaireQuestionCreateInput, QuestionnaireQuestionUncheckedCreateInput>
  }

  /**
   * QuestionnaireQuestion createMany
   */
  export type QuestionnaireQuestionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionnaireQuestions.
     */
    data: QuestionnaireQuestionCreateManyInput | QuestionnaireQuestionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionnaireQuestion createManyAndReturn
   */
  export type QuestionnaireQuestionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionnaireQuestions.
     */
    data: QuestionnaireQuestionCreateManyInput | QuestionnaireQuestionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionnaireQuestion update
   */
  export type QuestionnaireQuestionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionnaireQuestion.
     */
    data: XOR<QuestionnaireQuestionUpdateInput, QuestionnaireQuestionUncheckedUpdateInput>
    /**
     * Choose, which QuestionnaireQuestion to update.
     */
    where: QuestionnaireQuestionWhereUniqueInput
  }

  /**
   * QuestionnaireQuestion updateMany
   */
  export type QuestionnaireQuestionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionnaireQuestions.
     */
    data: XOR<QuestionnaireQuestionUpdateManyMutationInput, QuestionnaireQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuestionnaireQuestions to update
     */
    where?: QuestionnaireQuestionWhereInput
    /**
     * Limit how many QuestionnaireQuestions to update.
     */
    limit?: number
  }

  /**
   * QuestionnaireQuestion updateManyAndReturn
   */
  export type QuestionnaireQuestionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * The data used to update QuestionnaireQuestions.
     */
    data: XOR<QuestionnaireQuestionUpdateManyMutationInput, QuestionnaireQuestionUncheckedUpdateManyInput>
    /**
     * Filter which QuestionnaireQuestions to update
     */
    where?: QuestionnaireQuestionWhereInput
    /**
     * Limit how many QuestionnaireQuestions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionnaireQuestion upsert
   */
  export type QuestionnaireQuestionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionnaireQuestion to update in case it exists.
     */
    where: QuestionnaireQuestionWhereUniqueInput
    /**
     * In case the QuestionnaireQuestion found by the `where` argument doesn't exist, create a new QuestionnaireQuestion with this data.
     */
    create: XOR<QuestionnaireQuestionCreateInput, QuestionnaireQuestionUncheckedCreateInput>
    /**
     * In case the QuestionnaireQuestion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionnaireQuestionUpdateInput, QuestionnaireQuestionUncheckedUpdateInput>
  }

  /**
   * QuestionnaireQuestion delete
   */
  export type QuestionnaireQuestionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
    /**
     * Filter which QuestionnaireQuestion to delete.
     */
    where: QuestionnaireQuestionWhereUniqueInput
  }

  /**
   * QuestionnaireQuestion deleteMany
   */
  export type QuestionnaireQuestionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireQuestions to delete
     */
    where?: QuestionnaireQuestionWhereInput
    /**
     * Limit how many QuestionnaireQuestions to delete.
     */
    limit?: number
  }

  /**
   * QuestionnaireQuestion.answers
   */
  export type QuestionnaireQuestion$answersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    where?: QuestionnaireAnswerWhereInput
    orderBy?: QuestionnaireAnswerOrderByWithRelationInput | QuestionnaireAnswerOrderByWithRelationInput[]
    cursor?: QuestionnaireAnswerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: QuestionnaireAnswerScalarFieldEnum | QuestionnaireAnswerScalarFieldEnum[]
  }

  /**
   * QuestionnaireQuestion without action
   */
  export type QuestionnaireQuestionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireQuestion
     */
    select?: QuestionnaireQuestionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireQuestion
     */
    omit?: QuestionnaireQuestionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireQuestionInclude<ExtArgs> | null
  }


  /**
   * Model QuestionnaireAnswer
   */

  export type AggregateQuestionnaireAnswer = {
    _count: QuestionnaireAnswerCountAggregateOutputType | null
    _min: QuestionnaireAnswerMinAggregateOutputType | null
    _max: QuestionnaireAnswerMaxAggregateOutputType | null
  }

  export type QuestionnaireAnswerMinAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    questionId: string | null
    answerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireAnswerMaxAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    questionId: string | null
    answerValue: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type QuestionnaireAnswerCountAggregateOutputType = {
    id: number
    entityTaxYearId: number
    questionId: number
    answerValue: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type QuestionnaireAnswerMinAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    questionId?: true
    answerValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireAnswerMaxAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    questionId?: true
    answerValue?: true
    createdAt?: true
    updatedAt?: true
  }

  export type QuestionnaireAnswerCountAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    questionId?: true
    answerValue?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type QuestionnaireAnswerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireAnswer to aggregate.
     */
    where?: QuestionnaireAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireAnswers to fetch.
     */
    orderBy?: QuestionnaireAnswerOrderByWithRelationInput | QuestionnaireAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: QuestionnaireAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned QuestionnaireAnswers
    **/
    _count?: true | QuestionnaireAnswerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: QuestionnaireAnswerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: QuestionnaireAnswerMaxAggregateInputType
  }

  export type GetQuestionnaireAnswerAggregateType<T extends QuestionnaireAnswerAggregateArgs> = {
        [P in keyof T & keyof AggregateQuestionnaireAnswer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateQuestionnaireAnswer[P]>
      : GetScalarType<T[P], AggregateQuestionnaireAnswer[P]>
  }




  export type QuestionnaireAnswerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: QuestionnaireAnswerWhereInput
    orderBy?: QuestionnaireAnswerOrderByWithAggregationInput | QuestionnaireAnswerOrderByWithAggregationInput[]
    by: QuestionnaireAnswerScalarFieldEnum[] | QuestionnaireAnswerScalarFieldEnum
    having?: QuestionnaireAnswerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: QuestionnaireAnswerCountAggregateInputType | true
    _min?: QuestionnaireAnswerMinAggregateInputType
    _max?: QuestionnaireAnswerMaxAggregateInputType
  }

  export type QuestionnaireAnswerGroupByOutputType = {
    id: string
    entityTaxYearId: string
    questionId: string
    answerValue: string | null
    createdAt: Date
    updatedAt: Date
    _count: QuestionnaireAnswerCountAggregateOutputType | null
    _min: QuestionnaireAnswerMinAggregateOutputType | null
    _max: QuestionnaireAnswerMaxAggregateOutputType | null
  }

  type GetQuestionnaireAnswerGroupByPayload<T extends QuestionnaireAnswerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<QuestionnaireAnswerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof QuestionnaireAnswerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], QuestionnaireAnswerGroupByOutputType[P]>
            : GetScalarType<T[P], QuestionnaireAnswerGroupByOutputType[P]>
        }
      >
    >


  export type QuestionnaireAnswerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    questionId?: boolean
    answerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    question?: boolean | QuestionnaireQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireAnswer"]>

  export type QuestionnaireAnswerSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    questionId?: boolean
    answerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    question?: boolean | QuestionnaireQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireAnswer"]>

  export type QuestionnaireAnswerSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    questionId?: boolean
    answerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    question?: boolean | QuestionnaireQuestionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["questionnaireAnswer"]>

  export type QuestionnaireAnswerSelectScalar = {
    id?: boolean
    entityTaxYearId?: boolean
    questionId?: boolean
    answerValue?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type QuestionnaireAnswerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityTaxYearId" | "questionId" | "answerValue" | "createdAt" | "updatedAt", ExtArgs["result"]["questionnaireAnswer"]>
  export type QuestionnaireAnswerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    question?: boolean | QuestionnaireQuestionDefaultArgs<ExtArgs>
  }
  export type QuestionnaireAnswerIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    question?: boolean | QuestionnaireQuestionDefaultArgs<ExtArgs>
  }
  export type QuestionnaireAnswerIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    question?: boolean | QuestionnaireQuestionDefaultArgs<ExtArgs>
  }

  export type $QuestionnaireAnswerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "QuestionnaireAnswer"
    objects: {
      entityTaxYear: Prisma.$EntityTaxYearPayload<ExtArgs>
      question: Prisma.$QuestionnaireQuestionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityTaxYearId: string
      questionId: string
      answerValue: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["questionnaireAnswer"]>
    composites: {}
  }

  type QuestionnaireAnswerGetPayload<S extends boolean | null | undefined | QuestionnaireAnswerDefaultArgs> = $Result.GetResult<Prisma.$QuestionnaireAnswerPayload, S>

  type QuestionnaireAnswerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<QuestionnaireAnswerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: QuestionnaireAnswerCountAggregateInputType | true
    }

  export interface QuestionnaireAnswerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['QuestionnaireAnswer'], meta: { name: 'QuestionnaireAnswer' } }
    /**
     * Find zero or one QuestionnaireAnswer that matches the filter.
     * @param {QuestionnaireAnswerFindUniqueArgs} args - Arguments to find a QuestionnaireAnswer
     * @example
     * // Get one QuestionnaireAnswer
     * const questionnaireAnswer = await prisma.questionnaireAnswer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends QuestionnaireAnswerFindUniqueArgs>(args: SelectSubset<T, QuestionnaireAnswerFindUniqueArgs<ExtArgs>>): Prisma__QuestionnaireAnswerClient<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one QuestionnaireAnswer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {QuestionnaireAnswerFindUniqueOrThrowArgs} args - Arguments to find a QuestionnaireAnswer
     * @example
     * // Get one QuestionnaireAnswer
     * const questionnaireAnswer = await prisma.questionnaireAnswer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends QuestionnaireAnswerFindUniqueOrThrowArgs>(args: SelectSubset<T, QuestionnaireAnswerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireAnswerClient<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionnaireAnswer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireAnswerFindFirstArgs} args - Arguments to find a QuestionnaireAnswer
     * @example
     * // Get one QuestionnaireAnswer
     * const questionnaireAnswer = await prisma.questionnaireAnswer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends QuestionnaireAnswerFindFirstArgs>(args?: SelectSubset<T, QuestionnaireAnswerFindFirstArgs<ExtArgs>>): Prisma__QuestionnaireAnswerClient<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first QuestionnaireAnswer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireAnswerFindFirstOrThrowArgs} args - Arguments to find a QuestionnaireAnswer
     * @example
     * // Get one QuestionnaireAnswer
     * const questionnaireAnswer = await prisma.questionnaireAnswer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends QuestionnaireAnswerFindFirstOrThrowArgs>(args?: SelectSubset<T, QuestionnaireAnswerFindFirstOrThrowArgs<ExtArgs>>): Prisma__QuestionnaireAnswerClient<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more QuestionnaireAnswers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireAnswerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all QuestionnaireAnswers
     * const questionnaireAnswers = await prisma.questionnaireAnswer.findMany()
     * 
     * // Get first 10 QuestionnaireAnswers
     * const questionnaireAnswers = await prisma.questionnaireAnswer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const questionnaireAnswerWithIdOnly = await prisma.questionnaireAnswer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends QuestionnaireAnswerFindManyArgs>(args?: SelectSubset<T, QuestionnaireAnswerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a QuestionnaireAnswer.
     * @param {QuestionnaireAnswerCreateArgs} args - Arguments to create a QuestionnaireAnswer.
     * @example
     * // Create one QuestionnaireAnswer
     * const QuestionnaireAnswer = await prisma.questionnaireAnswer.create({
     *   data: {
     *     // ... data to create a QuestionnaireAnswer
     *   }
     * })
     * 
     */
    create<T extends QuestionnaireAnswerCreateArgs>(args: SelectSubset<T, QuestionnaireAnswerCreateArgs<ExtArgs>>): Prisma__QuestionnaireAnswerClient<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many QuestionnaireAnswers.
     * @param {QuestionnaireAnswerCreateManyArgs} args - Arguments to create many QuestionnaireAnswers.
     * @example
     * // Create many QuestionnaireAnswers
     * const questionnaireAnswer = await prisma.questionnaireAnswer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends QuestionnaireAnswerCreateManyArgs>(args?: SelectSubset<T, QuestionnaireAnswerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many QuestionnaireAnswers and returns the data saved in the database.
     * @param {QuestionnaireAnswerCreateManyAndReturnArgs} args - Arguments to create many QuestionnaireAnswers.
     * @example
     * // Create many QuestionnaireAnswers
     * const questionnaireAnswer = await prisma.questionnaireAnswer.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many QuestionnaireAnswers and only return the `id`
     * const questionnaireAnswerWithIdOnly = await prisma.questionnaireAnswer.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends QuestionnaireAnswerCreateManyAndReturnArgs>(args?: SelectSubset<T, QuestionnaireAnswerCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a QuestionnaireAnswer.
     * @param {QuestionnaireAnswerDeleteArgs} args - Arguments to delete one QuestionnaireAnswer.
     * @example
     * // Delete one QuestionnaireAnswer
     * const QuestionnaireAnswer = await prisma.questionnaireAnswer.delete({
     *   where: {
     *     // ... filter to delete one QuestionnaireAnswer
     *   }
     * })
     * 
     */
    delete<T extends QuestionnaireAnswerDeleteArgs>(args: SelectSubset<T, QuestionnaireAnswerDeleteArgs<ExtArgs>>): Prisma__QuestionnaireAnswerClient<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one QuestionnaireAnswer.
     * @param {QuestionnaireAnswerUpdateArgs} args - Arguments to update one QuestionnaireAnswer.
     * @example
     * // Update one QuestionnaireAnswer
     * const questionnaireAnswer = await prisma.questionnaireAnswer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends QuestionnaireAnswerUpdateArgs>(args: SelectSubset<T, QuestionnaireAnswerUpdateArgs<ExtArgs>>): Prisma__QuestionnaireAnswerClient<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more QuestionnaireAnswers.
     * @param {QuestionnaireAnswerDeleteManyArgs} args - Arguments to filter QuestionnaireAnswers to delete.
     * @example
     * // Delete a few QuestionnaireAnswers
     * const { count } = await prisma.questionnaireAnswer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends QuestionnaireAnswerDeleteManyArgs>(args?: SelectSubset<T, QuestionnaireAnswerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionnaireAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireAnswerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many QuestionnaireAnswers
     * const questionnaireAnswer = await prisma.questionnaireAnswer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends QuestionnaireAnswerUpdateManyArgs>(args: SelectSubset<T, QuestionnaireAnswerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more QuestionnaireAnswers and returns the data updated in the database.
     * @param {QuestionnaireAnswerUpdateManyAndReturnArgs} args - Arguments to update many QuestionnaireAnswers.
     * @example
     * // Update many QuestionnaireAnswers
     * const questionnaireAnswer = await prisma.questionnaireAnswer.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more QuestionnaireAnswers and only return the `id`
     * const questionnaireAnswerWithIdOnly = await prisma.questionnaireAnswer.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends QuestionnaireAnswerUpdateManyAndReturnArgs>(args: SelectSubset<T, QuestionnaireAnswerUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one QuestionnaireAnswer.
     * @param {QuestionnaireAnswerUpsertArgs} args - Arguments to update or create a QuestionnaireAnswer.
     * @example
     * // Update or create a QuestionnaireAnswer
     * const questionnaireAnswer = await prisma.questionnaireAnswer.upsert({
     *   create: {
     *     // ... data to create a QuestionnaireAnswer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the QuestionnaireAnswer we want to update
     *   }
     * })
     */
    upsert<T extends QuestionnaireAnswerUpsertArgs>(args: SelectSubset<T, QuestionnaireAnswerUpsertArgs<ExtArgs>>): Prisma__QuestionnaireAnswerClient<$Result.GetResult<Prisma.$QuestionnaireAnswerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of QuestionnaireAnswers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireAnswerCountArgs} args - Arguments to filter QuestionnaireAnswers to count.
     * @example
     * // Count the number of QuestionnaireAnswers
     * const count = await prisma.questionnaireAnswer.count({
     *   where: {
     *     // ... the filter for the QuestionnaireAnswers we want to count
     *   }
     * })
    **/
    count<T extends QuestionnaireAnswerCountArgs>(
      args?: Subset<T, QuestionnaireAnswerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], QuestionnaireAnswerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a QuestionnaireAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireAnswerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends QuestionnaireAnswerAggregateArgs>(args: Subset<T, QuestionnaireAnswerAggregateArgs>): Prisma.PrismaPromise<GetQuestionnaireAnswerAggregateType<T>>

    /**
     * Group by QuestionnaireAnswer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {QuestionnaireAnswerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends QuestionnaireAnswerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: QuestionnaireAnswerGroupByArgs['orderBy'] }
        : { orderBy?: QuestionnaireAnswerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, QuestionnaireAnswerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetQuestionnaireAnswerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the QuestionnaireAnswer model
   */
  readonly fields: QuestionnaireAnswerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for QuestionnaireAnswer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__QuestionnaireAnswerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityTaxYear<T extends EntityTaxYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYearDefaultArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    question<T extends QuestionnaireQuestionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, QuestionnaireQuestionDefaultArgs<ExtArgs>>): Prisma__QuestionnaireQuestionClient<$Result.GetResult<Prisma.$QuestionnaireQuestionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the QuestionnaireAnswer model
   */
  interface QuestionnaireAnswerFieldRefs {
    readonly id: FieldRef<"QuestionnaireAnswer", 'String'>
    readonly entityTaxYearId: FieldRef<"QuestionnaireAnswer", 'String'>
    readonly questionId: FieldRef<"QuestionnaireAnswer", 'String'>
    readonly answerValue: FieldRef<"QuestionnaireAnswer", 'String'>
    readonly createdAt: FieldRef<"QuestionnaireAnswer", 'DateTime'>
    readonly updatedAt: FieldRef<"QuestionnaireAnswer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * QuestionnaireAnswer findUnique
   */
  export type QuestionnaireAnswerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireAnswer to fetch.
     */
    where: QuestionnaireAnswerWhereUniqueInput
  }

  /**
   * QuestionnaireAnswer findUniqueOrThrow
   */
  export type QuestionnaireAnswerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireAnswer to fetch.
     */
    where: QuestionnaireAnswerWhereUniqueInput
  }

  /**
   * QuestionnaireAnswer findFirst
   */
  export type QuestionnaireAnswerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireAnswer to fetch.
     */
    where?: QuestionnaireAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireAnswers to fetch.
     */
    orderBy?: QuestionnaireAnswerOrderByWithRelationInput | QuestionnaireAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireAnswers.
     */
    cursor?: QuestionnaireAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireAnswers.
     */
    distinct?: QuestionnaireAnswerScalarFieldEnum | QuestionnaireAnswerScalarFieldEnum[]
  }

  /**
   * QuestionnaireAnswer findFirstOrThrow
   */
  export type QuestionnaireAnswerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireAnswer to fetch.
     */
    where?: QuestionnaireAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireAnswers to fetch.
     */
    orderBy?: QuestionnaireAnswerOrderByWithRelationInput | QuestionnaireAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for QuestionnaireAnswers.
     */
    cursor?: QuestionnaireAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireAnswers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of QuestionnaireAnswers.
     */
    distinct?: QuestionnaireAnswerScalarFieldEnum | QuestionnaireAnswerScalarFieldEnum[]
  }

  /**
   * QuestionnaireAnswer findMany
   */
  export type QuestionnaireAnswerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * Filter, which QuestionnaireAnswers to fetch.
     */
    where?: QuestionnaireAnswerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of QuestionnaireAnswers to fetch.
     */
    orderBy?: QuestionnaireAnswerOrderByWithRelationInput | QuestionnaireAnswerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing QuestionnaireAnswers.
     */
    cursor?: QuestionnaireAnswerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` QuestionnaireAnswers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` QuestionnaireAnswers.
     */
    skip?: number
    distinct?: QuestionnaireAnswerScalarFieldEnum | QuestionnaireAnswerScalarFieldEnum[]
  }

  /**
   * QuestionnaireAnswer create
   */
  export type QuestionnaireAnswerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * The data needed to create a QuestionnaireAnswer.
     */
    data: XOR<QuestionnaireAnswerCreateInput, QuestionnaireAnswerUncheckedCreateInput>
  }

  /**
   * QuestionnaireAnswer createMany
   */
  export type QuestionnaireAnswerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many QuestionnaireAnswers.
     */
    data: QuestionnaireAnswerCreateManyInput | QuestionnaireAnswerCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * QuestionnaireAnswer createManyAndReturn
   */
  export type QuestionnaireAnswerCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * The data used to create many QuestionnaireAnswers.
     */
    data: QuestionnaireAnswerCreateManyInput | QuestionnaireAnswerCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionnaireAnswer update
   */
  export type QuestionnaireAnswerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * The data needed to update a QuestionnaireAnswer.
     */
    data: XOR<QuestionnaireAnswerUpdateInput, QuestionnaireAnswerUncheckedUpdateInput>
    /**
     * Choose, which QuestionnaireAnswer to update.
     */
    where: QuestionnaireAnswerWhereUniqueInput
  }

  /**
   * QuestionnaireAnswer updateMany
   */
  export type QuestionnaireAnswerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update QuestionnaireAnswers.
     */
    data: XOR<QuestionnaireAnswerUpdateManyMutationInput, QuestionnaireAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuestionnaireAnswers to update
     */
    where?: QuestionnaireAnswerWhereInput
    /**
     * Limit how many QuestionnaireAnswers to update.
     */
    limit?: number
  }

  /**
   * QuestionnaireAnswer updateManyAndReturn
   */
  export type QuestionnaireAnswerUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * The data used to update QuestionnaireAnswers.
     */
    data: XOR<QuestionnaireAnswerUpdateManyMutationInput, QuestionnaireAnswerUncheckedUpdateManyInput>
    /**
     * Filter which QuestionnaireAnswers to update
     */
    where?: QuestionnaireAnswerWhereInput
    /**
     * Limit how many QuestionnaireAnswers to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * QuestionnaireAnswer upsert
   */
  export type QuestionnaireAnswerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * The filter to search for the QuestionnaireAnswer to update in case it exists.
     */
    where: QuestionnaireAnswerWhereUniqueInput
    /**
     * In case the QuestionnaireAnswer found by the `where` argument doesn't exist, create a new QuestionnaireAnswer with this data.
     */
    create: XOR<QuestionnaireAnswerCreateInput, QuestionnaireAnswerUncheckedCreateInput>
    /**
     * In case the QuestionnaireAnswer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<QuestionnaireAnswerUpdateInput, QuestionnaireAnswerUncheckedUpdateInput>
  }

  /**
   * QuestionnaireAnswer delete
   */
  export type QuestionnaireAnswerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
    /**
     * Filter which QuestionnaireAnswer to delete.
     */
    where: QuestionnaireAnswerWhereUniqueInput
  }

  /**
   * QuestionnaireAnswer deleteMany
   */
  export type QuestionnaireAnswerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which QuestionnaireAnswers to delete
     */
    where?: QuestionnaireAnswerWhereInput
    /**
     * Limit how many QuestionnaireAnswers to delete.
     */
    limit?: number
  }

  /**
   * QuestionnaireAnswer without action
   */
  export type QuestionnaireAnswerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the QuestionnaireAnswer
     */
    select?: QuestionnaireAnswerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the QuestionnaireAnswer
     */
    omit?: QuestionnaireAnswerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: QuestionnaireAnswerInclude<ExtArgs> | null
  }


  /**
   * Model EngagementSignature
   */

  export type AggregateEngagementSignature = {
    _count: EngagementSignatureCountAggregateOutputType | null
    _min: EngagementSignatureMinAggregateOutputType | null
    _max: EngagementSignatureMaxAggregateOutputType | null
  }

  export type EngagementSignatureMinAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    signerName: string | null
    signerEmail: string | null
    signatureData: string | null
    signedAt: Date | null
  }

  export type EngagementSignatureMaxAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    signerName: string | null
    signerEmail: string | null
    signatureData: string | null
    signedAt: Date | null
  }

  export type EngagementSignatureCountAggregateOutputType = {
    id: number
    entityTaxYearId: number
    signerName: number
    signerEmail: number
    signatureData: number
    signedAt: number
    _all: number
  }


  export type EngagementSignatureMinAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    signerName?: true
    signerEmail?: true
    signatureData?: true
    signedAt?: true
  }

  export type EngagementSignatureMaxAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    signerName?: true
    signerEmail?: true
    signatureData?: true
    signedAt?: true
  }

  export type EngagementSignatureCountAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    signerName?: true
    signerEmail?: true
    signatureData?: true
    signedAt?: true
    _all?: true
  }

  export type EngagementSignatureAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EngagementSignature to aggregate.
     */
    where?: EngagementSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementSignatures to fetch.
     */
    orderBy?: EngagementSignatureOrderByWithRelationInput | EngagementSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EngagementSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EngagementSignatures
    **/
    _count?: true | EngagementSignatureCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EngagementSignatureMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EngagementSignatureMaxAggregateInputType
  }

  export type GetEngagementSignatureAggregateType<T extends EngagementSignatureAggregateArgs> = {
        [P in keyof T & keyof AggregateEngagementSignature]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEngagementSignature[P]>
      : GetScalarType<T[P], AggregateEngagementSignature[P]>
  }




  export type EngagementSignatureGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EngagementSignatureWhereInput
    orderBy?: EngagementSignatureOrderByWithAggregationInput | EngagementSignatureOrderByWithAggregationInput[]
    by: EngagementSignatureScalarFieldEnum[] | EngagementSignatureScalarFieldEnum
    having?: EngagementSignatureScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EngagementSignatureCountAggregateInputType | true
    _min?: EngagementSignatureMinAggregateInputType
    _max?: EngagementSignatureMaxAggregateInputType
  }

  export type EngagementSignatureGroupByOutputType = {
    id: string
    entityTaxYearId: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt: Date
    _count: EngagementSignatureCountAggregateOutputType | null
    _min: EngagementSignatureMinAggregateOutputType | null
    _max: EngagementSignatureMaxAggregateOutputType | null
  }

  type GetEngagementSignatureGroupByPayload<T extends EngagementSignatureGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EngagementSignatureGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EngagementSignatureGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EngagementSignatureGroupByOutputType[P]>
            : GetScalarType<T[P], EngagementSignatureGroupByOutputType[P]>
        }
      >
    >


  export type EngagementSignatureSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    signerName?: boolean
    signerEmail?: boolean
    signatureData?: boolean
    signedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["engagementSignature"]>

  export type EngagementSignatureSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    signerName?: boolean
    signerEmail?: boolean
    signatureData?: boolean
    signedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["engagementSignature"]>

  export type EngagementSignatureSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    signerName?: boolean
    signerEmail?: boolean
    signatureData?: boolean
    signedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["engagementSignature"]>

  export type EngagementSignatureSelectScalar = {
    id?: boolean
    entityTaxYearId?: boolean
    signerName?: boolean
    signerEmail?: boolean
    signatureData?: boolean
    signedAt?: boolean
  }

  export type EngagementSignatureOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityTaxYearId" | "signerName" | "signerEmail" | "signatureData" | "signedAt", ExtArgs["result"]["engagementSignature"]>
  export type EngagementSignatureInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type EngagementSignatureIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type EngagementSignatureIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }

  export type $EngagementSignaturePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EngagementSignature"
    objects: {
      entityTaxYear: Prisma.$EntityTaxYearPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityTaxYearId: string
      signerName: string
      signerEmail: string
      signatureData: string
      signedAt: Date
    }, ExtArgs["result"]["engagementSignature"]>
    composites: {}
  }

  type EngagementSignatureGetPayload<S extends boolean | null | undefined | EngagementSignatureDefaultArgs> = $Result.GetResult<Prisma.$EngagementSignaturePayload, S>

  type EngagementSignatureCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EngagementSignatureFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EngagementSignatureCountAggregateInputType | true
    }

  export interface EngagementSignatureDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EngagementSignature'], meta: { name: 'EngagementSignature' } }
    /**
     * Find zero or one EngagementSignature that matches the filter.
     * @param {EngagementSignatureFindUniqueArgs} args - Arguments to find a EngagementSignature
     * @example
     * // Get one EngagementSignature
     * const engagementSignature = await prisma.engagementSignature.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EngagementSignatureFindUniqueArgs>(args: SelectSubset<T, EngagementSignatureFindUniqueArgs<ExtArgs>>): Prisma__EngagementSignatureClient<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EngagementSignature that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EngagementSignatureFindUniqueOrThrowArgs} args - Arguments to find a EngagementSignature
     * @example
     * // Get one EngagementSignature
     * const engagementSignature = await prisma.engagementSignature.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EngagementSignatureFindUniqueOrThrowArgs>(args: SelectSubset<T, EngagementSignatureFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EngagementSignatureClient<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EngagementSignature that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementSignatureFindFirstArgs} args - Arguments to find a EngagementSignature
     * @example
     * // Get one EngagementSignature
     * const engagementSignature = await prisma.engagementSignature.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EngagementSignatureFindFirstArgs>(args?: SelectSubset<T, EngagementSignatureFindFirstArgs<ExtArgs>>): Prisma__EngagementSignatureClient<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EngagementSignature that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementSignatureFindFirstOrThrowArgs} args - Arguments to find a EngagementSignature
     * @example
     * // Get one EngagementSignature
     * const engagementSignature = await prisma.engagementSignature.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EngagementSignatureFindFirstOrThrowArgs>(args?: SelectSubset<T, EngagementSignatureFindFirstOrThrowArgs<ExtArgs>>): Prisma__EngagementSignatureClient<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EngagementSignatures that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementSignatureFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EngagementSignatures
     * const engagementSignatures = await prisma.engagementSignature.findMany()
     * 
     * // Get first 10 EngagementSignatures
     * const engagementSignatures = await prisma.engagementSignature.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const engagementSignatureWithIdOnly = await prisma.engagementSignature.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EngagementSignatureFindManyArgs>(args?: SelectSubset<T, EngagementSignatureFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EngagementSignature.
     * @param {EngagementSignatureCreateArgs} args - Arguments to create a EngagementSignature.
     * @example
     * // Create one EngagementSignature
     * const EngagementSignature = await prisma.engagementSignature.create({
     *   data: {
     *     // ... data to create a EngagementSignature
     *   }
     * })
     * 
     */
    create<T extends EngagementSignatureCreateArgs>(args: SelectSubset<T, EngagementSignatureCreateArgs<ExtArgs>>): Prisma__EngagementSignatureClient<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EngagementSignatures.
     * @param {EngagementSignatureCreateManyArgs} args - Arguments to create many EngagementSignatures.
     * @example
     * // Create many EngagementSignatures
     * const engagementSignature = await prisma.engagementSignature.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EngagementSignatureCreateManyArgs>(args?: SelectSubset<T, EngagementSignatureCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EngagementSignatures and returns the data saved in the database.
     * @param {EngagementSignatureCreateManyAndReturnArgs} args - Arguments to create many EngagementSignatures.
     * @example
     * // Create many EngagementSignatures
     * const engagementSignature = await prisma.engagementSignature.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EngagementSignatures and only return the `id`
     * const engagementSignatureWithIdOnly = await prisma.engagementSignature.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EngagementSignatureCreateManyAndReturnArgs>(args?: SelectSubset<T, EngagementSignatureCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EngagementSignature.
     * @param {EngagementSignatureDeleteArgs} args - Arguments to delete one EngagementSignature.
     * @example
     * // Delete one EngagementSignature
     * const EngagementSignature = await prisma.engagementSignature.delete({
     *   where: {
     *     // ... filter to delete one EngagementSignature
     *   }
     * })
     * 
     */
    delete<T extends EngagementSignatureDeleteArgs>(args: SelectSubset<T, EngagementSignatureDeleteArgs<ExtArgs>>): Prisma__EngagementSignatureClient<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EngagementSignature.
     * @param {EngagementSignatureUpdateArgs} args - Arguments to update one EngagementSignature.
     * @example
     * // Update one EngagementSignature
     * const engagementSignature = await prisma.engagementSignature.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EngagementSignatureUpdateArgs>(args: SelectSubset<T, EngagementSignatureUpdateArgs<ExtArgs>>): Prisma__EngagementSignatureClient<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EngagementSignatures.
     * @param {EngagementSignatureDeleteManyArgs} args - Arguments to filter EngagementSignatures to delete.
     * @example
     * // Delete a few EngagementSignatures
     * const { count } = await prisma.engagementSignature.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EngagementSignatureDeleteManyArgs>(args?: SelectSubset<T, EngagementSignatureDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EngagementSignatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementSignatureUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EngagementSignatures
     * const engagementSignature = await prisma.engagementSignature.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EngagementSignatureUpdateManyArgs>(args: SelectSubset<T, EngagementSignatureUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EngagementSignatures and returns the data updated in the database.
     * @param {EngagementSignatureUpdateManyAndReturnArgs} args - Arguments to update many EngagementSignatures.
     * @example
     * // Update many EngagementSignatures
     * const engagementSignature = await prisma.engagementSignature.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EngagementSignatures and only return the `id`
     * const engagementSignatureWithIdOnly = await prisma.engagementSignature.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EngagementSignatureUpdateManyAndReturnArgs>(args: SelectSubset<T, EngagementSignatureUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EngagementSignature.
     * @param {EngagementSignatureUpsertArgs} args - Arguments to update or create a EngagementSignature.
     * @example
     * // Update or create a EngagementSignature
     * const engagementSignature = await prisma.engagementSignature.upsert({
     *   create: {
     *     // ... data to create a EngagementSignature
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EngagementSignature we want to update
     *   }
     * })
     */
    upsert<T extends EngagementSignatureUpsertArgs>(args: SelectSubset<T, EngagementSignatureUpsertArgs<ExtArgs>>): Prisma__EngagementSignatureClient<$Result.GetResult<Prisma.$EngagementSignaturePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EngagementSignatures.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementSignatureCountArgs} args - Arguments to filter EngagementSignatures to count.
     * @example
     * // Count the number of EngagementSignatures
     * const count = await prisma.engagementSignature.count({
     *   where: {
     *     // ... the filter for the EngagementSignatures we want to count
     *   }
     * })
    **/
    count<T extends EngagementSignatureCountArgs>(
      args?: Subset<T, EngagementSignatureCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EngagementSignatureCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EngagementSignature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementSignatureAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EngagementSignatureAggregateArgs>(args: Subset<T, EngagementSignatureAggregateArgs>): Prisma.PrismaPromise<GetEngagementSignatureAggregateType<T>>

    /**
     * Group by EngagementSignature.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EngagementSignatureGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EngagementSignatureGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EngagementSignatureGroupByArgs['orderBy'] }
        : { orderBy?: EngagementSignatureGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EngagementSignatureGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEngagementSignatureGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EngagementSignature model
   */
  readonly fields: EngagementSignatureFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EngagementSignature.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EngagementSignatureClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityTaxYear<T extends EntityTaxYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYearDefaultArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EngagementSignature model
   */
  interface EngagementSignatureFieldRefs {
    readonly id: FieldRef<"EngagementSignature", 'String'>
    readonly entityTaxYearId: FieldRef<"EngagementSignature", 'String'>
    readonly signerName: FieldRef<"EngagementSignature", 'String'>
    readonly signerEmail: FieldRef<"EngagementSignature", 'String'>
    readonly signatureData: FieldRef<"EngagementSignature", 'String'>
    readonly signedAt: FieldRef<"EngagementSignature", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EngagementSignature findUnique
   */
  export type EngagementSignatureFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EngagementSignature to fetch.
     */
    where: EngagementSignatureWhereUniqueInput
  }

  /**
   * EngagementSignature findUniqueOrThrow
   */
  export type EngagementSignatureFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EngagementSignature to fetch.
     */
    where: EngagementSignatureWhereUniqueInput
  }

  /**
   * EngagementSignature findFirst
   */
  export type EngagementSignatureFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EngagementSignature to fetch.
     */
    where?: EngagementSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementSignatures to fetch.
     */
    orderBy?: EngagementSignatureOrderByWithRelationInput | EngagementSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EngagementSignatures.
     */
    cursor?: EngagementSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EngagementSignatures.
     */
    distinct?: EngagementSignatureScalarFieldEnum | EngagementSignatureScalarFieldEnum[]
  }

  /**
   * EngagementSignature findFirstOrThrow
   */
  export type EngagementSignatureFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EngagementSignature to fetch.
     */
    where?: EngagementSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementSignatures to fetch.
     */
    orderBy?: EngagementSignatureOrderByWithRelationInput | EngagementSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EngagementSignatures.
     */
    cursor?: EngagementSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementSignatures.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EngagementSignatures.
     */
    distinct?: EngagementSignatureScalarFieldEnum | EngagementSignatureScalarFieldEnum[]
  }

  /**
   * EngagementSignature findMany
   */
  export type EngagementSignatureFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * Filter, which EngagementSignatures to fetch.
     */
    where?: EngagementSignatureWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EngagementSignatures to fetch.
     */
    orderBy?: EngagementSignatureOrderByWithRelationInput | EngagementSignatureOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EngagementSignatures.
     */
    cursor?: EngagementSignatureWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EngagementSignatures from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EngagementSignatures.
     */
    skip?: number
    distinct?: EngagementSignatureScalarFieldEnum | EngagementSignatureScalarFieldEnum[]
  }

  /**
   * EngagementSignature create
   */
  export type EngagementSignatureCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * The data needed to create a EngagementSignature.
     */
    data: XOR<EngagementSignatureCreateInput, EngagementSignatureUncheckedCreateInput>
  }

  /**
   * EngagementSignature createMany
   */
  export type EngagementSignatureCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EngagementSignatures.
     */
    data: EngagementSignatureCreateManyInput | EngagementSignatureCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EngagementSignature createManyAndReturn
   */
  export type EngagementSignatureCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * The data used to create many EngagementSignatures.
     */
    data: EngagementSignatureCreateManyInput | EngagementSignatureCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EngagementSignature update
   */
  export type EngagementSignatureUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * The data needed to update a EngagementSignature.
     */
    data: XOR<EngagementSignatureUpdateInput, EngagementSignatureUncheckedUpdateInput>
    /**
     * Choose, which EngagementSignature to update.
     */
    where: EngagementSignatureWhereUniqueInput
  }

  /**
   * EngagementSignature updateMany
   */
  export type EngagementSignatureUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EngagementSignatures.
     */
    data: XOR<EngagementSignatureUpdateManyMutationInput, EngagementSignatureUncheckedUpdateManyInput>
    /**
     * Filter which EngagementSignatures to update
     */
    where?: EngagementSignatureWhereInput
    /**
     * Limit how many EngagementSignatures to update.
     */
    limit?: number
  }

  /**
   * EngagementSignature updateManyAndReturn
   */
  export type EngagementSignatureUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * The data used to update EngagementSignatures.
     */
    data: XOR<EngagementSignatureUpdateManyMutationInput, EngagementSignatureUncheckedUpdateManyInput>
    /**
     * Filter which EngagementSignatures to update
     */
    where?: EngagementSignatureWhereInput
    /**
     * Limit how many EngagementSignatures to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EngagementSignature upsert
   */
  export type EngagementSignatureUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * The filter to search for the EngagementSignature to update in case it exists.
     */
    where: EngagementSignatureWhereUniqueInput
    /**
     * In case the EngagementSignature found by the `where` argument doesn't exist, create a new EngagementSignature with this data.
     */
    create: XOR<EngagementSignatureCreateInput, EngagementSignatureUncheckedCreateInput>
    /**
     * In case the EngagementSignature was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EngagementSignatureUpdateInput, EngagementSignatureUncheckedUpdateInput>
  }

  /**
   * EngagementSignature delete
   */
  export type EngagementSignatureDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
    /**
     * Filter which EngagementSignature to delete.
     */
    where: EngagementSignatureWhereUniqueInput
  }

  /**
   * EngagementSignature deleteMany
   */
  export type EngagementSignatureDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EngagementSignatures to delete
     */
    where?: EngagementSignatureWhereInput
    /**
     * Limit how many EngagementSignatures to delete.
     */
    limit?: number
  }

  /**
   * EngagementSignature without action
   */
  export type EngagementSignatureDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EngagementSignature
     */
    select?: EngagementSignatureSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EngagementSignature
     */
    omit?: EngagementSignatureOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EngagementSignatureInclude<ExtArgs> | null
  }


  /**
   * Model EfileAuthorization
   */

  export type AggregateEfileAuthorization = {
    _count: EfileAuthorizationCountAggregateOutputType | null
    _min: EfileAuthorizationMinAggregateOutputType | null
    _max: EfileAuthorizationMaxAggregateOutputType | null
  }

  export type EfileAuthorizationMinAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    signerName: string | null
    signerEmail: string | null
    signatureData: string | null
    signedAt: Date | null
  }

  export type EfileAuthorizationMaxAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    signerName: string | null
    signerEmail: string | null
    signatureData: string | null
    signedAt: Date | null
  }

  export type EfileAuthorizationCountAggregateOutputType = {
    id: number
    entityTaxYearId: number
    signerName: number
    signerEmail: number
    signatureData: number
    signedAt: number
    _all: number
  }


  export type EfileAuthorizationMinAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    signerName?: true
    signerEmail?: true
    signatureData?: true
    signedAt?: true
  }

  export type EfileAuthorizationMaxAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    signerName?: true
    signerEmail?: true
    signatureData?: true
    signedAt?: true
  }

  export type EfileAuthorizationCountAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    signerName?: true
    signerEmail?: true
    signatureData?: true
    signedAt?: true
    _all?: true
  }

  export type EfileAuthorizationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EfileAuthorization to aggregate.
     */
    where?: EfileAuthorizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EfileAuthorizations to fetch.
     */
    orderBy?: EfileAuthorizationOrderByWithRelationInput | EfileAuthorizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EfileAuthorizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EfileAuthorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EfileAuthorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EfileAuthorizations
    **/
    _count?: true | EfileAuthorizationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EfileAuthorizationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EfileAuthorizationMaxAggregateInputType
  }

  export type GetEfileAuthorizationAggregateType<T extends EfileAuthorizationAggregateArgs> = {
        [P in keyof T & keyof AggregateEfileAuthorization]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEfileAuthorization[P]>
      : GetScalarType<T[P], AggregateEfileAuthorization[P]>
  }




  export type EfileAuthorizationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EfileAuthorizationWhereInput
    orderBy?: EfileAuthorizationOrderByWithAggregationInput | EfileAuthorizationOrderByWithAggregationInput[]
    by: EfileAuthorizationScalarFieldEnum[] | EfileAuthorizationScalarFieldEnum
    having?: EfileAuthorizationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EfileAuthorizationCountAggregateInputType | true
    _min?: EfileAuthorizationMinAggregateInputType
    _max?: EfileAuthorizationMaxAggregateInputType
  }

  export type EfileAuthorizationGroupByOutputType = {
    id: string
    entityTaxYearId: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt: Date
    _count: EfileAuthorizationCountAggregateOutputType | null
    _min: EfileAuthorizationMinAggregateOutputType | null
    _max: EfileAuthorizationMaxAggregateOutputType | null
  }

  type GetEfileAuthorizationGroupByPayload<T extends EfileAuthorizationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EfileAuthorizationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EfileAuthorizationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EfileAuthorizationGroupByOutputType[P]>
            : GetScalarType<T[P], EfileAuthorizationGroupByOutputType[P]>
        }
      >
    >


  export type EfileAuthorizationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    signerName?: boolean
    signerEmail?: boolean
    signatureData?: boolean
    signedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["efileAuthorization"]>

  export type EfileAuthorizationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    signerName?: boolean
    signerEmail?: boolean
    signatureData?: boolean
    signedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["efileAuthorization"]>

  export type EfileAuthorizationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    signerName?: boolean
    signerEmail?: boolean
    signatureData?: boolean
    signedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["efileAuthorization"]>

  export type EfileAuthorizationSelectScalar = {
    id?: boolean
    entityTaxYearId?: boolean
    signerName?: boolean
    signerEmail?: boolean
    signatureData?: boolean
    signedAt?: boolean
  }

  export type EfileAuthorizationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityTaxYearId" | "signerName" | "signerEmail" | "signatureData" | "signedAt", ExtArgs["result"]["efileAuthorization"]>
  export type EfileAuthorizationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type EfileAuthorizationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type EfileAuthorizationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }

  export type $EfileAuthorizationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EfileAuthorization"
    objects: {
      entityTaxYear: Prisma.$EntityTaxYearPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityTaxYearId: string
      signerName: string
      signerEmail: string
      signatureData: string
      signedAt: Date
    }, ExtArgs["result"]["efileAuthorization"]>
    composites: {}
  }

  type EfileAuthorizationGetPayload<S extends boolean | null | undefined | EfileAuthorizationDefaultArgs> = $Result.GetResult<Prisma.$EfileAuthorizationPayload, S>

  type EfileAuthorizationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EfileAuthorizationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EfileAuthorizationCountAggregateInputType | true
    }

  export interface EfileAuthorizationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EfileAuthorization'], meta: { name: 'EfileAuthorization' } }
    /**
     * Find zero or one EfileAuthorization that matches the filter.
     * @param {EfileAuthorizationFindUniqueArgs} args - Arguments to find a EfileAuthorization
     * @example
     * // Get one EfileAuthorization
     * const efileAuthorization = await prisma.efileAuthorization.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EfileAuthorizationFindUniqueArgs>(args: SelectSubset<T, EfileAuthorizationFindUniqueArgs<ExtArgs>>): Prisma__EfileAuthorizationClient<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EfileAuthorization that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EfileAuthorizationFindUniqueOrThrowArgs} args - Arguments to find a EfileAuthorization
     * @example
     * // Get one EfileAuthorization
     * const efileAuthorization = await prisma.efileAuthorization.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EfileAuthorizationFindUniqueOrThrowArgs>(args: SelectSubset<T, EfileAuthorizationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EfileAuthorizationClient<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EfileAuthorization that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EfileAuthorizationFindFirstArgs} args - Arguments to find a EfileAuthorization
     * @example
     * // Get one EfileAuthorization
     * const efileAuthorization = await prisma.efileAuthorization.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EfileAuthorizationFindFirstArgs>(args?: SelectSubset<T, EfileAuthorizationFindFirstArgs<ExtArgs>>): Prisma__EfileAuthorizationClient<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EfileAuthorization that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EfileAuthorizationFindFirstOrThrowArgs} args - Arguments to find a EfileAuthorization
     * @example
     * // Get one EfileAuthorization
     * const efileAuthorization = await prisma.efileAuthorization.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EfileAuthorizationFindFirstOrThrowArgs>(args?: SelectSubset<T, EfileAuthorizationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EfileAuthorizationClient<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EfileAuthorizations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EfileAuthorizationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EfileAuthorizations
     * const efileAuthorizations = await prisma.efileAuthorization.findMany()
     * 
     * // Get first 10 EfileAuthorizations
     * const efileAuthorizations = await prisma.efileAuthorization.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const efileAuthorizationWithIdOnly = await prisma.efileAuthorization.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EfileAuthorizationFindManyArgs>(args?: SelectSubset<T, EfileAuthorizationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EfileAuthorization.
     * @param {EfileAuthorizationCreateArgs} args - Arguments to create a EfileAuthorization.
     * @example
     * // Create one EfileAuthorization
     * const EfileAuthorization = await prisma.efileAuthorization.create({
     *   data: {
     *     // ... data to create a EfileAuthorization
     *   }
     * })
     * 
     */
    create<T extends EfileAuthorizationCreateArgs>(args: SelectSubset<T, EfileAuthorizationCreateArgs<ExtArgs>>): Prisma__EfileAuthorizationClient<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EfileAuthorizations.
     * @param {EfileAuthorizationCreateManyArgs} args - Arguments to create many EfileAuthorizations.
     * @example
     * // Create many EfileAuthorizations
     * const efileAuthorization = await prisma.efileAuthorization.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EfileAuthorizationCreateManyArgs>(args?: SelectSubset<T, EfileAuthorizationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EfileAuthorizations and returns the data saved in the database.
     * @param {EfileAuthorizationCreateManyAndReturnArgs} args - Arguments to create many EfileAuthorizations.
     * @example
     * // Create many EfileAuthorizations
     * const efileAuthorization = await prisma.efileAuthorization.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EfileAuthorizations and only return the `id`
     * const efileAuthorizationWithIdOnly = await prisma.efileAuthorization.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EfileAuthorizationCreateManyAndReturnArgs>(args?: SelectSubset<T, EfileAuthorizationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EfileAuthorization.
     * @param {EfileAuthorizationDeleteArgs} args - Arguments to delete one EfileAuthorization.
     * @example
     * // Delete one EfileAuthorization
     * const EfileAuthorization = await prisma.efileAuthorization.delete({
     *   where: {
     *     // ... filter to delete one EfileAuthorization
     *   }
     * })
     * 
     */
    delete<T extends EfileAuthorizationDeleteArgs>(args: SelectSubset<T, EfileAuthorizationDeleteArgs<ExtArgs>>): Prisma__EfileAuthorizationClient<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EfileAuthorization.
     * @param {EfileAuthorizationUpdateArgs} args - Arguments to update one EfileAuthorization.
     * @example
     * // Update one EfileAuthorization
     * const efileAuthorization = await prisma.efileAuthorization.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EfileAuthorizationUpdateArgs>(args: SelectSubset<T, EfileAuthorizationUpdateArgs<ExtArgs>>): Prisma__EfileAuthorizationClient<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EfileAuthorizations.
     * @param {EfileAuthorizationDeleteManyArgs} args - Arguments to filter EfileAuthorizations to delete.
     * @example
     * // Delete a few EfileAuthorizations
     * const { count } = await prisma.efileAuthorization.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EfileAuthorizationDeleteManyArgs>(args?: SelectSubset<T, EfileAuthorizationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EfileAuthorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EfileAuthorizationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EfileAuthorizations
     * const efileAuthorization = await prisma.efileAuthorization.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EfileAuthorizationUpdateManyArgs>(args: SelectSubset<T, EfileAuthorizationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EfileAuthorizations and returns the data updated in the database.
     * @param {EfileAuthorizationUpdateManyAndReturnArgs} args - Arguments to update many EfileAuthorizations.
     * @example
     * // Update many EfileAuthorizations
     * const efileAuthorization = await prisma.efileAuthorization.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EfileAuthorizations and only return the `id`
     * const efileAuthorizationWithIdOnly = await prisma.efileAuthorization.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EfileAuthorizationUpdateManyAndReturnArgs>(args: SelectSubset<T, EfileAuthorizationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EfileAuthorization.
     * @param {EfileAuthorizationUpsertArgs} args - Arguments to update or create a EfileAuthorization.
     * @example
     * // Update or create a EfileAuthorization
     * const efileAuthorization = await prisma.efileAuthorization.upsert({
     *   create: {
     *     // ... data to create a EfileAuthorization
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EfileAuthorization we want to update
     *   }
     * })
     */
    upsert<T extends EfileAuthorizationUpsertArgs>(args: SelectSubset<T, EfileAuthorizationUpsertArgs<ExtArgs>>): Prisma__EfileAuthorizationClient<$Result.GetResult<Prisma.$EfileAuthorizationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EfileAuthorizations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EfileAuthorizationCountArgs} args - Arguments to filter EfileAuthorizations to count.
     * @example
     * // Count the number of EfileAuthorizations
     * const count = await prisma.efileAuthorization.count({
     *   where: {
     *     // ... the filter for the EfileAuthorizations we want to count
     *   }
     * })
    **/
    count<T extends EfileAuthorizationCountArgs>(
      args?: Subset<T, EfileAuthorizationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EfileAuthorizationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EfileAuthorization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EfileAuthorizationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EfileAuthorizationAggregateArgs>(args: Subset<T, EfileAuthorizationAggregateArgs>): Prisma.PrismaPromise<GetEfileAuthorizationAggregateType<T>>

    /**
     * Group by EfileAuthorization.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EfileAuthorizationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EfileAuthorizationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EfileAuthorizationGroupByArgs['orderBy'] }
        : { orderBy?: EfileAuthorizationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EfileAuthorizationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEfileAuthorizationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EfileAuthorization model
   */
  readonly fields: EfileAuthorizationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EfileAuthorization.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EfileAuthorizationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityTaxYear<T extends EntityTaxYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYearDefaultArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EfileAuthorization model
   */
  interface EfileAuthorizationFieldRefs {
    readonly id: FieldRef<"EfileAuthorization", 'String'>
    readonly entityTaxYearId: FieldRef<"EfileAuthorization", 'String'>
    readonly signerName: FieldRef<"EfileAuthorization", 'String'>
    readonly signerEmail: FieldRef<"EfileAuthorization", 'String'>
    readonly signatureData: FieldRef<"EfileAuthorization", 'String'>
    readonly signedAt: FieldRef<"EfileAuthorization", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EfileAuthorization findUnique
   */
  export type EfileAuthorizationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which EfileAuthorization to fetch.
     */
    where: EfileAuthorizationWhereUniqueInput
  }

  /**
   * EfileAuthorization findUniqueOrThrow
   */
  export type EfileAuthorizationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which EfileAuthorization to fetch.
     */
    where: EfileAuthorizationWhereUniqueInput
  }

  /**
   * EfileAuthorization findFirst
   */
  export type EfileAuthorizationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which EfileAuthorization to fetch.
     */
    where?: EfileAuthorizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EfileAuthorizations to fetch.
     */
    orderBy?: EfileAuthorizationOrderByWithRelationInput | EfileAuthorizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EfileAuthorizations.
     */
    cursor?: EfileAuthorizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EfileAuthorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EfileAuthorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EfileAuthorizations.
     */
    distinct?: EfileAuthorizationScalarFieldEnum | EfileAuthorizationScalarFieldEnum[]
  }

  /**
   * EfileAuthorization findFirstOrThrow
   */
  export type EfileAuthorizationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which EfileAuthorization to fetch.
     */
    where?: EfileAuthorizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EfileAuthorizations to fetch.
     */
    orderBy?: EfileAuthorizationOrderByWithRelationInput | EfileAuthorizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EfileAuthorizations.
     */
    cursor?: EfileAuthorizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EfileAuthorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EfileAuthorizations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EfileAuthorizations.
     */
    distinct?: EfileAuthorizationScalarFieldEnum | EfileAuthorizationScalarFieldEnum[]
  }

  /**
   * EfileAuthorization findMany
   */
  export type EfileAuthorizationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * Filter, which EfileAuthorizations to fetch.
     */
    where?: EfileAuthorizationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EfileAuthorizations to fetch.
     */
    orderBy?: EfileAuthorizationOrderByWithRelationInput | EfileAuthorizationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EfileAuthorizations.
     */
    cursor?: EfileAuthorizationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EfileAuthorizations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EfileAuthorizations.
     */
    skip?: number
    distinct?: EfileAuthorizationScalarFieldEnum | EfileAuthorizationScalarFieldEnum[]
  }

  /**
   * EfileAuthorization create
   */
  export type EfileAuthorizationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * The data needed to create a EfileAuthorization.
     */
    data: XOR<EfileAuthorizationCreateInput, EfileAuthorizationUncheckedCreateInput>
  }

  /**
   * EfileAuthorization createMany
   */
  export type EfileAuthorizationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EfileAuthorizations.
     */
    data: EfileAuthorizationCreateManyInput | EfileAuthorizationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EfileAuthorization createManyAndReturn
   */
  export type EfileAuthorizationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * The data used to create many EfileAuthorizations.
     */
    data: EfileAuthorizationCreateManyInput | EfileAuthorizationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EfileAuthorization update
   */
  export type EfileAuthorizationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * The data needed to update a EfileAuthorization.
     */
    data: XOR<EfileAuthorizationUpdateInput, EfileAuthorizationUncheckedUpdateInput>
    /**
     * Choose, which EfileAuthorization to update.
     */
    where: EfileAuthorizationWhereUniqueInput
  }

  /**
   * EfileAuthorization updateMany
   */
  export type EfileAuthorizationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EfileAuthorizations.
     */
    data: XOR<EfileAuthorizationUpdateManyMutationInput, EfileAuthorizationUncheckedUpdateManyInput>
    /**
     * Filter which EfileAuthorizations to update
     */
    where?: EfileAuthorizationWhereInput
    /**
     * Limit how many EfileAuthorizations to update.
     */
    limit?: number
  }

  /**
   * EfileAuthorization updateManyAndReturn
   */
  export type EfileAuthorizationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * The data used to update EfileAuthorizations.
     */
    data: XOR<EfileAuthorizationUpdateManyMutationInput, EfileAuthorizationUncheckedUpdateManyInput>
    /**
     * Filter which EfileAuthorizations to update
     */
    where?: EfileAuthorizationWhereInput
    /**
     * Limit how many EfileAuthorizations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EfileAuthorization upsert
   */
  export type EfileAuthorizationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * The filter to search for the EfileAuthorization to update in case it exists.
     */
    where: EfileAuthorizationWhereUniqueInput
    /**
     * In case the EfileAuthorization found by the `where` argument doesn't exist, create a new EfileAuthorization with this data.
     */
    create: XOR<EfileAuthorizationCreateInput, EfileAuthorizationUncheckedCreateInput>
    /**
     * In case the EfileAuthorization was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EfileAuthorizationUpdateInput, EfileAuthorizationUncheckedUpdateInput>
  }

  /**
   * EfileAuthorization delete
   */
  export type EfileAuthorizationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
    /**
     * Filter which EfileAuthorization to delete.
     */
    where: EfileAuthorizationWhereUniqueInput
  }

  /**
   * EfileAuthorization deleteMany
   */
  export type EfileAuthorizationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EfileAuthorizations to delete
     */
    where?: EfileAuthorizationWhereInput
    /**
     * Limit how many EfileAuthorizations to delete.
     */
    limit?: number
  }

  /**
   * EfileAuthorization without action
   */
  export type EfileAuthorizationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EfileAuthorization
     */
    select?: EfileAuthorizationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EfileAuthorization
     */
    omit?: EfileAuthorizationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EfileAuthorizationInclude<ExtArgs> | null
  }


  /**
   * Model MessageThread
   */

  export type AggregateMessageThread = {
    _count: MessageThreadCountAggregateOutputType | null
    _min: MessageThreadMinAggregateOutputType | null
    _max: MessageThreadMaxAggregateOutputType | null
  }

  export type MessageThreadMinAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    archived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageThreadMaxAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    archived: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageThreadCountAggregateOutputType = {
    id: number
    entityTaxYearId: number
    archived: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageThreadMinAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    archived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageThreadMaxAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    archived?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageThreadCountAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    archived?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageThreadAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThread to aggregate.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageThreads
    **/
    _count?: true | MessageThreadCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageThreadMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageThreadMaxAggregateInputType
  }

  export type GetMessageThreadAggregateType<T extends MessageThreadAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageThread]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageThread[P]>
      : GetScalarType<T[P], AggregateMessageThread[P]>
  }




  export type MessageThreadGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageThreadWhereInput
    orderBy?: MessageThreadOrderByWithAggregationInput | MessageThreadOrderByWithAggregationInput[]
    by: MessageThreadScalarFieldEnum[] | MessageThreadScalarFieldEnum
    having?: MessageThreadScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageThreadCountAggregateInputType | true
    _min?: MessageThreadMinAggregateInputType
    _max?: MessageThreadMaxAggregateInputType
  }

  export type MessageThreadGroupByOutputType = {
    id: string
    entityTaxYearId: string
    archived: boolean
    createdAt: Date
    updatedAt: Date
    _count: MessageThreadCountAggregateOutputType | null
    _min: MessageThreadMinAggregateOutputType | null
    _max: MessageThreadMaxAggregateOutputType | null
  }

  type GetMessageThreadGroupByPayload<T extends MessageThreadGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageThreadGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageThreadGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageThreadGroupByOutputType[P]>
            : GetScalarType<T[P], MessageThreadGroupByOutputType[P]>
        }
      >
    >


  export type MessageThreadSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    archived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    participants?: boolean | MessageThread$participantsArgs<ExtArgs>
    messages?: boolean | MessageThread$messagesArgs<ExtArgs>
    _count?: boolean | MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    archived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    archived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageThread"]>

  export type MessageThreadSelectScalar = {
    id?: boolean
    entityTaxYearId?: boolean
    archived?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageThreadOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityTaxYearId" | "archived" | "createdAt" | "updatedAt", ExtArgs["result"]["messageThread"]>
  export type MessageThreadInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    participants?: boolean | MessageThread$participantsArgs<ExtArgs>
    messages?: boolean | MessageThread$messagesArgs<ExtArgs>
    _count?: boolean | MessageThreadCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageThreadIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type MessageThreadIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }

  export type $MessageThreadPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageThread"
    objects: {
      entityTaxYear: Prisma.$EntityTaxYearPayload<ExtArgs>
      participants: Prisma.$ThreadParticipantPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityTaxYearId: string
      archived: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["messageThread"]>
    composites: {}
  }

  type MessageThreadGetPayload<S extends boolean | null | undefined | MessageThreadDefaultArgs> = $Result.GetResult<Prisma.$MessageThreadPayload, S>

  type MessageThreadCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageThreadFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageThreadCountAggregateInputType | true
    }

  export interface MessageThreadDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageThread'], meta: { name: 'MessageThread' } }
    /**
     * Find zero or one MessageThread that matches the filter.
     * @param {MessageThreadFindUniqueArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageThreadFindUniqueArgs>(args: SelectSubset<T, MessageThreadFindUniqueArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageThread that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageThreadFindUniqueOrThrowArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageThreadFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageThreadFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageThread that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindFirstArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageThreadFindFirstArgs>(args?: SelectSubset<T, MessageThreadFindFirstArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageThread that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindFirstOrThrowArgs} args - Arguments to find a MessageThread
     * @example
     * // Get one MessageThread
     * const messageThread = await prisma.messageThread.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageThreadFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageThreadFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageThreads that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageThreads
     * const messageThreads = await prisma.messageThread.findMany()
     * 
     * // Get first 10 MessageThreads
     * const messageThreads = await prisma.messageThread.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageThreadFindManyArgs>(args?: SelectSubset<T, MessageThreadFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageThread.
     * @param {MessageThreadCreateArgs} args - Arguments to create a MessageThread.
     * @example
     * // Create one MessageThread
     * const MessageThread = await prisma.messageThread.create({
     *   data: {
     *     // ... data to create a MessageThread
     *   }
     * })
     * 
     */
    create<T extends MessageThreadCreateArgs>(args: SelectSubset<T, MessageThreadCreateArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageThreads.
     * @param {MessageThreadCreateManyArgs} args - Arguments to create many MessageThreads.
     * @example
     * // Create many MessageThreads
     * const messageThread = await prisma.messageThread.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageThreadCreateManyArgs>(args?: SelectSubset<T, MessageThreadCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageThreads and returns the data saved in the database.
     * @param {MessageThreadCreateManyAndReturnArgs} args - Arguments to create many MessageThreads.
     * @example
     * // Create many MessageThreads
     * const messageThread = await prisma.messageThread.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageThreads and only return the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageThreadCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageThreadCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageThread.
     * @param {MessageThreadDeleteArgs} args - Arguments to delete one MessageThread.
     * @example
     * // Delete one MessageThread
     * const MessageThread = await prisma.messageThread.delete({
     *   where: {
     *     // ... filter to delete one MessageThread
     *   }
     * })
     * 
     */
    delete<T extends MessageThreadDeleteArgs>(args: SelectSubset<T, MessageThreadDeleteArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageThread.
     * @param {MessageThreadUpdateArgs} args - Arguments to update one MessageThread.
     * @example
     * // Update one MessageThread
     * const messageThread = await prisma.messageThread.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageThreadUpdateArgs>(args: SelectSubset<T, MessageThreadUpdateArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageThreads.
     * @param {MessageThreadDeleteManyArgs} args - Arguments to filter MessageThreads to delete.
     * @example
     * // Delete a few MessageThreads
     * const { count } = await prisma.messageThread.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageThreadDeleteManyArgs>(args?: SelectSubset<T, MessageThreadDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageThreads
     * const messageThread = await prisma.messageThread.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageThreadUpdateManyArgs>(args: SelectSubset<T, MessageThreadUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageThreads and returns the data updated in the database.
     * @param {MessageThreadUpdateManyAndReturnArgs} args - Arguments to update many MessageThreads.
     * @example
     * // Update many MessageThreads
     * const messageThread = await prisma.messageThread.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageThreads and only return the `id`
     * const messageThreadWithIdOnly = await prisma.messageThread.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageThreadUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageThreadUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageThread.
     * @param {MessageThreadUpsertArgs} args - Arguments to update or create a MessageThread.
     * @example
     * // Update or create a MessageThread
     * const messageThread = await prisma.messageThread.upsert({
     *   create: {
     *     // ... data to create a MessageThread
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageThread we want to update
     *   }
     * })
     */
    upsert<T extends MessageThreadUpsertArgs>(args: SelectSubset<T, MessageThreadUpsertArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageThreads.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadCountArgs} args - Arguments to filter MessageThreads to count.
     * @example
     * // Count the number of MessageThreads
     * const count = await prisma.messageThread.count({
     *   where: {
     *     // ... the filter for the MessageThreads we want to count
     *   }
     * })
    **/
    count<T extends MessageThreadCountArgs>(
      args?: Subset<T, MessageThreadCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageThreadCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageThreadAggregateArgs>(args: Subset<T, MessageThreadAggregateArgs>): Prisma.PrismaPromise<GetMessageThreadAggregateType<T>>

    /**
     * Group by MessageThread.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageThreadGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageThreadGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageThreadGroupByArgs['orderBy'] }
        : { orderBy?: MessageThreadGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageThreadGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageThreadGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageThread model
   */
  readonly fields: MessageThreadFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageThread.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageThreadClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityTaxYear<T extends EntityTaxYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYearDefaultArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    participants<T extends MessageThread$participantsArgs<ExtArgs> = {}>(args?: Subset<T, MessageThread$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends MessageThread$messagesArgs<ExtArgs> = {}>(args?: Subset<T, MessageThread$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageThread model
   */
  interface MessageThreadFieldRefs {
    readonly id: FieldRef<"MessageThread", 'String'>
    readonly entityTaxYearId: FieldRef<"MessageThread", 'String'>
    readonly archived: FieldRef<"MessageThread", 'Boolean'>
    readonly createdAt: FieldRef<"MessageThread", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageThread", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageThread findUnique
   */
  export type MessageThreadFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread findUniqueOrThrow
   */
  export type MessageThreadFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread findFirst
   */
  export type MessageThreadFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreads.
     */
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread findFirstOrThrow
   */
  export type MessageThreadFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThread to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageThreads.
     */
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread findMany
   */
  export type MessageThreadFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter, which MessageThreads to fetch.
     */
    where?: MessageThreadWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageThreads to fetch.
     */
    orderBy?: MessageThreadOrderByWithRelationInput | MessageThreadOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageThreads.
     */
    cursor?: MessageThreadWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MessageThreads from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageThreads.
     */
    skip?: number
    distinct?: MessageThreadScalarFieldEnum | MessageThreadScalarFieldEnum[]
  }

  /**
   * MessageThread create
   */
  export type MessageThreadCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageThread.
     */
    data: XOR<MessageThreadCreateInput, MessageThreadUncheckedCreateInput>
  }

  /**
   * MessageThread createMany
   */
  export type MessageThreadCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageThreads.
     */
    data: MessageThreadCreateManyInput | MessageThreadCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageThread createManyAndReturn
   */
  export type MessageThreadCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * The data used to create many MessageThreads.
     */
    data: MessageThreadCreateManyInput | MessageThreadCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageThread update
   */
  export type MessageThreadUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageThread.
     */
    data: XOR<MessageThreadUpdateInput, MessageThreadUncheckedUpdateInput>
    /**
     * Choose, which MessageThread to update.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread updateMany
   */
  export type MessageThreadUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageThreads.
     */
    data: XOR<MessageThreadUpdateManyMutationInput, MessageThreadUncheckedUpdateManyInput>
    /**
     * Filter which MessageThreads to update
     */
    where?: MessageThreadWhereInput
    /**
     * Limit how many MessageThreads to update.
     */
    limit?: number
  }

  /**
   * MessageThread updateManyAndReturn
   */
  export type MessageThreadUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * The data used to update MessageThreads.
     */
    data: XOR<MessageThreadUpdateManyMutationInput, MessageThreadUncheckedUpdateManyInput>
    /**
     * Filter which MessageThreads to update
     */
    where?: MessageThreadWhereInput
    /**
     * Limit how many MessageThreads to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageThread upsert
   */
  export type MessageThreadUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageThread to update in case it exists.
     */
    where: MessageThreadWhereUniqueInput
    /**
     * In case the MessageThread found by the `where` argument doesn't exist, create a new MessageThread with this data.
     */
    create: XOR<MessageThreadCreateInput, MessageThreadUncheckedCreateInput>
    /**
     * In case the MessageThread was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageThreadUpdateInput, MessageThreadUncheckedUpdateInput>
  }

  /**
   * MessageThread delete
   */
  export type MessageThreadDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
    /**
     * Filter which MessageThread to delete.
     */
    where: MessageThreadWhereUniqueInput
  }

  /**
   * MessageThread deleteMany
   */
  export type MessageThreadDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageThreads to delete
     */
    where?: MessageThreadWhereInput
    /**
     * Limit how many MessageThreads to delete.
     */
    limit?: number
  }

  /**
   * MessageThread.participants
   */
  export type MessageThread$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    where?: ThreadParticipantWhereInput
    orderBy?: ThreadParticipantOrderByWithRelationInput | ThreadParticipantOrderByWithRelationInput[]
    cursor?: ThreadParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ThreadParticipantScalarFieldEnum | ThreadParticipantScalarFieldEnum[]
  }

  /**
   * MessageThread.messages
   */
  export type MessageThread$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * MessageThread without action
   */
  export type MessageThreadDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageThread
     */
    select?: MessageThreadSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageThread
     */
    omit?: MessageThreadOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageThreadInclude<ExtArgs> | null
  }


  /**
   * Model ThreadParticipant
   */

  export type AggregateThreadParticipant = {
    _count: ThreadParticipantCountAggregateOutputType | null
    _min: ThreadParticipantMinAggregateOutputType | null
    _max: ThreadParticipantMaxAggregateOutputType | null
  }

  export type ThreadParticipantMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    userId: string | null
    userType: $Enums.UserType | null
    createdAt: Date | null
  }

  export type ThreadParticipantMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    userId: string | null
    userType: $Enums.UserType | null
    createdAt: Date | null
  }

  export type ThreadParticipantCountAggregateOutputType = {
    id: number
    threadId: number
    userId: number
    userType: number
    createdAt: number
    _all: number
  }


  export type ThreadParticipantMinAggregateInputType = {
    id?: true
    threadId?: true
    userId?: true
    userType?: true
    createdAt?: true
  }

  export type ThreadParticipantMaxAggregateInputType = {
    id?: true
    threadId?: true
    userId?: true
    userType?: true
    createdAt?: true
  }

  export type ThreadParticipantCountAggregateInputType = {
    id?: true
    threadId?: true
    userId?: true
    userType?: true
    createdAt?: true
    _all?: true
  }

  export type ThreadParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreadParticipant to aggregate.
     */
    where?: ThreadParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadParticipants to fetch.
     */
    orderBy?: ThreadParticipantOrderByWithRelationInput | ThreadParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ThreadParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ThreadParticipants
    **/
    _count?: true | ThreadParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ThreadParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ThreadParticipantMaxAggregateInputType
  }

  export type GetThreadParticipantAggregateType<T extends ThreadParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregateThreadParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateThreadParticipant[P]>
      : GetScalarType<T[P], AggregateThreadParticipant[P]>
  }




  export type ThreadParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ThreadParticipantWhereInput
    orderBy?: ThreadParticipantOrderByWithAggregationInput | ThreadParticipantOrderByWithAggregationInput[]
    by: ThreadParticipantScalarFieldEnum[] | ThreadParticipantScalarFieldEnum
    having?: ThreadParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ThreadParticipantCountAggregateInputType | true
    _min?: ThreadParticipantMinAggregateInputType
    _max?: ThreadParticipantMaxAggregateInputType
  }

  export type ThreadParticipantGroupByOutputType = {
    id: string
    threadId: string
    userId: string
    userType: $Enums.UserType
    createdAt: Date
    _count: ThreadParticipantCountAggregateOutputType | null
    _min: ThreadParticipantMinAggregateOutputType | null
    _max: ThreadParticipantMaxAggregateOutputType | null
  }

  type GetThreadParticipantGroupByPayload<T extends ThreadParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ThreadParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ThreadParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ThreadParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], ThreadParticipantGroupByOutputType[P]>
        }
      >
    >


  export type ThreadParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    userId?: boolean
    userType?: boolean
    createdAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    staff?: boolean | ThreadParticipant$staffArgs<ExtArgs>
  }, ExtArgs["result"]["threadParticipant"]>

  export type ThreadParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    userId?: boolean
    userType?: boolean
    createdAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    staff?: boolean | ThreadParticipant$staffArgs<ExtArgs>
  }, ExtArgs["result"]["threadParticipant"]>

  export type ThreadParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    userId?: boolean
    userType?: boolean
    createdAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    staff?: boolean | ThreadParticipant$staffArgs<ExtArgs>
  }, ExtArgs["result"]["threadParticipant"]>

  export type ThreadParticipantSelectScalar = {
    id?: boolean
    threadId?: boolean
    userId?: boolean
    userType?: boolean
    createdAt?: boolean
  }

  export type ThreadParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "threadId" | "userId" | "userType" | "createdAt", ExtArgs["result"]["threadParticipant"]>
  export type ThreadParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    staff?: boolean | ThreadParticipant$staffArgs<ExtArgs>
  }
  export type ThreadParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    staff?: boolean | ThreadParticipant$staffArgs<ExtArgs>
  }
  export type ThreadParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    staff?: boolean | ThreadParticipant$staffArgs<ExtArgs>
  }

  export type $ThreadParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ThreadParticipant"
    objects: {
      thread: Prisma.$MessageThreadPayload<ExtArgs>
      staff: Prisma.$StaffProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      userId: string
      userType: $Enums.UserType
      createdAt: Date
    }, ExtArgs["result"]["threadParticipant"]>
    composites: {}
  }

  type ThreadParticipantGetPayload<S extends boolean | null | undefined | ThreadParticipantDefaultArgs> = $Result.GetResult<Prisma.$ThreadParticipantPayload, S>

  type ThreadParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ThreadParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ThreadParticipantCountAggregateInputType | true
    }

  export interface ThreadParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ThreadParticipant'], meta: { name: 'ThreadParticipant' } }
    /**
     * Find zero or one ThreadParticipant that matches the filter.
     * @param {ThreadParticipantFindUniqueArgs} args - Arguments to find a ThreadParticipant
     * @example
     * // Get one ThreadParticipant
     * const threadParticipant = await prisma.threadParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ThreadParticipantFindUniqueArgs>(args: SelectSubset<T, ThreadParticipantFindUniqueArgs<ExtArgs>>): Prisma__ThreadParticipantClient<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ThreadParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ThreadParticipantFindUniqueOrThrowArgs} args - Arguments to find a ThreadParticipant
     * @example
     * // Get one ThreadParticipant
     * const threadParticipant = await prisma.threadParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ThreadParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, ThreadParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ThreadParticipantClient<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThreadParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadParticipantFindFirstArgs} args - Arguments to find a ThreadParticipant
     * @example
     * // Get one ThreadParticipant
     * const threadParticipant = await prisma.threadParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ThreadParticipantFindFirstArgs>(args?: SelectSubset<T, ThreadParticipantFindFirstArgs<ExtArgs>>): Prisma__ThreadParticipantClient<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ThreadParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadParticipantFindFirstOrThrowArgs} args - Arguments to find a ThreadParticipant
     * @example
     * // Get one ThreadParticipant
     * const threadParticipant = await prisma.threadParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ThreadParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, ThreadParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__ThreadParticipantClient<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ThreadParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ThreadParticipants
     * const threadParticipants = await prisma.threadParticipant.findMany()
     * 
     * // Get first 10 ThreadParticipants
     * const threadParticipants = await prisma.threadParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const threadParticipantWithIdOnly = await prisma.threadParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ThreadParticipantFindManyArgs>(args?: SelectSubset<T, ThreadParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ThreadParticipant.
     * @param {ThreadParticipantCreateArgs} args - Arguments to create a ThreadParticipant.
     * @example
     * // Create one ThreadParticipant
     * const ThreadParticipant = await prisma.threadParticipant.create({
     *   data: {
     *     // ... data to create a ThreadParticipant
     *   }
     * })
     * 
     */
    create<T extends ThreadParticipantCreateArgs>(args: SelectSubset<T, ThreadParticipantCreateArgs<ExtArgs>>): Prisma__ThreadParticipantClient<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ThreadParticipants.
     * @param {ThreadParticipantCreateManyArgs} args - Arguments to create many ThreadParticipants.
     * @example
     * // Create many ThreadParticipants
     * const threadParticipant = await prisma.threadParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ThreadParticipantCreateManyArgs>(args?: SelectSubset<T, ThreadParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ThreadParticipants and returns the data saved in the database.
     * @param {ThreadParticipantCreateManyAndReturnArgs} args - Arguments to create many ThreadParticipants.
     * @example
     * // Create many ThreadParticipants
     * const threadParticipant = await prisma.threadParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ThreadParticipants and only return the `id`
     * const threadParticipantWithIdOnly = await prisma.threadParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ThreadParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, ThreadParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ThreadParticipant.
     * @param {ThreadParticipantDeleteArgs} args - Arguments to delete one ThreadParticipant.
     * @example
     * // Delete one ThreadParticipant
     * const ThreadParticipant = await prisma.threadParticipant.delete({
     *   where: {
     *     // ... filter to delete one ThreadParticipant
     *   }
     * })
     * 
     */
    delete<T extends ThreadParticipantDeleteArgs>(args: SelectSubset<T, ThreadParticipantDeleteArgs<ExtArgs>>): Prisma__ThreadParticipantClient<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ThreadParticipant.
     * @param {ThreadParticipantUpdateArgs} args - Arguments to update one ThreadParticipant.
     * @example
     * // Update one ThreadParticipant
     * const threadParticipant = await prisma.threadParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ThreadParticipantUpdateArgs>(args: SelectSubset<T, ThreadParticipantUpdateArgs<ExtArgs>>): Prisma__ThreadParticipantClient<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ThreadParticipants.
     * @param {ThreadParticipantDeleteManyArgs} args - Arguments to filter ThreadParticipants to delete.
     * @example
     * // Delete a few ThreadParticipants
     * const { count } = await prisma.threadParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ThreadParticipantDeleteManyArgs>(args?: SelectSubset<T, ThreadParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreadParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ThreadParticipants
     * const threadParticipant = await prisma.threadParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ThreadParticipantUpdateManyArgs>(args: SelectSubset<T, ThreadParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ThreadParticipants and returns the data updated in the database.
     * @param {ThreadParticipantUpdateManyAndReturnArgs} args - Arguments to update many ThreadParticipants.
     * @example
     * // Update many ThreadParticipants
     * const threadParticipant = await prisma.threadParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ThreadParticipants and only return the `id`
     * const threadParticipantWithIdOnly = await prisma.threadParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ThreadParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, ThreadParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ThreadParticipant.
     * @param {ThreadParticipantUpsertArgs} args - Arguments to update or create a ThreadParticipant.
     * @example
     * // Update or create a ThreadParticipant
     * const threadParticipant = await prisma.threadParticipant.upsert({
     *   create: {
     *     // ... data to create a ThreadParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ThreadParticipant we want to update
     *   }
     * })
     */
    upsert<T extends ThreadParticipantUpsertArgs>(args: SelectSubset<T, ThreadParticipantUpsertArgs<ExtArgs>>): Prisma__ThreadParticipantClient<$Result.GetResult<Prisma.$ThreadParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ThreadParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadParticipantCountArgs} args - Arguments to filter ThreadParticipants to count.
     * @example
     * // Count the number of ThreadParticipants
     * const count = await prisma.threadParticipant.count({
     *   where: {
     *     // ... the filter for the ThreadParticipants we want to count
     *   }
     * })
    **/
    count<T extends ThreadParticipantCountArgs>(
      args?: Subset<T, ThreadParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ThreadParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ThreadParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ThreadParticipantAggregateArgs>(args: Subset<T, ThreadParticipantAggregateArgs>): Prisma.PrismaPromise<GetThreadParticipantAggregateType<T>>

    /**
     * Group by ThreadParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ThreadParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ThreadParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ThreadParticipantGroupByArgs['orderBy'] }
        : { orderBy?: ThreadParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ThreadParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetThreadParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ThreadParticipant model
   */
  readonly fields: ThreadParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ThreadParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ThreadParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends MessageThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageThreadDefaultArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends ThreadParticipant$staffArgs<ExtArgs> = {}>(args?: Subset<T, ThreadParticipant$staffArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ThreadParticipant model
   */
  interface ThreadParticipantFieldRefs {
    readonly id: FieldRef<"ThreadParticipant", 'String'>
    readonly threadId: FieldRef<"ThreadParticipant", 'String'>
    readonly userId: FieldRef<"ThreadParticipant", 'String'>
    readonly userType: FieldRef<"ThreadParticipant", 'UserType'>
    readonly createdAt: FieldRef<"ThreadParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ThreadParticipant findUnique
   */
  export type ThreadParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ThreadParticipant to fetch.
     */
    where: ThreadParticipantWhereUniqueInput
  }

  /**
   * ThreadParticipant findUniqueOrThrow
   */
  export type ThreadParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ThreadParticipant to fetch.
     */
    where: ThreadParticipantWhereUniqueInput
  }

  /**
   * ThreadParticipant findFirst
   */
  export type ThreadParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ThreadParticipant to fetch.
     */
    where?: ThreadParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadParticipants to fetch.
     */
    orderBy?: ThreadParticipantOrderByWithRelationInput | ThreadParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadParticipants.
     */
    cursor?: ThreadParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadParticipants.
     */
    distinct?: ThreadParticipantScalarFieldEnum | ThreadParticipantScalarFieldEnum[]
  }

  /**
   * ThreadParticipant findFirstOrThrow
   */
  export type ThreadParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ThreadParticipant to fetch.
     */
    where?: ThreadParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadParticipants to fetch.
     */
    orderBy?: ThreadParticipantOrderByWithRelationInput | ThreadParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ThreadParticipants.
     */
    cursor?: ThreadParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ThreadParticipants.
     */
    distinct?: ThreadParticipantScalarFieldEnum | ThreadParticipantScalarFieldEnum[]
  }

  /**
   * ThreadParticipant findMany
   */
  export type ThreadParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter, which ThreadParticipants to fetch.
     */
    where?: ThreadParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ThreadParticipants to fetch.
     */
    orderBy?: ThreadParticipantOrderByWithRelationInput | ThreadParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ThreadParticipants.
     */
    cursor?: ThreadParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ThreadParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ThreadParticipants.
     */
    skip?: number
    distinct?: ThreadParticipantScalarFieldEnum | ThreadParticipantScalarFieldEnum[]
  }

  /**
   * ThreadParticipant create
   */
  export type ThreadParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a ThreadParticipant.
     */
    data: XOR<ThreadParticipantCreateInput, ThreadParticipantUncheckedCreateInput>
  }

  /**
   * ThreadParticipant createMany
   */
  export type ThreadParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ThreadParticipants.
     */
    data: ThreadParticipantCreateManyInput | ThreadParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ThreadParticipant createManyAndReturn
   */
  export type ThreadParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many ThreadParticipants.
     */
    data: ThreadParticipantCreateManyInput | ThreadParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThreadParticipant update
   */
  export type ThreadParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a ThreadParticipant.
     */
    data: XOR<ThreadParticipantUpdateInput, ThreadParticipantUncheckedUpdateInput>
    /**
     * Choose, which ThreadParticipant to update.
     */
    where: ThreadParticipantWhereUniqueInput
  }

  /**
   * ThreadParticipant updateMany
   */
  export type ThreadParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ThreadParticipants.
     */
    data: XOR<ThreadParticipantUpdateManyMutationInput, ThreadParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ThreadParticipants to update
     */
    where?: ThreadParticipantWhereInput
    /**
     * Limit how many ThreadParticipants to update.
     */
    limit?: number
  }

  /**
   * ThreadParticipant updateManyAndReturn
   */
  export type ThreadParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * The data used to update ThreadParticipants.
     */
    data: XOR<ThreadParticipantUpdateManyMutationInput, ThreadParticipantUncheckedUpdateManyInput>
    /**
     * Filter which ThreadParticipants to update
     */
    where?: ThreadParticipantWhereInput
    /**
     * Limit how many ThreadParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ThreadParticipant upsert
   */
  export type ThreadParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the ThreadParticipant to update in case it exists.
     */
    where: ThreadParticipantWhereUniqueInput
    /**
     * In case the ThreadParticipant found by the `where` argument doesn't exist, create a new ThreadParticipant with this data.
     */
    create: XOR<ThreadParticipantCreateInput, ThreadParticipantUncheckedCreateInput>
    /**
     * In case the ThreadParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ThreadParticipantUpdateInput, ThreadParticipantUncheckedUpdateInput>
  }

  /**
   * ThreadParticipant delete
   */
  export type ThreadParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
    /**
     * Filter which ThreadParticipant to delete.
     */
    where: ThreadParticipantWhereUniqueInput
  }

  /**
   * ThreadParticipant deleteMany
   */
  export type ThreadParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ThreadParticipants to delete
     */
    where?: ThreadParticipantWhereInput
    /**
     * Limit how many ThreadParticipants to delete.
     */
    limit?: number
  }

  /**
   * ThreadParticipant.staff
   */
  export type ThreadParticipant$staffArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * ThreadParticipant without action
   */
  export type ThreadParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ThreadParticipant
     */
    select?: ThreadParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ThreadParticipant
     */
    omit?: ThreadParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ThreadParticipantInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    threadId: string | null
    senderId: string | null
    senderType: $Enums.UserType | null
    content: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    threadId: string | null
    senderId: string | null
    senderType: $Enums.UserType | null
    content: string | null
    read: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    threadId: number
    senderId: number
    senderType: number
    content: number
    read: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    senderType?: true
    content?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    senderType?: true
    content?: true
    read?: true
    createdAt?: true
    updatedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    threadId?: true
    senderId?: true
    senderType?: true
    content?: true
    read?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    threadId: string
    senderId: string
    senderType: $Enums.UserType
    content: string
    read: boolean
    createdAt: Date
    updatedAt: Date
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    threadId?: boolean
    senderId?: boolean
    senderType?: boolean
    content?: boolean
    read?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "threadId" | "senderId" | "senderType" | "content" | "read" | "createdAt" | "updatedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    thread?: boolean | MessageThreadDefaultArgs<ExtArgs>
    sender?: boolean | Message$senderArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      thread: Prisma.$MessageThreadPayload<ExtArgs>
      sender: Prisma.$StaffProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      threadId: string
      senderId: string
      senderType: $Enums.UserType
      content: string
      read: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    thread<T extends MessageThreadDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageThreadDefaultArgs<ExtArgs>>): Prisma__MessageThreadClient<$Result.GetResult<Prisma.$MessageThreadPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends Message$senderArgs<ExtArgs> = {}>(args?: Subset<T, Message$senderArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly threadId: FieldRef<"Message", 'String'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly senderType: FieldRef<"Message", 'UserType'>
    readonly content: FieldRef<"Message", 'String'>
    readonly read: FieldRef<"Message", 'Boolean'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.sender
   */
  export type Message$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StaffProfile
     */
    select?: StaffProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StaffProfile
     */
    omit?: StaffProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StaffProfileInclude<ExtArgs> | null
    where?: StaffProfileWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model ReminderState
   */

  export type AggregateReminderState = {
    _count: ReminderStateCountAggregateOutputType | null
    _avg: ReminderStateAvgAggregateOutputType | null
    _sum: ReminderStateSumAggregateOutputType | null
    _min: ReminderStateMinAggregateOutputType | null
    _max: ReminderStateMaxAggregateOutputType | null
  }

  export type ReminderStateAvgAggregateOutputType = {
    reminderCount: number | null
  }

  export type ReminderStateSumAggregateOutputType = {
    reminderCount: number | null
  }

  export type ReminderStateMinAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    reminderType: $Enums.ReminderType | null
    nextReminderAt: Date | null
    lastReminderAt: Date | null
    reminderCount: number | null
    paused: boolean | null
    pausedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReminderStateMaxAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    reminderType: $Enums.ReminderType | null
    nextReminderAt: Date | null
    lastReminderAt: Date | null
    reminderCount: number | null
    paused: boolean | null
    pausedReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReminderStateCountAggregateOutputType = {
    id: number
    entityTaxYearId: number
    reminderType: number
    nextReminderAt: number
    lastReminderAt: number
    reminderCount: number
    paused: number
    pausedReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReminderStateAvgAggregateInputType = {
    reminderCount?: true
  }

  export type ReminderStateSumAggregateInputType = {
    reminderCount?: true
  }

  export type ReminderStateMinAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    reminderType?: true
    nextReminderAt?: true
    lastReminderAt?: true
    reminderCount?: true
    paused?: true
    pausedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReminderStateMaxAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    reminderType?: true
    nextReminderAt?: true
    lastReminderAt?: true
    reminderCount?: true
    paused?: true
    pausedReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReminderStateCountAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    reminderType?: true
    nextReminderAt?: true
    lastReminderAt?: true
    reminderCount?: true
    paused?: true
    pausedReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReminderStateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReminderState to aggregate.
     */
    where?: ReminderStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderStates to fetch.
     */
    orderBy?: ReminderStateOrderByWithRelationInput | ReminderStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReminderStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReminderStates
    **/
    _count?: true | ReminderStateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReminderStateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReminderStateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReminderStateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReminderStateMaxAggregateInputType
  }

  export type GetReminderStateAggregateType<T extends ReminderStateAggregateArgs> = {
        [P in keyof T & keyof AggregateReminderState]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReminderState[P]>
      : GetScalarType<T[P], AggregateReminderState[P]>
  }




  export type ReminderStateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReminderStateWhereInput
    orderBy?: ReminderStateOrderByWithAggregationInput | ReminderStateOrderByWithAggregationInput[]
    by: ReminderStateScalarFieldEnum[] | ReminderStateScalarFieldEnum
    having?: ReminderStateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReminderStateCountAggregateInputType | true
    _avg?: ReminderStateAvgAggregateInputType
    _sum?: ReminderStateSumAggregateInputType
    _min?: ReminderStateMinAggregateInputType
    _max?: ReminderStateMaxAggregateInputType
  }

  export type ReminderStateGroupByOutputType = {
    id: string
    entityTaxYearId: string
    reminderType: $Enums.ReminderType
    nextReminderAt: Date | null
    lastReminderAt: Date | null
    reminderCount: number
    paused: boolean
    pausedReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: ReminderStateCountAggregateOutputType | null
    _avg: ReminderStateAvgAggregateOutputType | null
    _sum: ReminderStateSumAggregateOutputType | null
    _min: ReminderStateMinAggregateOutputType | null
    _max: ReminderStateMaxAggregateOutputType | null
  }

  type GetReminderStateGroupByPayload<T extends ReminderStateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReminderStateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReminderStateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReminderStateGroupByOutputType[P]>
            : GetScalarType<T[P], ReminderStateGroupByOutputType[P]>
        }
      >
    >


  export type ReminderStateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    reminderType?: boolean
    nextReminderAt?: boolean
    lastReminderAt?: boolean
    reminderCount?: boolean
    paused?: boolean
    pausedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminderState"]>

  export type ReminderStateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    reminderType?: boolean
    nextReminderAt?: boolean
    lastReminderAt?: boolean
    reminderCount?: boolean
    paused?: boolean
    pausedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminderState"]>

  export type ReminderStateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    reminderType?: boolean
    nextReminderAt?: boolean
    lastReminderAt?: boolean
    reminderCount?: boolean
    paused?: boolean
    pausedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reminderState"]>

  export type ReminderStateSelectScalar = {
    id?: boolean
    entityTaxYearId?: boolean
    reminderType?: boolean
    nextReminderAt?: boolean
    lastReminderAt?: boolean
    reminderCount?: boolean
    paused?: boolean
    pausedReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReminderStateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityTaxYearId" | "reminderType" | "nextReminderAt" | "lastReminderAt" | "reminderCount" | "paused" | "pausedReason" | "createdAt" | "updatedAt", ExtArgs["result"]["reminderState"]>
  export type ReminderStateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type ReminderStateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type ReminderStateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }

  export type $ReminderStatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReminderState"
    objects: {
      entityTaxYear: Prisma.$EntityTaxYearPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityTaxYearId: string
      reminderType: $Enums.ReminderType
      nextReminderAt: Date | null
      lastReminderAt: Date | null
      reminderCount: number
      paused: boolean
      pausedReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reminderState"]>
    composites: {}
  }

  type ReminderStateGetPayload<S extends boolean | null | undefined | ReminderStateDefaultArgs> = $Result.GetResult<Prisma.$ReminderStatePayload, S>

  type ReminderStateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReminderStateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReminderStateCountAggregateInputType | true
    }

  export interface ReminderStateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReminderState'], meta: { name: 'ReminderState' } }
    /**
     * Find zero or one ReminderState that matches the filter.
     * @param {ReminderStateFindUniqueArgs} args - Arguments to find a ReminderState
     * @example
     * // Get one ReminderState
     * const reminderState = await prisma.reminderState.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReminderStateFindUniqueArgs>(args: SelectSubset<T, ReminderStateFindUniqueArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReminderState that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReminderStateFindUniqueOrThrowArgs} args - Arguments to find a ReminderState
     * @example
     * // Get one ReminderState
     * const reminderState = await prisma.reminderState.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReminderStateFindUniqueOrThrowArgs>(args: SelectSubset<T, ReminderStateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReminderState that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderStateFindFirstArgs} args - Arguments to find a ReminderState
     * @example
     * // Get one ReminderState
     * const reminderState = await prisma.reminderState.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReminderStateFindFirstArgs>(args?: SelectSubset<T, ReminderStateFindFirstArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReminderState that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderStateFindFirstOrThrowArgs} args - Arguments to find a ReminderState
     * @example
     * // Get one ReminderState
     * const reminderState = await prisma.reminderState.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReminderStateFindFirstOrThrowArgs>(args?: SelectSubset<T, ReminderStateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReminderStates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderStateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReminderStates
     * const reminderStates = await prisma.reminderState.findMany()
     * 
     * // Get first 10 ReminderStates
     * const reminderStates = await prisma.reminderState.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reminderStateWithIdOnly = await prisma.reminderState.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReminderStateFindManyArgs>(args?: SelectSubset<T, ReminderStateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReminderState.
     * @param {ReminderStateCreateArgs} args - Arguments to create a ReminderState.
     * @example
     * // Create one ReminderState
     * const ReminderState = await prisma.reminderState.create({
     *   data: {
     *     // ... data to create a ReminderState
     *   }
     * })
     * 
     */
    create<T extends ReminderStateCreateArgs>(args: SelectSubset<T, ReminderStateCreateArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReminderStates.
     * @param {ReminderStateCreateManyArgs} args - Arguments to create many ReminderStates.
     * @example
     * // Create many ReminderStates
     * const reminderState = await prisma.reminderState.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReminderStateCreateManyArgs>(args?: SelectSubset<T, ReminderStateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReminderStates and returns the data saved in the database.
     * @param {ReminderStateCreateManyAndReturnArgs} args - Arguments to create many ReminderStates.
     * @example
     * // Create many ReminderStates
     * const reminderState = await prisma.reminderState.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReminderStates and only return the `id`
     * const reminderStateWithIdOnly = await prisma.reminderState.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReminderStateCreateManyAndReturnArgs>(args?: SelectSubset<T, ReminderStateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReminderState.
     * @param {ReminderStateDeleteArgs} args - Arguments to delete one ReminderState.
     * @example
     * // Delete one ReminderState
     * const ReminderState = await prisma.reminderState.delete({
     *   where: {
     *     // ... filter to delete one ReminderState
     *   }
     * })
     * 
     */
    delete<T extends ReminderStateDeleteArgs>(args: SelectSubset<T, ReminderStateDeleteArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReminderState.
     * @param {ReminderStateUpdateArgs} args - Arguments to update one ReminderState.
     * @example
     * // Update one ReminderState
     * const reminderState = await prisma.reminderState.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReminderStateUpdateArgs>(args: SelectSubset<T, ReminderStateUpdateArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReminderStates.
     * @param {ReminderStateDeleteManyArgs} args - Arguments to filter ReminderStates to delete.
     * @example
     * // Delete a few ReminderStates
     * const { count } = await prisma.reminderState.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReminderStateDeleteManyArgs>(args?: SelectSubset<T, ReminderStateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReminderStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderStateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReminderStates
     * const reminderState = await prisma.reminderState.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReminderStateUpdateManyArgs>(args: SelectSubset<T, ReminderStateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReminderStates and returns the data updated in the database.
     * @param {ReminderStateUpdateManyAndReturnArgs} args - Arguments to update many ReminderStates.
     * @example
     * // Update many ReminderStates
     * const reminderState = await prisma.reminderState.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReminderStates and only return the `id`
     * const reminderStateWithIdOnly = await prisma.reminderState.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReminderStateUpdateManyAndReturnArgs>(args: SelectSubset<T, ReminderStateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReminderState.
     * @param {ReminderStateUpsertArgs} args - Arguments to update or create a ReminderState.
     * @example
     * // Update or create a ReminderState
     * const reminderState = await prisma.reminderState.upsert({
     *   create: {
     *     // ... data to create a ReminderState
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReminderState we want to update
     *   }
     * })
     */
    upsert<T extends ReminderStateUpsertArgs>(args: SelectSubset<T, ReminderStateUpsertArgs<ExtArgs>>): Prisma__ReminderStateClient<$Result.GetResult<Prisma.$ReminderStatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReminderStates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderStateCountArgs} args - Arguments to filter ReminderStates to count.
     * @example
     * // Count the number of ReminderStates
     * const count = await prisma.reminderState.count({
     *   where: {
     *     // ... the filter for the ReminderStates we want to count
     *   }
     * })
    **/
    count<T extends ReminderStateCountArgs>(
      args?: Subset<T, ReminderStateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReminderStateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReminderState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderStateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReminderStateAggregateArgs>(args: Subset<T, ReminderStateAggregateArgs>): Prisma.PrismaPromise<GetReminderStateAggregateType<T>>

    /**
     * Group by ReminderState.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReminderStateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReminderStateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReminderStateGroupByArgs['orderBy'] }
        : { orderBy?: ReminderStateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReminderStateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReminderStateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReminderState model
   */
  readonly fields: ReminderStateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReminderState.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReminderStateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityTaxYear<T extends EntityTaxYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYearDefaultArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReminderState model
   */
  interface ReminderStateFieldRefs {
    readonly id: FieldRef<"ReminderState", 'String'>
    readonly entityTaxYearId: FieldRef<"ReminderState", 'String'>
    readonly reminderType: FieldRef<"ReminderState", 'ReminderType'>
    readonly nextReminderAt: FieldRef<"ReminderState", 'DateTime'>
    readonly lastReminderAt: FieldRef<"ReminderState", 'DateTime'>
    readonly reminderCount: FieldRef<"ReminderState", 'Int'>
    readonly paused: FieldRef<"ReminderState", 'Boolean'>
    readonly pausedReason: FieldRef<"ReminderState", 'String'>
    readonly createdAt: FieldRef<"ReminderState", 'DateTime'>
    readonly updatedAt: FieldRef<"ReminderState", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReminderState findUnique
   */
  export type ReminderStateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * Filter, which ReminderState to fetch.
     */
    where: ReminderStateWhereUniqueInput
  }

  /**
   * ReminderState findUniqueOrThrow
   */
  export type ReminderStateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * Filter, which ReminderState to fetch.
     */
    where: ReminderStateWhereUniqueInput
  }

  /**
   * ReminderState findFirst
   */
  export type ReminderStateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * Filter, which ReminderState to fetch.
     */
    where?: ReminderStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderStates to fetch.
     */
    orderBy?: ReminderStateOrderByWithRelationInput | ReminderStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReminderStates.
     */
    cursor?: ReminderStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReminderStates.
     */
    distinct?: ReminderStateScalarFieldEnum | ReminderStateScalarFieldEnum[]
  }

  /**
   * ReminderState findFirstOrThrow
   */
  export type ReminderStateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * Filter, which ReminderState to fetch.
     */
    where?: ReminderStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderStates to fetch.
     */
    orderBy?: ReminderStateOrderByWithRelationInput | ReminderStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReminderStates.
     */
    cursor?: ReminderStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderStates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReminderStates.
     */
    distinct?: ReminderStateScalarFieldEnum | ReminderStateScalarFieldEnum[]
  }

  /**
   * ReminderState findMany
   */
  export type ReminderStateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * Filter, which ReminderStates to fetch.
     */
    where?: ReminderStateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReminderStates to fetch.
     */
    orderBy?: ReminderStateOrderByWithRelationInput | ReminderStateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReminderStates.
     */
    cursor?: ReminderStateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReminderStates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReminderStates.
     */
    skip?: number
    distinct?: ReminderStateScalarFieldEnum | ReminderStateScalarFieldEnum[]
  }

  /**
   * ReminderState create
   */
  export type ReminderStateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * The data needed to create a ReminderState.
     */
    data: XOR<ReminderStateCreateInput, ReminderStateUncheckedCreateInput>
  }

  /**
   * ReminderState createMany
   */
  export type ReminderStateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReminderStates.
     */
    data: ReminderStateCreateManyInput | ReminderStateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReminderState createManyAndReturn
   */
  export type ReminderStateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * The data used to create many ReminderStates.
     */
    data: ReminderStateCreateManyInput | ReminderStateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReminderState update
   */
  export type ReminderStateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * The data needed to update a ReminderState.
     */
    data: XOR<ReminderStateUpdateInput, ReminderStateUncheckedUpdateInput>
    /**
     * Choose, which ReminderState to update.
     */
    where: ReminderStateWhereUniqueInput
  }

  /**
   * ReminderState updateMany
   */
  export type ReminderStateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReminderStates.
     */
    data: XOR<ReminderStateUpdateManyMutationInput, ReminderStateUncheckedUpdateManyInput>
    /**
     * Filter which ReminderStates to update
     */
    where?: ReminderStateWhereInput
    /**
     * Limit how many ReminderStates to update.
     */
    limit?: number
  }

  /**
   * ReminderState updateManyAndReturn
   */
  export type ReminderStateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * The data used to update ReminderStates.
     */
    data: XOR<ReminderStateUpdateManyMutationInput, ReminderStateUncheckedUpdateManyInput>
    /**
     * Filter which ReminderStates to update
     */
    where?: ReminderStateWhereInput
    /**
     * Limit how many ReminderStates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReminderState upsert
   */
  export type ReminderStateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * The filter to search for the ReminderState to update in case it exists.
     */
    where: ReminderStateWhereUniqueInput
    /**
     * In case the ReminderState found by the `where` argument doesn't exist, create a new ReminderState with this data.
     */
    create: XOR<ReminderStateCreateInput, ReminderStateUncheckedCreateInput>
    /**
     * In case the ReminderState was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReminderStateUpdateInput, ReminderStateUncheckedUpdateInput>
  }

  /**
   * ReminderState delete
   */
  export type ReminderStateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
    /**
     * Filter which ReminderState to delete.
     */
    where: ReminderStateWhereUniqueInput
  }

  /**
   * ReminderState deleteMany
   */
  export type ReminderStateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReminderStates to delete
     */
    where?: ReminderStateWhereInput
    /**
     * Limit how many ReminderStates to delete.
     */
    limit?: number
  }

  /**
   * ReminderState without action
   */
  export type ReminderStateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReminderState
     */
    select?: ReminderStateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReminderState
     */
    omit?: ReminderStateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReminderStateInclude<ExtArgs> | null
  }


  /**
   * Model StatusAuditLog
   */

  export type AggregateStatusAuditLog = {
    _count: StatusAuditLogCountAggregateOutputType | null
    _min: StatusAuditLogMinAggregateOutputType | null
    _max: StatusAuditLogMaxAggregateOutputType | null
  }

  export type StatusAuditLogMinAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    oldStatus: string | null
    newStatus: string | null
    changedBy: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type StatusAuditLogMaxAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    oldStatus: string | null
    newStatus: string | null
    changedBy: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type StatusAuditLogCountAggregateOutputType = {
    id: number
    entityTaxYearId: number
    oldStatus: number
    newStatus: number
    changedBy: number
    reason: number
    createdAt: number
    _all: number
  }


  export type StatusAuditLogMinAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    reason?: true
    createdAt?: true
  }

  export type StatusAuditLogMaxAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    reason?: true
    createdAt?: true
  }

  export type StatusAuditLogCountAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    oldStatus?: true
    newStatus?: true
    changedBy?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type StatusAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusAuditLog to aggregate.
     */
    where?: StatusAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusAuditLogs to fetch.
     */
    orderBy?: StatusAuditLogOrderByWithRelationInput | StatusAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StatusAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StatusAuditLogs
    **/
    _count?: true | StatusAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatusAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatusAuditLogMaxAggregateInputType
  }

  export type GetStatusAuditLogAggregateType<T extends StatusAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateStatusAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStatusAuditLog[P]>
      : GetScalarType<T[P], AggregateStatusAuditLog[P]>
  }




  export type StatusAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StatusAuditLogWhereInput
    orderBy?: StatusAuditLogOrderByWithAggregationInput | StatusAuditLogOrderByWithAggregationInput[]
    by: StatusAuditLogScalarFieldEnum[] | StatusAuditLogScalarFieldEnum
    having?: StatusAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatusAuditLogCountAggregateInputType | true
    _min?: StatusAuditLogMinAggregateInputType
    _max?: StatusAuditLogMaxAggregateInputType
  }

  export type StatusAuditLogGroupByOutputType = {
    id: string
    entityTaxYearId: string
    oldStatus: string | null
    newStatus: string
    changedBy: string
    reason: string | null
    createdAt: Date
    _count: StatusAuditLogCountAggregateOutputType | null
    _min: StatusAuditLogMinAggregateOutputType | null
    _max: StatusAuditLogMaxAggregateOutputType | null
  }

  type GetStatusAuditLogGroupByPayload<T extends StatusAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatusAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatusAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatusAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], StatusAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type StatusAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    reason?: boolean
    createdAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusAuditLog"]>

  export type StatusAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    reason?: boolean
    createdAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusAuditLog"]>

  export type StatusAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    reason?: boolean
    createdAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["statusAuditLog"]>

  export type StatusAuditLogSelectScalar = {
    id?: boolean
    entityTaxYearId?: boolean
    oldStatus?: boolean
    newStatus?: boolean
    changedBy?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type StatusAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityTaxYearId" | "oldStatus" | "newStatus" | "changedBy" | "reason" | "createdAt", ExtArgs["result"]["statusAuditLog"]>
  export type StatusAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type StatusAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type StatusAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $StatusAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StatusAuditLog"
    objects: {
      entityTaxYear: Prisma.$EntityTaxYearPayload<ExtArgs>
      staff: Prisma.$StaffProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityTaxYearId: string
      oldStatus: string | null
      newStatus: string
      changedBy: string
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["statusAuditLog"]>
    composites: {}
  }

  type StatusAuditLogGetPayload<S extends boolean | null | undefined | StatusAuditLogDefaultArgs> = $Result.GetResult<Prisma.$StatusAuditLogPayload, S>

  type StatusAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StatusAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatusAuditLogCountAggregateInputType | true
    }

  export interface StatusAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StatusAuditLog'], meta: { name: 'StatusAuditLog' } }
    /**
     * Find zero or one StatusAuditLog that matches the filter.
     * @param {StatusAuditLogFindUniqueArgs} args - Arguments to find a StatusAuditLog
     * @example
     * // Get one StatusAuditLog
     * const statusAuditLog = await prisma.statusAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StatusAuditLogFindUniqueArgs>(args: SelectSubset<T, StatusAuditLogFindUniqueArgs<ExtArgs>>): Prisma__StatusAuditLogClient<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StatusAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StatusAuditLogFindUniqueOrThrowArgs} args - Arguments to find a StatusAuditLog
     * @example
     * // Get one StatusAuditLog
     * const statusAuditLog = await prisma.statusAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StatusAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, StatusAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StatusAuditLogClient<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatusAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAuditLogFindFirstArgs} args - Arguments to find a StatusAuditLog
     * @example
     * // Get one StatusAuditLog
     * const statusAuditLog = await prisma.statusAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StatusAuditLogFindFirstArgs>(args?: SelectSubset<T, StatusAuditLogFindFirstArgs<ExtArgs>>): Prisma__StatusAuditLogClient<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StatusAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAuditLogFindFirstOrThrowArgs} args - Arguments to find a StatusAuditLog
     * @example
     * // Get one StatusAuditLog
     * const statusAuditLog = await prisma.statusAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StatusAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, StatusAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__StatusAuditLogClient<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StatusAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StatusAuditLogs
     * const statusAuditLogs = await prisma.statusAuditLog.findMany()
     * 
     * // Get first 10 StatusAuditLogs
     * const statusAuditLogs = await prisma.statusAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statusAuditLogWithIdOnly = await prisma.statusAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StatusAuditLogFindManyArgs>(args?: SelectSubset<T, StatusAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StatusAuditLog.
     * @param {StatusAuditLogCreateArgs} args - Arguments to create a StatusAuditLog.
     * @example
     * // Create one StatusAuditLog
     * const StatusAuditLog = await prisma.statusAuditLog.create({
     *   data: {
     *     // ... data to create a StatusAuditLog
     *   }
     * })
     * 
     */
    create<T extends StatusAuditLogCreateArgs>(args: SelectSubset<T, StatusAuditLogCreateArgs<ExtArgs>>): Prisma__StatusAuditLogClient<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StatusAuditLogs.
     * @param {StatusAuditLogCreateManyArgs} args - Arguments to create many StatusAuditLogs.
     * @example
     * // Create many StatusAuditLogs
     * const statusAuditLog = await prisma.statusAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StatusAuditLogCreateManyArgs>(args?: SelectSubset<T, StatusAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StatusAuditLogs and returns the data saved in the database.
     * @param {StatusAuditLogCreateManyAndReturnArgs} args - Arguments to create many StatusAuditLogs.
     * @example
     * // Create many StatusAuditLogs
     * const statusAuditLog = await prisma.statusAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StatusAuditLogs and only return the `id`
     * const statusAuditLogWithIdOnly = await prisma.statusAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StatusAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, StatusAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StatusAuditLog.
     * @param {StatusAuditLogDeleteArgs} args - Arguments to delete one StatusAuditLog.
     * @example
     * // Delete one StatusAuditLog
     * const StatusAuditLog = await prisma.statusAuditLog.delete({
     *   where: {
     *     // ... filter to delete one StatusAuditLog
     *   }
     * })
     * 
     */
    delete<T extends StatusAuditLogDeleteArgs>(args: SelectSubset<T, StatusAuditLogDeleteArgs<ExtArgs>>): Prisma__StatusAuditLogClient<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StatusAuditLog.
     * @param {StatusAuditLogUpdateArgs} args - Arguments to update one StatusAuditLog.
     * @example
     * // Update one StatusAuditLog
     * const statusAuditLog = await prisma.statusAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StatusAuditLogUpdateArgs>(args: SelectSubset<T, StatusAuditLogUpdateArgs<ExtArgs>>): Prisma__StatusAuditLogClient<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StatusAuditLogs.
     * @param {StatusAuditLogDeleteManyArgs} args - Arguments to filter StatusAuditLogs to delete.
     * @example
     * // Delete a few StatusAuditLogs
     * const { count } = await prisma.statusAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StatusAuditLogDeleteManyArgs>(args?: SelectSubset<T, StatusAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StatusAuditLogs
     * const statusAuditLog = await prisma.statusAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StatusAuditLogUpdateManyArgs>(args: SelectSubset<T, StatusAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StatusAuditLogs and returns the data updated in the database.
     * @param {StatusAuditLogUpdateManyAndReturnArgs} args - Arguments to update many StatusAuditLogs.
     * @example
     * // Update many StatusAuditLogs
     * const statusAuditLog = await prisma.statusAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StatusAuditLogs and only return the `id`
     * const statusAuditLogWithIdOnly = await prisma.statusAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StatusAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, StatusAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StatusAuditLog.
     * @param {StatusAuditLogUpsertArgs} args - Arguments to update or create a StatusAuditLog.
     * @example
     * // Update or create a StatusAuditLog
     * const statusAuditLog = await prisma.statusAuditLog.upsert({
     *   create: {
     *     // ... data to create a StatusAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StatusAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends StatusAuditLogUpsertArgs>(args: SelectSubset<T, StatusAuditLogUpsertArgs<ExtArgs>>): Prisma__StatusAuditLogClient<$Result.GetResult<Prisma.$StatusAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StatusAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAuditLogCountArgs} args - Arguments to filter StatusAuditLogs to count.
     * @example
     * // Count the number of StatusAuditLogs
     * const count = await prisma.statusAuditLog.count({
     *   where: {
     *     // ... the filter for the StatusAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends StatusAuditLogCountArgs>(
      args?: Subset<T, StatusAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatusAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StatusAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatusAuditLogAggregateArgs>(args: Subset<T, StatusAuditLogAggregateArgs>): Prisma.PrismaPromise<GetStatusAuditLogAggregateType<T>>

    /**
     * Group by StatusAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatusAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StatusAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StatusAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: StatusAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StatusAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatusAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StatusAuditLog model
   */
  readonly fields: StatusAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StatusAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StatusAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityTaxYear<T extends EntityTaxYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYearDefaultArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    staff<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StatusAuditLog model
   */
  interface StatusAuditLogFieldRefs {
    readonly id: FieldRef<"StatusAuditLog", 'String'>
    readonly entityTaxYearId: FieldRef<"StatusAuditLog", 'String'>
    readonly oldStatus: FieldRef<"StatusAuditLog", 'String'>
    readonly newStatus: FieldRef<"StatusAuditLog", 'String'>
    readonly changedBy: FieldRef<"StatusAuditLog", 'String'>
    readonly reason: FieldRef<"StatusAuditLog", 'String'>
    readonly createdAt: FieldRef<"StatusAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StatusAuditLog findUnique
   */
  export type StatusAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StatusAuditLog to fetch.
     */
    where: StatusAuditLogWhereUniqueInput
  }

  /**
   * StatusAuditLog findUniqueOrThrow
   */
  export type StatusAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StatusAuditLog to fetch.
     */
    where: StatusAuditLogWhereUniqueInput
  }

  /**
   * StatusAuditLog findFirst
   */
  export type StatusAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StatusAuditLog to fetch.
     */
    where?: StatusAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusAuditLogs to fetch.
     */
    orderBy?: StatusAuditLogOrderByWithRelationInput | StatusAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusAuditLogs.
     */
    cursor?: StatusAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusAuditLogs.
     */
    distinct?: StatusAuditLogScalarFieldEnum | StatusAuditLogScalarFieldEnum[]
  }

  /**
   * StatusAuditLog findFirstOrThrow
   */
  export type StatusAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StatusAuditLog to fetch.
     */
    where?: StatusAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusAuditLogs to fetch.
     */
    orderBy?: StatusAuditLogOrderByWithRelationInput | StatusAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StatusAuditLogs.
     */
    cursor?: StatusAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StatusAuditLogs.
     */
    distinct?: StatusAuditLogScalarFieldEnum | StatusAuditLogScalarFieldEnum[]
  }

  /**
   * StatusAuditLog findMany
   */
  export type StatusAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which StatusAuditLogs to fetch.
     */
    where?: StatusAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StatusAuditLogs to fetch.
     */
    orderBy?: StatusAuditLogOrderByWithRelationInput | StatusAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StatusAuditLogs.
     */
    cursor?: StatusAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StatusAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StatusAuditLogs.
     */
    skip?: number
    distinct?: StatusAuditLogScalarFieldEnum | StatusAuditLogScalarFieldEnum[]
  }

  /**
   * StatusAuditLog create
   */
  export type StatusAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a StatusAuditLog.
     */
    data: XOR<StatusAuditLogCreateInput, StatusAuditLogUncheckedCreateInput>
  }

  /**
   * StatusAuditLog createMany
   */
  export type StatusAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StatusAuditLogs.
     */
    data: StatusAuditLogCreateManyInput | StatusAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StatusAuditLog createManyAndReturn
   */
  export type StatusAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many StatusAuditLogs.
     */
    data: StatusAuditLogCreateManyInput | StatusAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusAuditLog update
   */
  export type StatusAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a StatusAuditLog.
     */
    data: XOR<StatusAuditLogUpdateInput, StatusAuditLogUncheckedUpdateInput>
    /**
     * Choose, which StatusAuditLog to update.
     */
    where: StatusAuditLogWhereUniqueInput
  }

  /**
   * StatusAuditLog updateMany
   */
  export type StatusAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StatusAuditLogs.
     */
    data: XOR<StatusAuditLogUpdateManyMutationInput, StatusAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which StatusAuditLogs to update
     */
    where?: StatusAuditLogWhereInput
    /**
     * Limit how many StatusAuditLogs to update.
     */
    limit?: number
  }

  /**
   * StatusAuditLog updateManyAndReturn
   */
  export type StatusAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update StatusAuditLogs.
     */
    data: XOR<StatusAuditLogUpdateManyMutationInput, StatusAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which StatusAuditLogs to update
     */
    where?: StatusAuditLogWhereInput
    /**
     * Limit how many StatusAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StatusAuditLog upsert
   */
  export type StatusAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the StatusAuditLog to update in case it exists.
     */
    where: StatusAuditLogWhereUniqueInput
    /**
     * In case the StatusAuditLog found by the `where` argument doesn't exist, create a new StatusAuditLog with this data.
     */
    create: XOR<StatusAuditLogCreateInput, StatusAuditLogUncheckedCreateInput>
    /**
     * In case the StatusAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StatusAuditLogUpdateInput, StatusAuditLogUncheckedUpdateInput>
  }

  /**
   * StatusAuditLog delete
   */
  export type StatusAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
    /**
     * Filter which StatusAuditLog to delete.
     */
    where: StatusAuditLogWhereUniqueInput
  }

  /**
   * StatusAuditLog deleteMany
   */
  export type StatusAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StatusAuditLogs to delete
     */
    where?: StatusAuditLogWhereInput
    /**
     * Limit how many StatusAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * StatusAuditLog without action
   */
  export type StatusAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatusAuditLog
     */
    select?: StatusAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StatusAuditLog
     */
    omit?: StatusAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StatusAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model PermissionAuditLog
   */

  export type AggregatePermissionAuditLog = {
    _count: PermissionAuditLogCountAggregateOutputType | null
    _min: PermissionAuditLogMinAggregateOutputType | null
    _max: PermissionAuditLogMaxAggregateOutputType | null
  }

  export type PermissionAuditLogMinAggregateOutputType = {
    id: string | null
    changeType: string | null
    clientId: string | null
    staffUserId: string | null
    oldValue: string | null
    newValue: string | null
    changedBy: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type PermissionAuditLogMaxAggregateOutputType = {
    id: string | null
    changeType: string | null
    clientId: string | null
    staffUserId: string | null
    oldValue: string | null
    newValue: string | null
    changedBy: string | null
    reason: string | null
    createdAt: Date | null
  }

  export type PermissionAuditLogCountAggregateOutputType = {
    id: number
    changeType: number
    clientId: number
    staffUserId: number
    oldValue: number
    newValue: number
    changedBy: number
    reason: number
    createdAt: number
    _all: number
  }


  export type PermissionAuditLogMinAggregateInputType = {
    id?: true
    changeType?: true
    clientId?: true
    staffUserId?: true
    oldValue?: true
    newValue?: true
    changedBy?: true
    reason?: true
    createdAt?: true
  }

  export type PermissionAuditLogMaxAggregateInputType = {
    id?: true
    changeType?: true
    clientId?: true
    staffUserId?: true
    oldValue?: true
    newValue?: true
    changedBy?: true
    reason?: true
    createdAt?: true
  }

  export type PermissionAuditLogCountAggregateInputType = {
    id?: true
    changeType?: true
    clientId?: true
    staffUserId?: true
    oldValue?: true
    newValue?: true
    changedBy?: true
    reason?: true
    createdAt?: true
    _all?: true
  }

  export type PermissionAuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionAuditLog to aggregate.
     */
    where?: PermissionAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionAuditLogs to fetch.
     */
    orderBy?: PermissionAuditLogOrderByWithRelationInput | PermissionAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PermissionAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PermissionAuditLogs
    **/
    _count?: true | PermissionAuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionAuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionAuditLogMaxAggregateInputType
  }

  export type GetPermissionAuditLogAggregateType<T extends PermissionAuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissionAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissionAuditLog[P]>
      : GetScalarType<T[P], AggregatePermissionAuditLog[P]>
  }




  export type PermissionAuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PermissionAuditLogWhereInput
    orderBy?: PermissionAuditLogOrderByWithAggregationInput | PermissionAuditLogOrderByWithAggregationInput[]
    by: PermissionAuditLogScalarFieldEnum[] | PermissionAuditLogScalarFieldEnum
    having?: PermissionAuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionAuditLogCountAggregateInputType | true
    _min?: PermissionAuditLogMinAggregateInputType
    _max?: PermissionAuditLogMaxAggregateInputType
  }

  export type PermissionAuditLogGroupByOutputType = {
    id: string
    changeType: string
    clientId: string | null
    staffUserId: string | null
    oldValue: string | null
    newValue: string | null
    changedBy: string
    reason: string | null
    createdAt: Date
    _count: PermissionAuditLogCountAggregateOutputType | null
    _min: PermissionAuditLogMinAggregateOutputType | null
    _max: PermissionAuditLogMaxAggregateOutputType | null
  }

  type GetPermissionAuditLogGroupByPayload<T extends PermissionAuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionAuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionAuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionAuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionAuditLogGroupByOutputType[P]>
        }
      >
    >


  export type PermissionAuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeType?: boolean
    clientId?: boolean
    staffUserId?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    reason?: boolean
    createdAt?: boolean
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionAuditLog"]>

  export type PermissionAuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeType?: boolean
    clientId?: boolean
    staffUserId?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    reason?: boolean
    createdAt?: boolean
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionAuditLog"]>

  export type PermissionAuditLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    changeType?: boolean
    clientId?: boolean
    staffUserId?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    reason?: boolean
    createdAt?: boolean
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissionAuditLog"]>

  export type PermissionAuditLogSelectScalar = {
    id?: boolean
    changeType?: boolean
    clientId?: boolean
    staffUserId?: boolean
    oldValue?: boolean
    newValue?: boolean
    changedBy?: boolean
    reason?: boolean
    createdAt?: boolean
  }

  export type PermissionAuditLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "changeType" | "clientId" | "staffUserId" | "oldValue" | "newValue" | "changedBy" | "reason" | "createdAt", ExtArgs["result"]["permissionAuditLog"]>
  export type PermissionAuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type PermissionAuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }
  export type PermissionAuditLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    staff?: boolean | StaffProfileDefaultArgs<ExtArgs>
  }

  export type $PermissionAuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PermissionAuditLog"
    objects: {
      staff: Prisma.$StaffProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      changeType: string
      clientId: string | null
      staffUserId: string | null
      oldValue: string | null
      newValue: string | null
      changedBy: string
      reason: string | null
      createdAt: Date
    }, ExtArgs["result"]["permissionAuditLog"]>
    composites: {}
  }

  type PermissionAuditLogGetPayload<S extends boolean | null | undefined | PermissionAuditLogDefaultArgs> = $Result.GetResult<Prisma.$PermissionAuditLogPayload, S>

  type PermissionAuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PermissionAuditLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionAuditLogCountAggregateInputType | true
    }

  export interface PermissionAuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PermissionAuditLog'], meta: { name: 'PermissionAuditLog' } }
    /**
     * Find zero or one PermissionAuditLog that matches the filter.
     * @param {PermissionAuditLogFindUniqueArgs} args - Arguments to find a PermissionAuditLog
     * @example
     * // Get one PermissionAuditLog
     * const permissionAuditLog = await prisma.permissionAuditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PermissionAuditLogFindUniqueArgs>(args: SelectSubset<T, PermissionAuditLogFindUniqueArgs<ExtArgs>>): Prisma__PermissionAuditLogClient<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PermissionAuditLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PermissionAuditLogFindUniqueOrThrowArgs} args - Arguments to find a PermissionAuditLog
     * @example
     * // Get one PermissionAuditLog
     * const permissionAuditLog = await prisma.permissionAuditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PermissionAuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, PermissionAuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PermissionAuditLogClient<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PermissionAuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditLogFindFirstArgs} args - Arguments to find a PermissionAuditLog
     * @example
     * // Get one PermissionAuditLog
     * const permissionAuditLog = await prisma.permissionAuditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PermissionAuditLogFindFirstArgs>(args?: SelectSubset<T, PermissionAuditLogFindFirstArgs<ExtArgs>>): Prisma__PermissionAuditLogClient<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PermissionAuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditLogFindFirstOrThrowArgs} args - Arguments to find a PermissionAuditLog
     * @example
     * // Get one PermissionAuditLog
     * const permissionAuditLog = await prisma.permissionAuditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PermissionAuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, PermissionAuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__PermissionAuditLogClient<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PermissionAuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PermissionAuditLogs
     * const permissionAuditLogs = await prisma.permissionAuditLog.findMany()
     * 
     * // Get first 10 PermissionAuditLogs
     * const permissionAuditLogs = await prisma.permissionAuditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionAuditLogWithIdOnly = await prisma.permissionAuditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PermissionAuditLogFindManyArgs>(args?: SelectSubset<T, PermissionAuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PermissionAuditLog.
     * @param {PermissionAuditLogCreateArgs} args - Arguments to create a PermissionAuditLog.
     * @example
     * // Create one PermissionAuditLog
     * const PermissionAuditLog = await prisma.permissionAuditLog.create({
     *   data: {
     *     // ... data to create a PermissionAuditLog
     *   }
     * })
     * 
     */
    create<T extends PermissionAuditLogCreateArgs>(args: SelectSubset<T, PermissionAuditLogCreateArgs<ExtArgs>>): Prisma__PermissionAuditLogClient<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PermissionAuditLogs.
     * @param {PermissionAuditLogCreateManyArgs} args - Arguments to create many PermissionAuditLogs.
     * @example
     * // Create many PermissionAuditLogs
     * const permissionAuditLog = await prisma.permissionAuditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PermissionAuditLogCreateManyArgs>(args?: SelectSubset<T, PermissionAuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PermissionAuditLogs and returns the data saved in the database.
     * @param {PermissionAuditLogCreateManyAndReturnArgs} args - Arguments to create many PermissionAuditLogs.
     * @example
     * // Create many PermissionAuditLogs
     * const permissionAuditLog = await prisma.permissionAuditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PermissionAuditLogs and only return the `id`
     * const permissionAuditLogWithIdOnly = await prisma.permissionAuditLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PermissionAuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, PermissionAuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PermissionAuditLog.
     * @param {PermissionAuditLogDeleteArgs} args - Arguments to delete one PermissionAuditLog.
     * @example
     * // Delete one PermissionAuditLog
     * const PermissionAuditLog = await prisma.permissionAuditLog.delete({
     *   where: {
     *     // ... filter to delete one PermissionAuditLog
     *   }
     * })
     * 
     */
    delete<T extends PermissionAuditLogDeleteArgs>(args: SelectSubset<T, PermissionAuditLogDeleteArgs<ExtArgs>>): Prisma__PermissionAuditLogClient<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PermissionAuditLog.
     * @param {PermissionAuditLogUpdateArgs} args - Arguments to update one PermissionAuditLog.
     * @example
     * // Update one PermissionAuditLog
     * const permissionAuditLog = await prisma.permissionAuditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PermissionAuditLogUpdateArgs>(args: SelectSubset<T, PermissionAuditLogUpdateArgs<ExtArgs>>): Prisma__PermissionAuditLogClient<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PermissionAuditLogs.
     * @param {PermissionAuditLogDeleteManyArgs} args - Arguments to filter PermissionAuditLogs to delete.
     * @example
     * // Delete a few PermissionAuditLogs
     * const { count } = await prisma.permissionAuditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PermissionAuditLogDeleteManyArgs>(args?: SelectSubset<T, PermissionAuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermissionAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PermissionAuditLogs
     * const permissionAuditLog = await prisma.permissionAuditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PermissionAuditLogUpdateManyArgs>(args: SelectSubset<T, PermissionAuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PermissionAuditLogs and returns the data updated in the database.
     * @param {PermissionAuditLogUpdateManyAndReturnArgs} args - Arguments to update many PermissionAuditLogs.
     * @example
     * // Update many PermissionAuditLogs
     * const permissionAuditLog = await prisma.permissionAuditLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PermissionAuditLogs and only return the `id`
     * const permissionAuditLogWithIdOnly = await prisma.permissionAuditLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PermissionAuditLogUpdateManyAndReturnArgs>(args: SelectSubset<T, PermissionAuditLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PermissionAuditLog.
     * @param {PermissionAuditLogUpsertArgs} args - Arguments to update or create a PermissionAuditLog.
     * @example
     * // Update or create a PermissionAuditLog
     * const permissionAuditLog = await prisma.permissionAuditLog.upsert({
     *   create: {
     *     // ... data to create a PermissionAuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PermissionAuditLog we want to update
     *   }
     * })
     */
    upsert<T extends PermissionAuditLogUpsertArgs>(args: SelectSubset<T, PermissionAuditLogUpsertArgs<ExtArgs>>): Prisma__PermissionAuditLogClient<$Result.GetResult<Prisma.$PermissionAuditLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PermissionAuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditLogCountArgs} args - Arguments to filter PermissionAuditLogs to count.
     * @example
     * // Count the number of PermissionAuditLogs
     * const count = await prisma.permissionAuditLog.count({
     *   where: {
     *     // ... the filter for the PermissionAuditLogs we want to count
     *   }
     * })
    **/
    count<T extends PermissionAuditLogCountArgs>(
      args?: Subset<T, PermissionAuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionAuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PermissionAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAuditLogAggregateArgs>(args: Subset<T, PermissionAuditLogAggregateArgs>): Prisma.PrismaPromise<GetPermissionAuditLogAggregateType<T>>

    /**
     * Group by PermissionAuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionAuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionAuditLogGroupByArgs['orderBy'] }
        : { orderBy?: PermissionAuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionAuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PermissionAuditLog model
   */
  readonly fields: PermissionAuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PermissionAuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PermissionAuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    staff<T extends StaffProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StaffProfileDefaultArgs<ExtArgs>>): Prisma__StaffProfileClient<$Result.GetResult<Prisma.$StaffProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PermissionAuditLog model
   */
  interface PermissionAuditLogFieldRefs {
    readonly id: FieldRef<"PermissionAuditLog", 'String'>
    readonly changeType: FieldRef<"PermissionAuditLog", 'String'>
    readonly clientId: FieldRef<"PermissionAuditLog", 'String'>
    readonly staffUserId: FieldRef<"PermissionAuditLog", 'String'>
    readonly oldValue: FieldRef<"PermissionAuditLog", 'String'>
    readonly newValue: FieldRef<"PermissionAuditLog", 'String'>
    readonly changedBy: FieldRef<"PermissionAuditLog", 'String'>
    readonly reason: FieldRef<"PermissionAuditLog", 'String'>
    readonly createdAt: FieldRef<"PermissionAuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PermissionAuditLog findUnique
   */
  export type PermissionAuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAuditLog to fetch.
     */
    where: PermissionAuditLogWhereUniqueInput
  }

  /**
   * PermissionAuditLog findUniqueOrThrow
   */
  export type PermissionAuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAuditLog to fetch.
     */
    where: PermissionAuditLogWhereUniqueInput
  }

  /**
   * PermissionAuditLog findFirst
   */
  export type PermissionAuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAuditLog to fetch.
     */
    where?: PermissionAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionAuditLogs to fetch.
     */
    orderBy?: PermissionAuditLogOrderByWithRelationInput | PermissionAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionAuditLogs.
     */
    cursor?: PermissionAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionAuditLogs.
     */
    distinct?: PermissionAuditLogScalarFieldEnum | PermissionAuditLogScalarFieldEnum[]
  }

  /**
   * PermissionAuditLog findFirstOrThrow
   */
  export type PermissionAuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAuditLog to fetch.
     */
    where?: PermissionAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionAuditLogs to fetch.
     */
    orderBy?: PermissionAuditLogOrderByWithRelationInput | PermissionAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PermissionAuditLogs.
     */
    cursor?: PermissionAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionAuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PermissionAuditLogs.
     */
    distinct?: PermissionAuditLogScalarFieldEnum | PermissionAuditLogScalarFieldEnum[]
  }

  /**
   * PermissionAuditLog findMany
   */
  export type PermissionAuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * Filter, which PermissionAuditLogs to fetch.
     */
    where?: PermissionAuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PermissionAuditLogs to fetch.
     */
    orderBy?: PermissionAuditLogOrderByWithRelationInput | PermissionAuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PermissionAuditLogs.
     */
    cursor?: PermissionAuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PermissionAuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PermissionAuditLogs.
     */
    skip?: number
    distinct?: PermissionAuditLogScalarFieldEnum | PermissionAuditLogScalarFieldEnum[]
  }

  /**
   * PermissionAuditLog create
   */
  export type PermissionAuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a PermissionAuditLog.
     */
    data: XOR<PermissionAuditLogCreateInput, PermissionAuditLogUncheckedCreateInput>
  }

  /**
   * PermissionAuditLog createMany
   */
  export type PermissionAuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PermissionAuditLogs.
     */
    data: PermissionAuditLogCreateManyInput | PermissionAuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PermissionAuditLog createManyAndReturn
   */
  export type PermissionAuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * The data used to create many PermissionAuditLogs.
     */
    data: PermissionAuditLogCreateManyInput | PermissionAuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PermissionAuditLog update
   */
  export type PermissionAuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a PermissionAuditLog.
     */
    data: XOR<PermissionAuditLogUpdateInput, PermissionAuditLogUncheckedUpdateInput>
    /**
     * Choose, which PermissionAuditLog to update.
     */
    where: PermissionAuditLogWhereUniqueInput
  }

  /**
   * PermissionAuditLog updateMany
   */
  export type PermissionAuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PermissionAuditLogs.
     */
    data: XOR<PermissionAuditLogUpdateManyMutationInput, PermissionAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which PermissionAuditLogs to update
     */
    where?: PermissionAuditLogWhereInput
    /**
     * Limit how many PermissionAuditLogs to update.
     */
    limit?: number
  }

  /**
   * PermissionAuditLog updateManyAndReturn
   */
  export type PermissionAuditLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * The data used to update PermissionAuditLogs.
     */
    data: XOR<PermissionAuditLogUpdateManyMutationInput, PermissionAuditLogUncheckedUpdateManyInput>
    /**
     * Filter which PermissionAuditLogs to update
     */
    where?: PermissionAuditLogWhereInput
    /**
     * Limit how many PermissionAuditLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PermissionAuditLog upsert
   */
  export type PermissionAuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the PermissionAuditLog to update in case it exists.
     */
    where: PermissionAuditLogWhereUniqueInput
    /**
     * In case the PermissionAuditLog found by the `where` argument doesn't exist, create a new PermissionAuditLog with this data.
     */
    create: XOR<PermissionAuditLogCreateInput, PermissionAuditLogUncheckedCreateInput>
    /**
     * In case the PermissionAuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PermissionAuditLogUpdateInput, PermissionAuditLogUncheckedUpdateInput>
  }

  /**
   * PermissionAuditLog delete
   */
  export type PermissionAuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
    /**
     * Filter which PermissionAuditLog to delete.
     */
    where: PermissionAuditLogWhereUniqueInput
  }

  /**
   * PermissionAuditLog deleteMany
   */
  export type PermissionAuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PermissionAuditLogs to delete
     */
    where?: PermissionAuditLogWhereInput
    /**
     * Limit how many PermissionAuditLogs to delete.
     */
    limit?: number
  }

  /**
   * PermissionAuditLog without action
   */
  export type PermissionAuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionAuditLog
     */
    select?: PermissionAuditLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PermissionAuditLog
     */
    omit?: PermissionAuditLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PermissionAuditLogInclude<ExtArgs> | null
  }


  /**
   * Model DocumentEvent
   */

  export type AggregateDocumentEvent = {
    _count: DocumentEventCountAggregateOutputType | null
    _min: DocumentEventMinAggregateOutputType | null
    _max: DocumentEventMaxAggregateOutputType | null
  }

  export type DocumentEventMinAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    eventType: $Enums.DocumentEventType | null
    documentId: string | null
    description: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type DocumentEventMaxAggregateOutputType = {
    id: string | null
    entityTaxYearId: string | null
    eventType: $Enums.DocumentEventType | null
    documentId: string | null
    description: string | null
    metadata: string | null
    createdAt: Date | null
  }

  export type DocumentEventCountAggregateOutputType = {
    id: number
    entityTaxYearId: number
    eventType: number
    documentId: number
    description: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type DocumentEventMinAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    eventType?: true
    documentId?: true
    description?: true
    metadata?: true
    createdAt?: true
  }

  export type DocumentEventMaxAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    eventType?: true
    documentId?: true
    description?: true
    metadata?: true
    createdAt?: true
  }

  export type DocumentEventCountAggregateInputType = {
    id?: true
    entityTaxYearId?: true
    eventType?: true
    documentId?: true
    description?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type DocumentEventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentEvent to aggregate.
     */
    where?: DocumentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentEvents to fetch.
     */
    orderBy?: DocumentEventOrderByWithRelationInput | DocumentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DocumentEvents
    **/
    _count?: true | DocumentEventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentEventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentEventMaxAggregateInputType
  }

  export type GetDocumentEventAggregateType<T extends DocumentEventAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumentEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumentEvent[P]>
      : GetScalarType<T[P], AggregateDocumentEvent[P]>
  }




  export type DocumentEventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentEventWhereInput
    orderBy?: DocumentEventOrderByWithAggregationInput | DocumentEventOrderByWithAggregationInput[]
    by: DocumentEventScalarFieldEnum[] | DocumentEventScalarFieldEnum
    having?: DocumentEventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentEventCountAggregateInputType | true
    _min?: DocumentEventMinAggregateInputType
    _max?: DocumentEventMaxAggregateInputType
  }

  export type DocumentEventGroupByOutputType = {
    id: string
    entityTaxYearId: string
    eventType: $Enums.DocumentEventType
    documentId: string | null
    description: string | null
    metadata: string | null
    createdAt: Date
    _count: DocumentEventCountAggregateOutputType | null
    _min: DocumentEventMinAggregateOutputType | null
    _max: DocumentEventMaxAggregateOutputType | null
  }

  type GetDocumentEventGroupByPayload<T extends DocumentEventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentEventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentEventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentEventGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentEventGroupByOutputType[P]>
        }
      >
    >


  export type DocumentEventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    eventType?: boolean
    documentId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentEvent"]>

  export type DocumentEventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    eventType?: boolean
    documentId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentEvent"]>

  export type DocumentEventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entityTaxYearId?: boolean
    eventType?: boolean
    documentId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documentEvent"]>

  export type DocumentEventSelectScalar = {
    id?: boolean
    entityTaxYearId?: boolean
    eventType?: boolean
    documentId?: boolean
    description?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type DocumentEventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entityTaxYearId" | "eventType" | "documentId" | "description" | "metadata" | "createdAt", ExtArgs["result"]["documentEvent"]>
  export type DocumentEventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type DocumentEventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }
  export type DocumentEventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    entityTaxYear?: boolean | EntityTaxYearDefaultArgs<ExtArgs>
  }

  export type $DocumentEventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DocumentEvent"
    objects: {
      entityTaxYear: Prisma.$EntityTaxYearPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      entityTaxYearId: string
      eventType: $Enums.DocumentEventType
      documentId: string | null
      description: string | null
      metadata: string | null
      createdAt: Date
    }, ExtArgs["result"]["documentEvent"]>
    composites: {}
  }

  type DocumentEventGetPayload<S extends boolean | null | undefined | DocumentEventDefaultArgs> = $Result.GetResult<Prisma.$DocumentEventPayload, S>

  type DocumentEventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DocumentEventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DocumentEventCountAggregateInputType | true
    }

  export interface DocumentEventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DocumentEvent'], meta: { name: 'DocumentEvent' } }
    /**
     * Find zero or one DocumentEvent that matches the filter.
     * @param {DocumentEventFindUniqueArgs} args - Arguments to find a DocumentEvent
     * @example
     * // Get one DocumentEvent
     * const documentEvent = await prisma.documentEvent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentEventFindUniqueArgs>(args: SelectSubset<T, DocumentEventFindUniqueArgs<ExtArgs>>): Prisma__DocumentEventClient<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DocumentEvent that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DocumentEventFindUniqueOrThrowArgs} args - Arguments to find a DocumentEvent
     * @example
     * // Get one DocumentEvent
     * const documentEvent = await prisma.documentEvent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentEventFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentEventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentEventClient<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentEvent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentEventFindFirstArgs} args - Arguments to find a DocumentEvent
     * @example
     * // Get one DocumentEvent
     * const documentEvent = await prisma.documentEvent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentEventFindFirstArgs>(args?: SelectSubset<T, DocumentEventFindFirstArgs<ExtArgs>>): Prisma__DocumentEventClient<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DocumentEvent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentEventFindFirstOrThrowArgs} args - Arguments to find a DocumentEvent
     * @example
     * // Get one DocumentEvent
     * const documentEvent = await prisma.documentEvent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentEventFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentEventFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentEventClient<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DocumentEvents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentEventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DocumentEvents
     * const documentEvents = await prisma.documentEvent.findMany()
     * 
     * // Get first 10 DocumentEvents
     * const documentEvents = await prisma.documentEvent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentEventWithIdOnly = await prisma.documentEvent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentEventFindManyArgs>(args?: SelectSubset<T, DocumentEventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DocumentEvent.
     * @param {DocumentEventCreateArgs} args - Arguments to create a DocumentEvent.
     * @example
     * // Create one DocumentEvent
     * const DocumentEvent = await prisma.documentEvent.create({
     *   data: {
     *     // ... data to create a DocumentEvent
     *   }
     * })
     * 
     */
    create<T extends DocumentEventCreateArgs>(args: SelectSubset<T, DocumentEventCreateArgs<ExtArgs>>): Prisma__DocumentEventClient<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DocumentEvents.
     * @param {DocumentEventCreateManyArgs} args - Arguments to create many DocumentEvents.
     * @example
     * // Create many DocumentEvents
     * const documentEvent = await prisma.documentEvent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentEventCreateManyArgs>(args?: SelectSubset<T, DocumentEventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DocumentEvents and returns the data saved in the database.
     * @param {DocumentEventCreateManyAndReturnArgs} args - Arguments to create many DocumentEvents.
     * @example
     * // Create many DocumentEvents
     * const documentEvent = await prisma.documentEvent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DocumentEvents and only return the `id`
     * const documentEventWithIdOnly = await prisma.documentEvent.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentEventCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentEventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DocumentEvent.
     * @param {DocumentEventDeleteArgs} args - Arguments to delete one DocumentEvent.
     * @example
     * // Delete one DocumentEvent
     * const DocumentEvent = await prisma.documentEvent.delete({
     *   where: {
     *     // ... filter to delete one DocumentEvent
     *   }
     * })
     * 
     */
    delete<T extends DocumentEventDeleteArgs>(args: SelectSubset<T, DocumentEventDeleteArgs<ExtArgs>>): Prisma__DocumentEventClient<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DocumentEvent.
     * @param {DocumentEventUpdateArgs} args - Arguments to update one DocumentEvent.
     * @example
     * // Update one DocumentEvent
     * const documentEvent = await prisma.documentEvent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentEventUpdateArgs>(args: SelectSubset<T, DocumentEventUpdateArgs<ExtArgs>>): Prisma__DocumentEventClient<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DocumentEvents.
     * @param {DocumentEventDeleteManyArgs} args - Arguments to filter DocumentEvents to delete.
     * @example
     * // Delete a few DocumentEvents
     * const { count } = await prisma.documentEvent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentEventDeleteManyArgs>(args?: SelectSubset<T, DocumentEventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentEventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DocumentEvents
     * const documentEvent = await prisma.documentEvent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentEventUpdateManyArgs>(args: SelectSubset<T, DocumentEventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DocumentEvents and returns the data updated in the database.
     * @param {DocumentEventUpdateManyAndReturnArgs} args - Arguments to update many DocumentEvents.
     * @example
     * // Update many DocumentEvents
     * const documentEvent = await prisma.documentEvent.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DocumentEvents and only return the `id`
     * const documentEventWithIdOnly = await prisma.documentEvent.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DocumentEventUpdateManyAndReturnArgs>(args: SelectSubset<T, DocumentEventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DocumentEvent.
     * @param {DocumentEventUpsertArgs} args - Arguments to update or create a DocumentEvent.
     * @example
     * // Update or create a DocumentEvent
     * const documentEvent = await prisma.documentEvent.upsert({
     *   create: {
     *     // ... data to create a DocumentEvent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DocumentEvent we want to update
     *   }
     * })
     */
    upsert<T extends DocumentEventUpsertArgs>(args: SelectSubset<T, DocumentEventUpsertArgs<ExtArgs>>): Prisma__DocumentEventClient<$Result.GetResult<Prisma.$DocumentEventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DocumentEvents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentEventCountArgs} args - Arguments to filter DocumentEvents to count.
     * @example
     * // Count the number of DocumentEvents
     * const count = await prisma.documentEvent.count({
     *   where: {
     *     // ... the filter for the DocumentEvents we want to count
     *   }
     * })
    **/
    count<T extends DocumentEventCountArgs>(
      args?: Subset<T, DocumentEventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentEventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DocumentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentEventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentEventAggregateArgs>(args: Subset<T, DocumentEventAggregateArgs>): Prisma.PrismaPromise<GetDocumentEventAggregateType<T>>

    /**
     * Group by DocumentEvent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentEventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentEventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentEventGroupByArgs['orderBy'] }
        : { orderBy?: DocumentEventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentEventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DocumentEvent model
   */
  readonly fields: DocumentEventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DocumentEvent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentEventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    entityTaxYear<T extends EntityTaxYearDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EntityTaxYearDefaultArgs<ExtArgs>>): Prisma__EntityTaxYearClient<$Result.GetResult<Prisma.$EntityTaxYearPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DocumentEvent model
   */
  interface DocumentEventFieldRefs {
    readonly id: FieldRef<"DocumentEvent", 'String'>
    readonly entityTaxYearId: FieldRef<"DocumentEvent", 'String'>
    readonly eventType: FieldRef<"DocumentEvent", 'DocumentEventType'>
    readonly documentId: FieldRef<"DocumentEvent", 'String'>
    readonly description: FieldRef<"DocumentEvent", 'String'>
    readonly metadata: FieldRef<"DocumentEvent", 'String'>
    readonly createdAt: FieldRef<"DocumentEvent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DocumentEvent findUnique
   */
  export type DocumentEventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * Filter, which DocumentEvent to fetch.
     */
    where: DocumentEventWhereUniqueInput
  }

  /**
   * DocumentEvent findUniqueOrThrow
   */
  export type DocumentEventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * Filter, which DocumentEvent to fetch.
     */
    where: DocumentEventWhereUniqueInput
  }

  /**
   * DocumentEvent findFirst
   */
  export type DocumentEventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * Filter, which DocumentEvent to fetch.
     */
    where?: DocumentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentEvents to fetch.
     */
    orderBy?: DocumentEventOrderByWithRelationInput | DocumentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentEvents.
     */
    cursor?: DocumentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentEvents.
     */
    distinct?: DocumentEventScalarFieldEnum | DocumentEventScalarFieldEnum[]
  }

  /**
   * DocumentEvent findFirstOrThrow
   */
  export type DocumentEventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * Filter, which DocumentEvent to fetch.
     */
    where?: DocumentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentEvents to fetch.
     */
    orderBy?: DocumentEventOrderByWithRelationInput | DocumentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DocumentEvents.
     */
    cursor?: DocumentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentEvents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DocumentEvents.
     */
    distinct?: DocumentEventScalarFieldEnum | DocumentEventScalarFieldEnum[]
  }

  /**
   * DocumentEvent findMany
   */
  export type DocumentEventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * Filter, which DocumentEvents to fetch.
     */
    where?: DocumentEventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DocumentEvents to fetch.
     */
    orderBy?: DocumentEventOrderByWithRelationInput | DocumentEventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DocumentEvents.
     */
    cursor?: DocumentEventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DocumentEvents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DocumentEvents.
     */
    skip?: number
    distinct?: DocumentEventScalarFieldEnum | DocumentEventScalarFieldEnum[]
  }

  /**
   * DocumentEvent create
   */
  export type DocumentEventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * The data needed to create a DocumentEvent.
     */
    data: XOR<DocumentEventCreateInput, DocumentEventUncheckedCreateInput>
  }

  /**
   * DocumentEvent createMany
   */
  export type DocumentEventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DocumentEvents.
     */
    data: DocumentEventCreateManyInput | DocumentEventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DocumentEvent createManyAndReturn
   */
  export type DocumentEventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * The data used to create many DocumentEvents.
     */
    data: DocumentEventCreateManyInput | DocumentEventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentEvent update
   */
  export type DocumentEventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * The data needed to update a DocumentEvent.
     */
    data: XOR<DocumentEventUpdateInput, DocumentEventUncheckedUpdateInput>
    /**
     * Choose, which DocumentEvent to update.
     */
    where: DocumentEventWhereUniqueInput
  }

  /**
   * DocumentEvent updateMany
   */
  export type DocumentEventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DocumentEvents.
     */
    data: XOR<DocumentEventUpdateManyMutationInput, DocumentEventUncheckedUpdateManyInput>
    /**
     * Filter which DocumentEvents to update
     */
    where?: DocumentEventWhereInput
    /**
     * Limit how many DocumentEvents to update.
     */
    limit?: number
  }

  /**
   * DocumentEvent updateManyAndReturn
   */
  export type DocumentEventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * The data used to update DocumentEvents.
     */
    data: XOR<DocumentEventUpdateManyMutationInput, DocumentEventUncheckedUpdateManyInput>
    /**
     * Filter which DocumentEvents to update
     */
    where?: DocumentEventWhereInput
    /**
     * Limit how many DocumentEvents to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DocumentEvent upsert
   */
  export type DocumentEventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * The filter to search for the DocumentEvent to update in case it exists.
     */
    where: DocumentEventWhereUniqueInput
    /**
     * In case the DocumentEvent found by the `where` argument doesn't exist, create a new DocumentEvent with this data.
     */
    create: XOR<DocumentEventCreateInput, DocumentEventUncheckedCreateInput>
    /**
     * In case the DocumentEvent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentEventUpdateInput, DocumentEventUncheckedUpdateInput>
  }

  /**
   * DocumentEvent delete
   */
  export type DocumentEventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
    /**
     * Filter which DocumentEvent to delete.
     */
    where: DocumentEventWhereUniqueInput
  }

  /**
   * DocumentEvent deleteMany
   */
  export type DocumentEventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DocumentEvents to delete
     */
    where?: DocumentEventWhereInput
    /**
     * Limit how many DocumentEvents to delete.
     */
    limit?: number
  }

  /**
   * DocumentEvent without action
   */
  export type DocumentEventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentEvent
     */
    select?: DocumentEventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DocumentEvent
     */
    omit?: DocumentEventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentEventInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    userType: 'userType',
    fullName: 'fullName',
    email: 'email',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const StaffProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    staffRole: 'staffRole',
    staffTeamReporting: 'staffTeamReporting',
    jobTitle: 'jobTitle',
    phone: 'phone',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StaffProfileScalarFieldEnum = (typeof StaffProfileScalarFieldEnum)[keyof typeof StaffProfileScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    displayName: 'displayName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const AccountUserScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    userId: 'userId',
    clientRole: 'clientRole',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AccountUserScalarFieldEnum = (typeof AccountUserScalarFieldEnum)[keyof typeof AccountUserScalarFieldEnum]


  export const ClientEntityScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    entityName: 'entityName',
    entityType: 'entityType',
    status: 'status',
    isRestricted: 'isRestricted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientEntityScalarFieldEnum = (typeof ClientEntityScalarFieldEnum)[keyof typeof ClientEntityScalarFieldEnum]


  export const EntityTaxYearScalarFieldEnum: {
    id: 'id',
    clientEntityId: 'clientEntityId',
    taxYear: 'taxYear',
    taxReturnExpected: 'taxReturnExpected',
    inviteStatus: 'inviteStatus',
    inviteSentAt: 'inviteSentAt',
    attemptCount: 'attemptCount',
    lastError: 'lastError',
    engagementStatus: 'engagementStatus',
    engagementSignedAt: 'engagementSignedAt',
    engagementSigner1Id: 'engagementSigner1Id',
    engagementSigner2Id: 'engagementSigner2Id',
    docsRequiredCount: 'docsRequiredCount',
    docsReceivedCount: 'docsReceivedCount',
    checklistCompleteAt: 'checklistCompleteAt',
    docConfirmationStatus: 'docConfirmationStatus',
    docConfirmationSignedAt: 'docConfirmationSignedAt',
    docConfirmationSignerId: 'docConfirmationSignerId',
    questionnaireStatus: 'questionnaireStatus',
    questionnaireCompletedAt: 'questionnaireCompletedAt',
    idStatus: 'idStatus',
    idValidUntil: 'idValidUntil',
    readyForPrep: 'readyForPrep',
    extensionRequested: 'extensionRequested',
    extensionFiled: 'extensionFiled',
    extendedDueDate: 'extendedDueDate',
    internalStatus: 'internalStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EntityTaxYearScalarFieldEnum = (typeof EntityTaxYearScalarFieldEnum)[keyof typeof EntityTaxYearScalarFieldEnum]


  export const ClientAclScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    staffUserId: 'staffUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientAclScalarFieldEnum = (typeof ClientAclScalarFieldEnum)[keyof typeof ClientAclScalarFieldEnum]


  export const ClientStaffPermissionScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    staffUserId: 'staffUserId',
    canSeeTaxes: 'canSeeTaxes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientStaffPermissionScalarFieldEnum = (typeof ClientStaffPermissionScalarFieldEnum)[keyof typeof ClientStaffPermissionScalarFieldEnum]


  export const ClientStaffAssignmentScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    staffUserId: 'staffUserId',
    roleOnClient: 'roleOnClient',
    active: 'active',
    assignedBy: 'assignedBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClientStaffAssignmentScalarFieldEnum = (typeof ClientStaffAssignmentScalarFieldEnum)[keyof typeof ClientStaffAssignmentScalarFieldEnum]


  export const FolderScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    name: 'name',
    parentId: 'parentId',
    folderType: 'folderType',
    isSystem: 'isSystem',
    clientVisible: 'clientVisible',
    staffOnly: 'staffOnly',
    adminOnly: 'adminOnly',
    superAdminOnly: 'superAdminOnly',
    restrictedAcl: 'restrictedAcl',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FolderScalarFieldEnum = (typeof FolderScalarFieldEnum)[keyof typeof FolderScalarFieldEnum]


  export const FolderAclScalarFieldEnum: {
    id: 'id',
    folderId: 'folderId',
    staffUserId: 'staffUserId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FolderAclScalarFieldEnum = (typeof FolderAclScalarFieldEnum)[keyof typeof FolderAclScalarFieldEnum]


  export const DocumentScalarFieldEnum: {
    id: 'id',
    clientId: 'clientId',
    folderId: 'folderId',
    storagePath: 'storagePath',
    displayName: 'displayName',
    uploadedBy: 'uploadedBy',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DocumentScalarFieldEnum = (typeof DocumentScalarFieldEnum)[keyof typeof DocumentScalarFieldEnum]


  export const ChecklistItemScalarFieldEnum: {
    id: 'id',
    entityTaxYearId: 'entityTaxYearId',
    itemName: 'itemName',
    itemType: 'itemType',
    required: 'required',
    status: 'status',
    receivedAt: 'receivedAt',
    markedNotApplicableAt: 'markedNotApplicableAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChecklistItemScalarFieldEnum = (typeof ChecklistItemScalarFieldEnum)[keyof typeof ChecklistItemScalarFieldEnum]


  export const ChecklistItemFileScalarFieldEnum: {
    id: 'id',
    checklistItemId: 'checklistItemId',
    documentId: 'documentId',
    createdAt: 'createdAt'
  };

  export type ChecklistItemFileScalarFieldEnum = (typeof ChecklistItemFileScalarFieldEnum)[keyof typeof ChecklistItemFileScalarFieldEnum]


  export const QuestionnaireSectionScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    order: 'order',
    active: 'active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionnaireSectionScalarFieldEnum = (typeof QuestionnaireSectionScalarFieldEnum)[keyof typeof QuestionnaireSectionScalarFieldEnum]


  export const QuestionnaireQuestionScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    questionText: 'questionText',
    questionType: 'questionType',
    required: 'required',
    order: 'order',
    conditionalLogic: 'conditionalLogic',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionnaireQuestionScalarFieldEnum = (typeof QuestionnaireQuestionScalarFieldEnum)[keyof typeof QuestionnaireQuestionScalarFieldEnum]


  export const QuestionnaireAnswerScalarFieldEnum: {
    id: 'id',
    entityTaxYearId: 'entityTaxYearId',
    questionId: 'questionId',
    answerValue: 'answerValue',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type QuestionnaireAnswerScalarFieldEnum = (typeof QuestionnaireAnswerScalarFieldEnum)[keyof typeof QuestionnaireAnswerScalarFieldEnum]


  export const EngagementSignatureScalarFieldEnum: {
    id: 'id',
    entityTaxYearId: 'entityTaxYearId',
    signerName: 'signerName',
    signerEmail: 'signerEmail',
    signatureData: 'signatureData',
    signedAt: 'signedAt'
  };

  export type EngagementSignatureScalarFieldEnum = (typeof EngagementSignatureScalarFieldEnum)[keyof typeof EngagementSignatureScalarFieldEnum]


  export const EfileAuthorizationScalarFieldEnum: {
    id: 'id',
    entityTaxYearId: 'entityTaxYearId',
    signerName: 'signerName',
    signerEmail: 'signerEmail',
    signatureData: 'signatureData',
    signedAt: 'signedAt'
  };

  export type EfileAuthorizationScalarFieldEnum = (typeof EfileAuthorizationScalarFieldEnum)[keyof typeof EfileAuthorizationScalarFieldEnum]


  export const MessageThreadScalarFieldEnum: {
    id: 'id',
    entityTaxYearId: 'entityTaxYearId',
    archived: 'archived',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageThreadScalarFieldEnum = (typeof MessageThreadScalarFieldEnum)[keyof typeof MessageThreadScalarFieldEnum]


  export const ThreadParticipantScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    userId: 'userId',
    userType: 'userType',
    createdAt: 'createdAt'
  };

  export type ThreadParticipantScalarFieldEnum = (typeof ThreadParticipantScalarFieldEnum)[keyof typeof ThreadParticipantScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    threadId: 'threadId',
    senderId: 'senderId',
    senderType: 'senderType',
    content: 'content',
    read: 'read',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const ReminderStateScalarFieldEnum: {
    id: 'id',
    entityTaxYearId: 'entityTaxYearId',
    reminderType: 'reminderType',
    nextReminderAt: 'nextReminderAt',
    lastReminderAt: 'lastReminderAt',
    reminderCount: 'reminderCount',
    paused: 'paused',
    pausedReason: 'pausedReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReminderStateScalarFieldEnum = (typeof ReminderStateScalarFieldEnum)[keyof typeof ReminderStateScalarFieldEnum]


  export const StatusAuditLogScalarFieldEnum: {
    id: 'id',
    entityTaxYearId: 'entityTaxYearId',
    oldStatus: 'oldStatus',
    newStatus: 'newStatus',
    changedBy: 'changedBy',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type StatusAuditLogScalarFieldEnum = (typeof StatusAuditLogScalarFieldEnum)[keyof typeof StatusAuditLogScalarFieldEnum]


  export const PermissionAuditLogScalarFieldEnum: {
    id: 'id',
    changeType: 'changeType',
    clientId: 'clientId',
    staffUserId: 'staffUserId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    changedBy: 'changedBy',
    reason: 'reason',
    createdAt: 'createdAt'
  };

  export type PermissionAuditLogScalarFieldEnum = (typeof PermissionAuditLogScalarFieldEnum)[keyof typeof PermissionAuditLogScalarFieldEnum]


  export const DocumentEventScalarFieldEnum: {
    id: 'id',
    entityTaxYearId: 'entityTaxYearId',
    eventType: 'eventType',
    documentId: 'documentId',
    description: 'description',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type DocumentEventScalarFieldEnum = (typeof DocumentEventScalarFieldEnum)[keyof typeof DocumentEventScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'UserType'
   */
  export type EnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType'>
    


  /**
   * Reference to a field of type 'UserType[]'
   */
  export type ListEnumUserTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'StaffRole'
   */
  export type EnumStaffRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffRole'>
    


  /**
   * Reference to a field of type 'StaffRole[]'
   */
  export type ListEnumStaffRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'StaffRole[]'>
    


  /**
   * Reference to a field of type 'ClientRole'
   */
  export type EnumClientRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientRole'>
    


  /**
   * Reference to a field of type 'ClientRole[]'
   */
  export type ListEnumClientRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ClientRole[]'>
    


  /**
   * Reference to a field of type 'EntityType'
   */
  export type EnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType'>
    


  /**
   * Reference to a field of type 'EntityType[]'
   */
  export type ListEnumEntityTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EntityType[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'InviteStatus'
   */
  export type EnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus'>
    


  /**
   * Reference to a field of type 'InviteStatus[]'
   */
  export type ListEnumInviteStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InviteStatus[]'>
    


  /**
   * Reference to a field of type 'EngagementStatus'
   */
  export type EnumEngagementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementStatus'>
    


  /**
   * Reference to a field of type 'EngagementStatus[]'
   */
  export type ListEnumEngagementStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EngagementStatus[]'>
    


  /**
   * Reference to a field of type 'ConfirmationStatus'
   */
  export type EnumConfirmationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfirmationStatus'>
    


  /**
   * Reference to a field of type 'ConfirmationStatus[]'
   */
  export type ListEnumConfirmationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ConfirmationStatus[]'>
    


  /**
   * Reference to a field of type 'QuestionnaireStatus'
   */
  export type EnumQuestionnaireStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionnaireStatus'>
    


  /**
   * Reference to a field of type 'QuestionnaireStatus[]'
   */
  export type ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionnaireStatus[]'>
    


  /**
   * Reference to a field of type 'IdStatus'
   */
  export type EnumIdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdStatus'>
    


  /**
   * Reference to a field of type 'IdStatus[]'
   */
  export type ListEnumIdStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IdStatus[]'>
    


  /**
   * Reference to a field of type 'InternalStatus'
   */
  export type EnumInternalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InternalStatus'>
    


  /**
   * Reference to a field of type 'InternalStatus[]'
   */
  export type ListEnumInternalStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InternalStatus[]'>
    


  /**
   * Reference to a field of type 'ChecklistItemStatus'
   */
  export type EnumChecklistItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChecklistItemStatus'>
    


  /**
   * Reference to a field of type 'ChecklistItemStatus[]'
   */
  export type ListEnumChecklistItemStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChecklistItemStatus[]'>
    


  /**
   * Reference to a field of type 'QuestionType'
   */
  export type EnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType'>
    


  /**
   * Reference to a field of type 'QuestionType[]'
   */
  export type ListEnumQuestionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QuestionType[]'>
    


  /**
   * Reference to a field of type 'ReminderType'
   */
  export type EnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType'>
    


  /**
   * Reference to a field of type 'ReminderType[]'
   */
  export type ListEnumReminderTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReminderType[]'>
    


  /**
   * Reference to a field of type 'DocumentEventType'
   */
  export type EnumDocumentEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentEventType'>
    


  /**
   * Reference to a field of type 'DocumentEventType[]'
   */
  export type ListEnumDocumentEventTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DocumentEventType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    staffProfile?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
    staffProfile?: StaffProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    staffProfile?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    userType?: EnumUserTypeFilter<"Profile"> | $Enums.UserType
    fullName?: StringFilter<"Profile"> | string
    email?: StringFilter<"Profile"> | string
    active?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    staffProfile?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    accountUsers?: AccountUserListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    staffProfile?: StaffProfileOrderByWithRelationInput
    accountUsers?: AccountUserOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    userType?: EnumUserTypeFilter<"Profile"> | $Enums.UserType
    fullName?: StringFilter<"Profile"> | string
    email?: StringFilter<"Profile"> | string
    active?: BoolFilter<"Profile"> | boolean
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    staffProfile?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    accountUsers?: AccountUserListRelationFilter
  }, "id" | "userId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    userType?: EnumUserTypeWithAggregatesFilter<"Profile"> | $Enums.UserType
    fullName?: StringWithAggregatesFilter<"Profile"> | string
    email?: StringWithAggregatesFilter<"Profile"> | string
    active?: BoolWithAggregatesFilter<"Profile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type StaffProfileWhereInput = {
    AND?: StaffProfileWhereInput | StaffProfileWhereInput[]
    OR?: StaffProfileWhereInput[]
    NOT?: StaffProfileWhereInput | StaffProfileWhereInput[]
    id?: StringFilter<"StaffProfile"> | string
    userId?: StringFilter<"StaffProfile"> | string
    staffRole?: EnumStaffRoleFilter<"StaffProfile"> | $Enums.StaffRole
    staffTeamReporting?: StringNullableFilter<"StaffProfile"> | string | null
    jobTitle?: StringNullableFilter<"StaffProfile"> | string | null
    phone?: StringNullableFilter<"StaffProfile"> | string | null
    active?: BoolFilter<"StaffProfile"> | boolean
    createdAt?: DateTimeFilter<"StaffProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StaffProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    clientAcl?: ClientAclListRelationFilter
    clientStaffPermissions?: ClientStaffPermissionListRelationFilter
    clientStaffAssignments?: ClientStaffAssignmentListRelationFilter
    folderAcl?: FolderAclListRelationFilter
    uploadedDocuments?: DocumentListRelationFilter
    assignedThreads?: ThreadParticipantListRelationFilter
    sentMessages?: MessageListRelationFilter
    statusAuditLogs?: StatusAuditLogListRelationFilter
    permissionAuditLogs?: PermissionAuditLogListRelationFilter
  }

  export type StaffProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    staffRole?: SortOrder
    staffTeamReporting?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
    clientAcl?: ClientAclOrderByRelationAggregateInput
    clientStaffPermissions?: ClientStaffPermissionOrderByRelationAggregateInput
    clientStaffAssignments?: ClientStaffAssignmentOrderByRelationAggregateInput
    folderAcl?: FolderAclOrderByRelationAggregateInput
    uploadedDocuments?: DocumentOrderByRelationAggregateInput
    assignedThreads?: ThreadParticipantOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    statusAuditLogs?: StatusAuditLogOrderByRelationAggregateInput
    permissionAuditLogs?: PermissionAuditLogOrderByRelationAggregateInput
  }

  export type StaffProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: StaffProfileWhereInput | StaffProfileWhereInput[]
    OR?: StaffProfileWhereInput[]
    NOT?: StaffProfileWhereInput | StaffProfileWhereInput[]
    staffRole?: EnumStaffRoleFilter<"StaffProfile"> | $Enums.StaffRole
    staffTeamReporting?: StringNullableFilter<"StaffProfile"> | string | null
    jobTitle?: StringNullableFilter<"StaffProfile"> | string | null
    phone?: StringNullableFilter<"StaffProfile"> | string | null
    active?: BoolFilter<"StaffProfile"> | boolean
    createdAt?: DateTimeFilter<"StaffProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StaffProfile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    clientAcl?: ClientAclListRelationFilter
    clientStaffPermissions?: ClientStaffPermissionListRelationFilter
    clientStaffAssignments?: ClientStaffAssignmentListRelationFilter
    folderAcl?: FolderAclListRelationFilter
    uploadedDocuments?: DocumentListRelationFilter
    assignedThreads?: ThreadParticipantListRelationFilter
    sentMessages?: MessageListRelationFilter
    statusAuditLogs?: StatusAuditLogListRelationFilter
    permissionAuditLogs?: PermissionAuditLogListRelationFilter
  }, "id" | "userId">

  export type StaffProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    staffRole?: SortOrder
    staffTeamReporting?: SortOrderInput | SortOrder
    jobTitle?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StaffProfileCountOrderByAggregateInput
    _max?: StaffProfileMaxOrderByAggregateInput
    _min?: StaffProfileMinOrderByAggregateInput
  }

  export type StaffProfileScalarWhereWithAggregatesInput = {
    AND?: StaffProfileScalarWhereWithAggregatesInput | StaffProfileScalarWhereWithAggregatesInput[]
    OR?: StaffProfileScalarWhereWithAggregatesInput[]
    NOT?: StaffProfileScalarWhereWithAggregatesInput | StaffProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StaffProfile"> | string
    userId?: StringWithAggregatesFilter<"StaffProfile"> | string
    staffRole?: EnumStaffRoleWithAggregatesFilter<"StaffProfile"> | $Enums.StaffRole
    staffTeamReporting?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    jobTitle?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    phone?: StringNullableWithAggregatesFilter<"StaffProfile"> | string | null
    active?: BoolWithAggregatesFilter<"StaffProfile"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"StaffProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StaffProfile"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    displayName?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    accountUsers?: AccountUserListRelationFilter
    entities?: ClientEntityListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    accountUsers?: AccountUserOrderByRelationAggregateInput
    entities?: ClientEntityOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    displayName?: StringFilter<"Account"> | string
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    accountUsers?: AccountUserListRelationFilter
    entities?: ClientEntityListRelationFilter
  }, "id">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    displayName?: StringWithAggregatesFilter<"Account"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
  }

  export type AccountUserWhereInput = {
    AND?: AccountUserWhereInput | AccountUserWhereInput[]
    OR?: AccountUserWhereInput[]
    NOT?: AccountUserWhereInput | AccountUserWhereInput[]
    id?: StringFilter<"AccountUser"> | string
    accountId?: StringFilter<"AccountUser"> | string
    userId?: StringFilter<"AccountUser"> | string
    clientRole?: EnumClientRoleFilter<"AccountUser"> | $Enums.ClientRole
    createdAt?: DateTimeFilter<"AccountUser"> | Date | string
    updatedAt?: DateTimeFilter<"AccountUser"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }

  export type AccountUserOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    clientRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    profile?: ProfileOrderByWithRelationInput
  }

  export type AccountUserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId_userId?: AccountUserAccountIdUserIdCompoundUniqueInput
    AND?: AccountUserWhereInput | AccountUserWhereInput[]
    OR?: AccountUserWhereInput[]
    NOT?: AccountUserWhereInput | AccountUserWhereInput[]
    accountId?: StringFilter<"AccountUser"> | string
    userId?: StringFilter<"AccountUser"> | string
    clientRole?: EnumClientRoleFilter<"AccountUser"> | $Enums.ClientRole
    createdAt?: DateTimeFilter<"AccountUser"> | Date | string
    updatedAt?: DateTimeFilter<"AccountUser"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    profile?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
  }, "id" | "accountId_userId">

  export type AccountUserOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    clientRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AccountUserCountOrderByAggregateInput
    _max?: AccountUserMaxOrderByAggregateInput
    _min?: AccountUserMinOrderByAggregateInput
  }

  export type AccountUserScalarWhereWithAggregatesInput = {
    AND?: AccountUserScalarWhereWithAggregatesInput | AccountUserScalarWhereWithAggregatesInput[]
    OR?: AccountUserScalarWhereWithAggregatesInput[]
    NOT?: AccountUserScalarWhereWithAggregatesInput | AccountUserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccountUser"> | string
    accountId?: StringWithAggregatesFilter<"AccountUser"> | string
    userId?: StringWithAggregatesFilter<"AccountUser"> | string
    clientRole?: EnumClientRoleWithAggregatesFilter<"AccountUser"> | $Enums.ClientRole
    createdAt?: DateTimeWithAggregatesFilter<"AccountUser"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"AccountUser"> | Date | string
  }

  export type ClientEntityWhereInput = {
    AND?: ClientEntityWhereInput | ClientEntityWhereInput[]
    OR?: ClientEntityWhereInput[]
    NOT?: ClientEntityWhereInput | ClientEntityWhereInput[]
    id?: StringFilter<"ClientEntity"> | string
    accountId?: StringFilter<"ClientEntity"> | string
    entityName?: StringFilter<"ClientEntity"> | string
    entityType?: EnumEntityTypeFilter<"ClientEntity"> | $Enums.EntityType
    status?: StringNullableFilter<"ClientEntity"> | string | null
    isRestricted?: BoolFilter<"ClientEntity"> | boolean
    createdAt?: DateTimeFilter<"ClientEntity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientEntity"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    entityTaxYears?: EntityTaxYearListRelationFilter
    folders?: FolderListRelationFilter
    documents?: DocumentListRelationFilter
    clientAcl?: ClientAclListRelationFilter
    clientStaffPermissions?: ClientStaffPermissionListRelationFilter
    clientStaffAssignments?: ClientStaffAssignmentListRelationFilter
  }

  export type ClientEntityOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    entityName?: SortOrder
    entityType?: SortOrder
    status?: SortOrderInput | SortOrder
    isRestricted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    entityTaxYears?: EntityTaxYearOrderByRelationAggregateInput
    folders?: FolderOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    clientAcl?: ClientAclOrderByRelationAggregateInput
    clientStaffPermissions?: ClientStaffPermissionOrderByRelationAggregateInput
    clientStaffAssignments?: ClientStaffAssignmentOrderByRelationAggregateInput
  }

  export type ClientEntityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientEntityWhereInput | ClientEntityWhereInput[]
    OR?: ClientEntityWhereInput[]
    NOT?: ClientEntityWhereInput | ClientEntityWhereInput[]
    accountId?: StringFilter<"ClientEntity"> | string
    entityName?: StringFilter<"ClientEntity"> | string
    entityType?: EnumEntityTypeFilter<"ClientEntity"> | $Enums.EntityType
    status?: StringNullableFilter<"ClientEntity"> | string | null
    isRestricted?: BoolFilter<"ClientEntity"> | boolean
    createdAt?: DateTimeFilter<"ClientEntity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientEntity"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    entityTaxYears?: EntityTaxYearListRelationFilter
    folders?: FolderListRelationFilter
    documents?: DocumentListRelationFilter
    clientAcl?: ClientAclListRelationFilter
    clientStaffPermissions?: ClientStaffPermissionListRelationFilter
    clientStaffAssignments?: ClientStaffAssignmentListRelationFilter
  }, "id">

  export type ClientEntityOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    entityName?: SortOrder
    entityType?: SortOrder
    status?: SortOrderInput | SortOrder
    isRestricted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientEntityCountOrderByAggregateInput
    _max?: ClientEntityMaxOrderByAggregateInput
    _min?: ClientEntityMinOrderByAggregateInput
  }

  export type ClientEntityScalarWhereWithAggregatesInput = {
    AND?: ClientEntityScalarWhereWithAggregatesInput | ClientEntityScalarWhereWithAggregatesInput[]
    OR?: ClientEntityScalarWhereWithAggregatesInput[]
    NOT?: ClientEntityScalarWhereWithAggregatesInput | ClientEntityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientEntity"> | string
    accountId?: StringWithAggregatesFilter<"ClientEntity"> | string
    entityName?: StringWithAggregatesFilter<"ClientEntity"> | string
    entityType?: EnumEntityTypeWithAggregatesFilter<"ClientEntity"> | $Enums.EntityType
    status?: StringNullableWithAggregatesFilter<"ClientEntity"> | string | null
    isRestricted?: BoolWithAggregatesFilter<"ClientEntity"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClientEntity"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientEntity"> | Date | string
  }

  export type EntityTaxYearWhereInput = {
    AND?: EntityTaxYearWhereInput | EntityTaxYearWhereInput[]
    OR?: EntityTaxYearWhereInput[]
    NOT?: EntityTaxYearWhereInput | EntityTaxYearWhereInput[]
    id?: StringFilter<"EntityTaxYear"> | string
    clientEntityId?: StringFilter<"EntityTaxYear"> | string
    taxYear?: IntFilter<"EntityTaxYear"> | number
    taxReturnExpected?: BoolFilter<"EntityTaxYear"> | boolean
    inviteStatus?: EnumInviteStatusFilter<"EntityTaxYear"> | $Enums.InviteStatus
    inviteSentAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    attemptCount?: IntFilter<"EntityTaxYear"> | number
    lastError?: StringNullableFilter<"EntityTaxYear"> | string | null
    engagementStatus?: EnumEngagementStatusFilter<"EntityTaxYear"> | $Enums.EngagementStatus
    engagementSignedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    engagementSigner1Id?: StringNullableFilter<"EntityTaxYear"> | string | null
    engagementSigner2Id?: StringNullableFilter<"EntityTaxYear"> | string | null
    docsRequiredCount?: IntFilter<"EntityTaxYear"> | number
    docsReceivedCount?: IntFilter<"EntityTaxYear"> | number
    checklistCompleteAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFilter<"EntityTaxYear"> | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    docConfirmationSignerId?: StringNullableFilter<"EntityTaxYear"> | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFilter<"EntityTaxYear"> | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    idStatus?: EnumIdStatusFilter<"EntityTaxYear"> | $Enums.IdStatus
    idValidUntil?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    readyForPrep?: BoolFilter<"EntityTaxYear"> | boolean
    extensionRequested?: BoolFilter<"EntityTaxYear"> | boolean
    extensionFiled?: BoolFilter<"EntityTaxYear"> | boolean
    extendedDueDate?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    internalStatus?: EnumInternalStatusFilter<"EntityTaxYear"> | $Enums.InternalStatus
    createdAt?: DateTimeFilter<"EntityTaxYear"> | Date | string
    updatedAt?: DateTimeFilter<"EntityTaxYear"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    checklistItems?: ChecklistItemListRelationFilter
    questionnaireAnswers?: QuestionnaireAnswerListRelationFilter
    messageThread?: XOR<MessageThreadNullableScalarRelationFilter, MessageThreadWhereInput> | null
    reminderState?: XOR<ReminderStateNullableScalarRelationFilter, ReminderStateWhereInput> | null
    statusAuditLogs?: StatusAuditLogListRelationFilter
    documentEvents?: DocumentEventListRelationFilter
    engagementSignatures?: EngagementSignatureListRelationFilter
    efileAuthorizations?: EfileAuthorizationListRelationFilter
  }

  export type EntityTaxYearOrderByWithRelationInput = {
    id?: SortOrder
    clientEntityId?: SortOrder
    taxYear?: SortOrder
    taxReturnExpected?: SortOrder
    inviteStatus?: SortOrder
    inviteSentAt?: SortOrderInput | SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrderInput | SortOrder
    engagementStatus?: SortOrder
    engagementSignedAt?: SortOrderInput | SortOrder
    engagementSigner1Id?: SortOrderInput | SortOrder
    engagementSigner2Id?: SortOrderInput | SortOrder
    docsRequiredCount?: SortOrder
    docsReceivedCount?: SortOrder
    checklistCompleteAt?: SortOrderInput | SortOrder
    docConfirmationStatus?: SortOrder
    docConfirmationSignedAt?: SortOrderInput | SortOrder
    docConfirmationSignerId?: SortOrderInput | SortOrder
    questionnaireStatus?: SortOrder
    questionnaireCompletedAt?: SortOrderInput | SortOrder
    idStatus?: SortOrder
    idValidUntil?: SortOrderInput | SortOrder
    readyForPrep?: SortOrder
    extensionRequested?: SortOrder
    extensionFiled?: SortOrder
    extendedDueDate?: SortOrderInput | SortOrder
    internalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientEntity?: ClientEntityOrderByWithRelationInput
    checklistItems?: ChecklistItemOrderByRelationAggregateInput
    questionnaireAnswers?: QuestionnaireAnswerOrderByRelationAggregateInput
    messageThread?: MessageThreadOrderByWithRelationInput
    reminderState?: ReminderStateOrderByWithRelationInput
    statusAuditLogs?: StatusAuditLogOrderByRelationAggregateInput
    documentEvents?: DocumentEventOrderByRelationAggregateInput
    engagementSignatures?: EngagementSignatureOrderByRelationAggregateInput
    efileAuthorizations?: EfileAuthorizationOrderByRelationAggregateInput
  }

  export type EntityTaxYearWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientEntityId_taxYear?: EntityTaxYearClientEntityIdTaxYearCompoundUniqueInput
    AND?: EntityTaxYearWhereInput | EntityTaxYearWhereInput[]
    OR?: EntityTaxYearWhereInput[]
    NOT?: EntityTaxYearWhereInput | EntityTaxYearWhereInput[]
    clientEntityId?: StringFilter<"EntityTaxYear"> | string
    taxYear?: IntFilter<"EntityTaxYear"> | number
    taxReturnExpected?: BoolFilter<"EntityTaxYear"> | boolean
    inviteStatus?: EnumInviteStatusFilter<"EntityTaxYear"> | $Enums.InviteStatus
    inviteSentAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    attemptCount?: IntFilter<"EntityTaxYear"> | number
    lastError?: StringNullableFilter<"EntityTaxYear"> | string | null
    engagementStatus?: EnumEngagementStatusFilter<"EntityTaxYear"> | $Enums.EngagementStatus
    engagementSignedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    engagementSigner1Id?: StringNullableFilter<"EntityTaxYear"> | string | null
    engagementSigner2Id?: StringNullableFilter<"EntityTaxYear"> | string | null
    docsRequiredCount?: IntFilter<"EntityTaxYear"> | number
    docsReceivedCount?: IntFilter<"EntityTaxYear"> | number
    checklistCompleteAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFilter<"EntityTaxYear"> | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    docConfirmationSignerId?: StringNullableFilter<"EntityTaxYear"> | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFilter<"EntityTaxYear"> | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    idStatus?: EnumIdStatusFilter<"EntityTaxYear"> | $Enums.IdStatus
    idValidUntil?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    readyForPrep?: BoolFilter<"EntityTaxYear"> | boolean
    extensionRequested?: BoolFilter<"EntityTaxYear"> | boolean
    extensionFiled?: BoolFilter<"EntityTaxYear"> | boolean
    extendedDueDate?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    internalStatus?: EnumInternalStatusFilter<"EntityTaxYear"> | $Enums.InternalStatus
    createdAt?: DateTimeFilter<"EntityTaxYear"> | Date | string
    updatedAt?: DateTimeFilter<"EntityTaxYear"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    checklistItems?: ChecklistItemListRelationFilter
    questionnaireAnswers?: QuestionnaireAnswerListRelationFilter
    messageThread?: XOR<MessageThreadNullableScalarRelationFilter, MessageThreadWhereInput> | null
    reminderState?: XOR<ReminderStateNullableScalarRelationFilter, ReminderStateWhereInput> | null
    statusAuditLogs?: StatusAuditLogListRelationFilter
    documentEvents?: DocumentEventListRelationFilter
    engagementSignatures?: EngagementSignatureListRelationFilter
    efileAuthorizations?: EfileAuthorizationListRelationFilter
  }, "id" | "clientEntityId_taxYear">

  export type EntityTaxYearOrderByWithAggregationInput = {
    id?: SortOrder
    clientEntityId?: SortOrder
    taxYear?: SortOrder
    taxReturnExpected?: SortOrder
    inviteStatus?: SortOrder
    inviteSentAt?: SortOrderInput | SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrderInput | SortOrder
    engagementStatus?: SortOrder
    engagementSignedAt?: SortOrderInput | SortOrder
    engagementSigner1Id?: SortOrderInput | SortOrder
    engagementSigner2Id?: SortOrderInput | SortOrder
    docsRequiredCount?: SortOrder
    docsReceivedCount?: SortOrder
    checklistCompleteAt?: SortOrderInput | SortOrder
    docConfirmationStatus?: SortOrder
    docConfirmationSignedAt?: SortOrderInput | SortOrder
    docConfirmationSignerId?: SortOrderInput | SortOrder
    questionnaireStatus?: SortOrder
    questionnaireCompletedAt?: SortOrderInput | SortOrder
    idStatus?: SortOrder
    idValidUntil?: SortOrderInput | SortOrder
    readyForPrep?: SortOrder
    extensionRequested?: SortOrder
    extensionFiled?: SortOrder
    extendedDueDate?: SortOrderInput | SortOrder
    internalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EntityTaxYearCountOrderByAggregateInput
    _avg?: EntityTaxYearAvgOrderByAggregateInput
    _max?: EntityTaxYearMaxOrderByAggregateInput
    _min?: EntityTaxYearMinOrderByAggregateInput
    _sum?: EntityTaxYearSumOrderByAggregateInput
  }

  export type EntityTaxYearScalarWhereWithAggregatesInput = {
    AND?: EntityTaxYearScalarWhereWithAggregatesInput | EntityTaxYearScalarWhereWithAggregatesInput[]
    OR?: EntityTaxYearScalarWhereWithAggregatesInput[]
    NOT?: EntityTaxYearScalarWhereWithAggregatesInput | EntityTaxYearScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EntityTaxYear"> | string
    clientEntityId?: StringWithAggregatesFilter<"EntityTaxYear"> | string
    taxYear?: IntWithAggregatesFilter<"EntityTaxYear"> | number
    taxReturnExpected?: BoolWithAggregatesFilter<"EntityTaxYear"> | boolean
    inviteStatus?: EnumInviteStatusWithAggregatesFilter<"EntityTaxYear"> | $Enums.InviteStatus
    inviteSentAt?: DateTimeNullableWithAggregatesFilter<"EntityTaxYear"> | Date | string | null
    attemptCount?: IntWithAggregatesFilter<"EntityTaxYear"> | number
    lastError?: StringNullableWithAggregatesFilter<"EntityTaxYear"> | string | null
    engagementStatus?: EnumEngagementStatusWithAggregatesFilter<"EntityTaxYear"> | $Enums.EngagementStatus
    engagementSignedAt?: DateTimeNullableWithAggregatesFilter<"EntityTaxYear"> | Date | string | null
    engagementSigner1Id?: StringNullableWithAggregatesFilter<"EntityTaxYear"> | string | null
    engagementSigner2Id?: StringNullableWithAggregatesFilter<"EntityTaxYear"> | string | null
    docsRequiredCount?: IntWithAggregatesFilter<"EntityTaxYear"> | number
    docsReceivedCount?: IntWithAggregatesFilter<"EntityTaxYear"> | number
    checklistCompleteAt?: DateTimeNullableWithAggregatesFilter<"EntityTaxYear"> | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusWithAggregatesFilter<"EntityTaxYear"> | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: DateTimeNullableWithAggregatesFilter<"EntityTaxYear"> | Date | string | null
    docConfirmationSignerId?: StringNullableWithAggregatesFilter<"EntityTaxYear"> | string | null
    questionnaireStatus?: EnumQuestionnaireStatusWithAggregatesFilter<"EntityTaxYear"> | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: DateTimeNullableWithAggregatesFilter<"EntityTaxYear"> | Date | string | null
    idStatus?: EnumIdStatusWithAggregatesFilter<"EntityTaxYear"> | $Enums.IdStatus
    idValidUntil?: DateTimeNullableWithAggregatesFilter<"EntityTaxYear"> | Date | string | null
    readyForPrep?: BoolWithAggregatesFilter<"EntityTaxYear"> | boolean
    extensionRequested?: BoolWithAggregatesFilter<"EntityTaxYear"> | boolean
    extensionFiled?: BoolWithAggregatesFilter<"EntityTaxYear"> | boolean
    extendedDueDate?: DateTimeNullableWithAggregatesFilter<"EntityTaxYear"> | Date | string | null
    internalStatus?: EnumInternalStatusWithAggregatesFilter<"EntityTaxYear"> | $Enums.InternalStatus
    createdAt?: DateTimeWithAggregatesFilter<"EntityTaxYear"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EntityTaxYear"> | Date | string
  }

  export type ClientAclWhereInput = {
    AND?: ClientAclWhereInput | ClientAclWhereInput[]
    OR?: ClientAclWhereInput[]
    NOT?: ClientAclWhereInput | ClientAclWhereInput[]
    id?: StringFilter<"ClientAcl"> | string
    clientId?: StringFilter<"ClientAcl"> | string
    staffUserId?: StringFilter<"ClientAcl"> | string
    createdAt?: DateTimeFilter<"ClientAcl"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAcl"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }

  export type ClientAclOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientEntity?: ClientEntityOrderByWithRelationInput
    staff?: StaffProfileOrderByWithRelationInput
  }

  export type ClientAclWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_staffUserId?: ClientAclClientIdStaffUserIdCompoundUniqueInput
    AND?: ClientAclWhereInput | ClientAclWhereInput[]
    OR?: ClientAclWhereInput[]
    NOT?: ClientAclWhereInput | ClientAclWhereInput[]
    clientId?: StringFilter<"ClientAcl"> | string
    staffUserId?: StringFilter<"ClientAcl"> | string
    createdAt?: DateTimeFilter<"ClientAcl"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAcl"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }, "id" | "clientId_staffUserId">

  export type ClientAclOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientAclCountOrderByAggregateInput
    _max?: ClientAclMaxOrderByAggregateInput
    _min?: ClientAclMinOrderByAggregateInput
  }

  export type ClientAclScalarWhereWithAggregatesInput = {
    AND?: ClientAclScalarWhereWithAggregatesInput | ClientAclScalarWhereWithAggregatesInput[]
    OR?: ClientAclScalarWhereWithAggregatesInput[]
    NOT?: ClientAclScalarWhereWithAggregatesInput | ClientAclScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientAcl"> | string
    clientId?: StringWithAggregatesFilter<"ClientAcl"> | string
    staffUserId?: StringWithAggregatesFilter<"ClientAcl"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ClientAcl"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientAcl"> | Date | string
  }

  export type ClientStaffPermissionWhereInput = {
    AND?: ClientStaffPermissionWhereInput | ClientStaffPermissionWhereInput[]
    OR?: ClientStaffPermissionWhereInput[]
    NOT?: ClientStaffPermissionWhereInput | ClientStaffPermissionWhereInput[]
    id?: StringFilter<"ClientStaffPermission"> | string
    clientId?: StringFilter<"ClientStaffPermission"> | string
    staffUserId?: StringFilter<"ClientStaffPermission"> | string
    canSeeTaxes?: BoolFilter<"ClientStaffPermission"> | boolean
    createdAt?: DateTimeFilter<"ClientStaffPermission"> | Date | string
    updatedAt?: DateTimeFilter<"ClientStaffPermission"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }

  export type ClientStaffPermissionOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    canSeeTaxes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientEntity?: ClientEntityOrderByWithRelationInput
    staff?: StaffProfileOrderByWithRelationInput
  }

  export type ClientStaffPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clientId_staffUserId?: ClientStaffPermissionClientIdStaffUserIdCompoundUniqueInput
    AND?: ClientStaffPermissionWhereInput | ClientStaffPermissionWhereInput[]
    OR?: ClientStaffPermissionWhereInput[]
    NOT?: ClientStaffPermissionWhereInput | ClientStaffPermissionWhereInput[]
    clientId?: StringFilter<"ClientStaffPermission"> | string
    staffUserId?: StringFilter<"ClientStaffPermission"> | string
    canSeeTaxes?: BoolFilter<"ClientStaffPermission"> | boolean
    createdAt?: DateTimeFilter<"ClientStaffPermission"> | Date | string
    updatedAt?: DateTimeFilter<"ClientStaffPermission"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }, "id" | "clientId_staffUserId">

  export type ClientStaffPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    canSeeTaxes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientStaffPermissionCountOrderByAggregateInput
    _max?: ClientStaffPermissionMaxOrderByAggregateInput
    _min?: ClientStaffPermissionMinOrderByAggregateInput
  }

  export type ClientStaffPermissionScalarWhereWithAggregatesInput = {
    AND?: ClientStaffPermissionScalarWhereWithAggregatesInput | ClientStaffPermissionScalarWhereWithAggregatesInput[]
    OR?: ClientStaffPermissionScalarWhereWithAggregatesInput[]
    NOT?: ClientStaffPermissionScalarWhereWithAggregatesInput | ClientStaffPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientStaffPermission"> | string
    clientId?: StringWithAggregatesFilter<"ClientStaffPermission"> | string
    staffUserId?: StringWithAggregatesFilter<"ClientStaffPermission"> | string
    canSeeTaxes?: BoolWithAggregatesFilter<"ClientStaffPermission"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClientStaffPermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientStaffPermission"> | Date | string
  }

  export type ClientStaffAssignmentWhereInput = {
    AND?: ClientStaffAssignmentWhereInput | ClientStaffAssignmentWhereInput[]
    OR?: ClientStaffAssignmentWhereInput[]
    NOT?: ClientStaffAssignmentWhereInput | ClientStaffAssignmentWhereInput[]
    id?: StringFilter<"ClientStaffAssignment"> | string
    clientId?: StringFilter<"ClientStaffAssignment"> | string
    staffUserId?: StringFilter<"ClientStaffAssignment"> | string
    roleOnClient?: StringFilter<"ClientStaffAssignment"> | string
    active?: BoolFilter<"ClientStaffAssignment"> | boolean
    assignedBy?: StringNullableFilter<"ClientStaffAssignment"> | string | null
    createdAt?: DateTimeFilter<"ClientStaffAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ClientStaffAssignment"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }

  export type ClientStaffAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    roleOnClient?: SortOrder
    active?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientEntity?: ClientEntityOrderByWithRelationInput
    staff?: StaffProfileOrderByWithRelationInput
  }

  export type ClientStaffAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClientStaffAssignmentWhereInput | ClientStaffAssignmentWhereInput[]
    OR?: ClientStaffAssignmentWhereInput[]
    NOT?: ClientStaffAssignmentWhereInput | ClientStaffAssignmentWhereInput[]
    clientId?: StringFilter<"ClientStaffAssignment"> | string
    staffUserId?: StringFilter<"ClientStaffAssignment"> | string
    roleOnClient?: StringFilter<"ClientStaffAssignment"> | string
    active?: BoolFilter<"ClientStaffAssignment"> | boolean
    assignedBy?: StringNullableFilter<"ClientStaffAssignment"> | string | null
    createdAt?: DateTimeFilter<"ClientStaffAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ClientStaffAssignment"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }, "id">

  export type ClientStaffAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    roleOnClient?: SortOrder
    active?: SortOrder
    assignedBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClientStaffAssignmentCountOrderByAggregateInput
    _max?: ClientStaffAssignmentMaxOrderByAggregateInput
    _min?: ClientStaffAssignmentMinOrderByAggregateInput
  }

  export type ClientStaffAssignmentScalarWhereWithAggregatesInput = {
    AND?: ClientStaffAssignmentScalarWhereWithAggregatesInput | ClientStaffAssignmentScalarWhereWithAggregatesInput[]
    OR?: ClientStaffAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ClientStaffAssignmentScalarWhereWithAggregatesInput | ClientStaffAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClientStaffAssignment"> | string
    clientId?: StringWithAggregatesFilter<"ClientStaffAssignment"> | string
    staffUserId?: StringWithAggregatesFilter<"ClientStaffAssignment"> | string
    roleOnClient?: StringWithAggregatesFilter<"ClientStaffAssignment"> | string
    active?: BoolWithAggregatesFilter<"ClientStaffAssignment"> | boolean
    assignedBy?: StringNullableWithAggregatesFilter<"ClientStaffAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ClientStaffAssignment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClientStaffAssignment"> | Date | string
  }

  export type FolderWhereInput = {
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    id?: StringFilter<"Folder"> | string
    clientId?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    parentId?: StringNullableFilter<"Folder"> | string | null
    folderType?: StringNullableFilter<"Folder"> | string | null
    isSystem?: BoolFilter<"Folder"> | boolean
    clientVisible?: BoolFilter<"Folder"> | boolean
    staffOnly?: BoolFilter<"Folder"> | boolean
    adminOnly?: BoolFilter<"Folder"> | boolean
    superAdminOnly?: BoolFilter<"Folder"> | boolean
    restrictedAcl?: BoolFilter<"Folder"> | boolean
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    children?: FolderListRelationFilter
    documents?: DocumentListRelationFilter
    folderAcl?: FolderAclListRelationFilter
  }

  export type FolderOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    folderType?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    clientVisible?: SortOrder
    staffOnly?: SortOrder
    adminOnly?: SortOrder
    superAdminOnly?: SortOrder
    restrictedAcl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientEntity?: ClientEntityOrderByWithRelationInput
    parent?: FolderOrderByWithRelationInput
    children?: FolderOrderByRelationAggregateInput
    documents?: DocumentOrderByRelationAggregateInput
    folderAcl?: FolderAclOrderByRelationAggregateInput
  }

  export type FolderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FolderWhereInput | FolderWhereInput[]
    OR?: FolderWhereInput[]
    NOT?: FolderWhereInput | FolderWhereInput[]
    clientId?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    parentId?: StringNullableFilter<"Folder"> | string | null
    folderType?: StringNullableFilter<"Folder"> | string | null
    isSystem?: BoolFilter<"Folder"> | boolean
    clientVisible?: BoolFilter<"Folder"> | boolean
    staffOnly?: BoolFilter<"Folder"> | boolean
    adminOnly?: BoolFilter<"Folder"> | boolean
    superAdminOnly?: BoolFilter<"Folder"> | boolean
    restrictedAcl?: BoolFilter<"Folder"> | boolean
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    parent?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    children?: FolderListRelationFilter
    documents?: DocumentListRelationFilter
    folderAcl?: FolderAclListRelationFilter
  }, "id">

  export type FolderOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    parentId?: SortOrderInput | SortOrder
    folderType?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    clientVisible?: SortOrder
    staffOnly?: SortOrder
    adminOnly?: SortOrder
    superAdminOnly?: SortOrder
    restrictedAcl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FolderCountOrderByAggregateInput
    _max?: FolderMaxOrderByAggregateInput
    _min?: FolderMinOrderByAggregateInput
  }

  export type FolderScalarWhereWithAggregatesInput = {
    AND?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    OR?: FolderScalarWhereWithAggregatesInput[]
    NOT?: FolderScalarWhereWithAggregatesInput | FolderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Folder"> | string
    clientId?: StringWithAggregatesFilter<"Folder"> | string
    name?: StringWithAggregatesFilter<"Folder"> | string
    parentId?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    folderType?: StringNullableWithAggregatesFilter<"Folder"> | string | null
    isSystem?: BoolWithAggregatesFilter<"Folder"> | boolean
    clientVisible?: BoolWithAggregatesFilter<"Folder"> | boolean
    staffOnly?: BoolWithAggregatesFilter<"Folder"> | boolean
    adminOnly?: BoolWithAggregatesFilter<"Folder"> | boolean
    superAdminOnly?: BoolWithAggregatesFilter<"Folder"> | boolean
    restrictedAcl?: BoolWithAggregatesFilter<"Folder"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Folder"> | Date | string
  }

  export type FolderAclWhereInput = {
    AND?: FolderAclWhereInput | FolderAclWhereInput[]
    OR?: FolderAclWhereInput[]
    NOT?: FolderAclWhereInput | FolderAclWhereInput[]
    id?: StringFilter<"FolderAcl"> | string
    folderId?: StringFilter<"FolderAcl"> | string
    staffUserId?: StringFilter<"FolderAcl"> | string
    createdAt?: DateTimeFilter<"FolderAcl"> | Date | string
    updatedAt?: DateTimeFilter<"FolderAcl"> | Date | string
    folder?: XOR<FolderScalarRelationFilter, FolderWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }

  export type FolderAclOrderByWithRelationInput = {
    id?: SortOrder
    folderId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    folder?: FolderOrderByWithRelationInput
    staff?: StaffProfileOrderByWithRelationInput
  }

  export type FolderAclWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    folderId_staffUserId?: FolderAclFolderIdStaffUserIdCompoundUniqueInput
    AND?: FolderAclWhereInput | FolderAclWhereInput[]
    OR?: FolderAclWhereInput[]
    NOT?: FolderAclWhereInput | FolderAclWhereInput[]
    folderId?: StringFilter<"FolderAcl"> | string
    staffUserId?: StringFilter<"FolderAcl"> | string
    createdAt?: DateTimeFilter<"FolderAcl"> | Date | string
    updatedAt?: DateTimeFilter<"FolderAcl"> | Date | string
    folder?: XOR<FolderScalarRelationFilter, FolderWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }, "id" | "folderId_staffUserId">

  export type FolderAclOrderByWithAggregationInput = {
    id?: SortOrder
    folderId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FolderAclCountOrderByAggregateInput
    _max?: FolderAclMaxOrderByAggregateInput
    _min?: FolderAclMinOrderByAggregateInput
  }

  export type FolderAclScalarWhereWithAggregatesInput = {
    AND?: FolderAclScalarWhereWithAggregatesInput | FolderAclScalarWhereWithAggregatesInput[]
    OR?: FolderAclScalarWhereWithAggregatesInput[]
    NOT?: FolderAclScalarWhereWithAggregatesInput | FolderAclScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FolderAcl"> | string
    folderId?: StringWithAggregatesFilter<"FolderAcl"> | string
    staffUserId?: StringWithAggregatesFilter<"FolderAcl"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FolderAcl"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FolderAcl"> | Date | string
  }

  export type DocumentWhereInput = {
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    id?: StringFilter<"Document"> | string
    clientId?: StringFilter<"Document"> | string
    folderId?: StringNullableFilter<"Document"> | string | null
    storagePath?: StringFilter<"Document"> | string
    displayName?: StringFilter<"Document"> | string
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    uploader?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    checklistItems?: ChecklistItemFileListRelationFilter
  }

  export type DocumentOrderByWithRelationInput = {
    id?: SortOrder
    clientId?: SortOrder
    folderId?: SortOrderInput | SortOrder
    storagePath?: SortOrder
    displayName?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clientEntity?: ClientEntityOrderByWithRelationInput
    folder?: FolderOrderByWithRelationInput
    uploader?: StaffProfileOrderByWithRelationInput
    checklistItems?: ChecklistItemFileOrderByRelationAggregateInput
  }

  export type DocumentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentWhereInput | DocumentWhereInput[]
    OR?: DocumentWhereInput[]
    NOT?: DocumentWhereInput | DocumentWhereInput[]
    clientId?: StringFilter<"Document"> | string
    folderId?: StringNullableFilter<"Document"> | string | null
    storagePath?: StringFilter<"Document"> | string
    displayName?: StringFilter<"Document"> | string
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
    clientEntity?: XOR<ClientEntityScalarRelationFilter, ClientEntityWhereInput>
    folder?: XOR<FolderNullableScalarRelationFilter, FolderWhereInput> | null
    uploader?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
    checklistItems?: ChecklistItemFileListRelationFilter
  }, "id">

  export type DocumentOrderByWithAggregationInput = {
    id?: SortOrder
    clientId?: SortOrder
    folderId?: SortOrderInput | SortOrder
    storagePath?: SortOrder
    displayName?: SortOrder
    uploadedBy?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DocumentCountOrderByAggregateInput
    _avg?: DocumentAvgOrderByAggregateInput
    _max?: DocumentMaxOrderByAggregateInput
    _min?: DocumentMinOrderByAggregateInput
    _sum?: DocumentSumOrderByAggregateInput
  }

  export type DocumentScalarWhereWithAggregatesInput = {
    AND?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    OR?: DocumentScalarWhereWithAggregatesInput[]
    NOT?: DocumentScalarWhereWithAggregatesInput | DocumentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Document"> | string
    clientId?: StringWithAggregatesFilter<"Document"> | string
    folderId?: StringNullableWithAggregatesFilter<"Document"> | string | null
    storagePath?: StringWithAggregatesFilter<"Document"> | string
    displayName?: StringWithAggregatesFilter<"Document"> | string
    uploadedBy?: StringNullableWithAggregatesFilter<"Document"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"Document"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Document"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Document"> | Date | string
  }

  export type ChecklistItemWhereInput = {
    AND?: ChecklistItemWhereInput | ChecklistItemWhereInput[]
    OR?: ChecklistItemWhereInput[]
    NOT?: ChecklistItemWhereInput | ChecklistItemWhereInput[]
    id?: StringFilter<"ChecklistItem"> | string
    entityTaxYearId?: StringFilter<"ChecklistItem"> | string
    itemName?: StringFilter<"ChecklistItem"> | string
    itemType?: StringNullableFilter<"ChecklistItem"> | string | null
    required?: BoolFilter<"ChecklistItem"> | boolean
    status?: EnumChecklistItemStatusFilter<"ChecklistItem"> | $Enums.ChecklistItemStatus
    receivedAt?: DateTimeNullableFilter<"ChecklistItem"> | Date | string | null
    markedNotApplicableAt?: DateTimeNullableFilter<"ChecklistItem"> | Date | string | null
    notes?: StringNullableFilter<"ChecklistItem"> | string | null
    createdAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
    files?: ChecklistItemFileListRelationFilter
  }

  export type ChecklistItemOrderByWithRelationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrderInput | SortOrder
    required?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    markedNotApplicableAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entityTaxYear?: EntityTaxYearOrderByWithRelationInput
    files?: ChecklistItemFileOrderByRelationAggregateInput
  }

  export type ChecklistItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChecklistItemWhereInput | ChecklistItemWhereInput[]
    OR?: ChecklistItemWhereInput[]
    NOT?: ChecklistItemWhereInput | ChecklistItemWhereInput[]
    entityTaxYearId?: StringFilter<"ChecklistItem"> | string
    itemName?: StringFilter<"ChecklistItem"> | string
    itemType?: StringNullableFilter<"ChecklistItem"> | string | null
    required?: BoolFilter<"ChecklistItem"> | boolean
    status?: EnumChecklistItemStatusFilter<"ChecklistItem"> | $Enums.ChecklistItemStatus
    receivedAt?: DateTimeNullableFilter<"ChecklistItem"> | Date | string | null
    markedNotApplicableAt?: DateTimeNullableFilter<"ChecklistItem"> | Date | string | null
    notes?: StringNullableFilter<"ChecklistItem"> | string | null
    createdAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
    files?: ChecklistItemFileListRelationFilter
  }, "id">

  export type ChecklistItemOrderByWithAggregationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrderInput | SortOrder
    required?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrderInput | SortOrder
    markedNotApplicableAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChecklistItemCountOrderByAggregateInput
    _max?: ChecklistItemMaxOrderByAggregateInput
    _min?: ChecklistItemMinOrderByAggregateInput
  }

  export type ChecklistItemScalarWhereWithAggregatesInput = {
    AND?: ChecklistItemScalarWhereWithAggregatesInput | ChecklistItemScalarWhereWithAggregatesInput[]
    OR?: ChecklistItemScalarWhereWithAggregatesInput[]
    NOT?: ChecklistItemScalarWhereWithAggregatesInput | ChecklistItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChecklistItem"> | string
    entityTaxYearId?: StringWithAggregatesFilter<"ChecklistItem"> | string
    itemName?: StringWithAggregatesFilter<"ChecklistItem"> | string
    itemType?: StringNullableWithAggregatesFilter<"ChecklistItem"> | string | null
    required?: BoolWithAggregatesFilter<"ChecklistItem"> | boolean
    status?: EnumChecklistItemStatusWithAggregatesFilter<"ChecklistItem"> | $Enums.ChecklistItemStatus
    receivedAt?: DateTimeNullableWithAggregatesFilter<"ChecklistItem"> | Date | string | null
    markedNotApplicableAt?: DateTimeNullableWithAggregatesFilter<"ChecklistItem"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"ChecklistItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChecklistItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChecklistItem"> | Date | string
  }

  export type ChecklistItemFileWhereInput = {
    AND?: ChecklistItemFileWhereInput | ChecklistItemFileWhereInput[]
    OR?: ChecklistItemFileWhereInput[]
    NOT?: ChecklistItemFileWhereInput | ChecklistItemFileWhereInput[]
    id?: StringFilter<"ChecklistItemFile"> | string
    checklistItemId?: StringFilter<"ChecklistItemFile"> | string
    documentId?: StringFilter<"ChecklistItemFile"> | string
    createdAt?: DateTimeFilter<"ChecklistItemFile"> | Date | string
    checklistItem?: XOR<ChecklistItemScalarRelationFilter, ChecklistItemWhereInput>
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }

  export type ChecklistItemFileOrderByWithRelationInput = {
    id?: SortOrder
    checklistItemId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    checklistItem?: ChecklistItemOrderByWithRelationInput
    document?: DocumentOrderByWithRelationInput
  }

  export type ChecklistItemFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    checklistItemId_documentId?: ChecklistItemFileChecklistItemIdDocumentIdCompoundUniqueInput
    AND?: ChecklistItemFileWhereInput | ChecklistItemFileWhereInput[]
    OR?: ChecklistItemFileWhereInput[]
    NOT?: ChecklistItemFileWhereInput | ChecklistItemFileWhereInput[]
    checklistItemId?: StringFilter<"ChecklistItemFile"> | string
    documentId?: StringFilter<"ChecklistItemFile"> | string
    createdAt?: DateTimeFilter<"ChecklistItemFile"> | Date | string
    checklistItem?: XOR<ChecklistItemScalarRelationFilter, ChecklistItemWhereInput>
    document?: XOR<DocumentScalarRelationFilter, DocumentWhereInput>
  }, "id" | "checklistItemId_documentId">

  export type ChecklistItemFileOrderByWithAggregationInput = {
    id?: SortOrder
    checklistItemId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
    _count?: ChecklistItemFileCountOrderByAggregateInput
    _max?: ChecklistItemFileMaxOrderByAggregateInput
    _min?: ChecklistItemFileMinOrderByAggregateInput
  }

  export type ChecklistItemFileScalarWhereWithAggregatesInput = {
    AND?: ChecklistItemFileScalarWhereWithAggregatesInput | ChecklistItemFileScalarWhereWithAggregatesInput[]
    OR?: ChecklistItemFileScalarWhereWithAggregatesInput[]
    NOT?: ChecklistItemFileScalarWhereWithAggregatesInput | ChecklistItemFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChecklistItemFile"> | string
    checklistItemId?: StringWithAggregatesFilter<"ChecklistItemFile"> | string
    documentId?: StringWithAggregatesFilter<"ChecklistItemFile"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChecklistItemFile"> | Date | string
  }

  export type QuestionnaireSectionWhereInput = {
    AND?: QuestionnaireSectionWhereInput | QuestionnaireSectionWhereInput[]
    OR?: QuestionnaireSectionWhereInput[]
    NOT?: QuestionnaireSectionWhereInput | QuestionnaireSectionWhereInput[]
    id?: StringFilter<"QuestionnaireSection"> | string
    name?: StringFilter<"QuestionnaireSection"> | string
    description?: StringNullableFilter<"QuestionnaireSection"> | string | null
    order?: IntFilter<"QuestionnaireSection"> | number
    active?: BoolFilter<"QuestionnaireSection"> | boolean
    createdAt?: DateTimeFilter<"QuestionnaireSection"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireSection"> | Date | string
    questions?: QuestionnaireQuestionListRelationFilter
  }

  export type QuestionnaireSectionOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    questions?: QuestionnaireQuestionOrderByRelationAggregateInput
  }

  export type QuestionnaireSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionnaireSectionWhereInput | QuestionnaireSectionWhereInput[]
    OR?: QuestionnaireSectionWhereInput[]
    NOT?: QuestionnaireSectionWhereInput | QuestionnaireSectionWhereInput[]
    name?: StringFilter<"QuestionnaireSection"> | string
    description?: StringNullableFilter<"QuestionnaireSection"> | string | null
    order?: IntFilter<"QuestionnaireSection"> | number
    active?: BoolFilter<"QuestionnaireSection"> | boolean
    createdAt?: DateTimeFilter<"QuestionnaireSection"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireSection"> | Date | string
    questions?: QuestionnaireQuestionListRelationFilter
  }, "id">

  export type QuestionnaireSectionOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionnaireSectionCountOrderByAggregateInput
    _avg?: QuestionnaireSectionAvgOrderByAggregateInput
    _max?: QuestionnaireSectionMaxOrderByAggregateInput
    _min?: QuestionnaireSectionMinOrderByAggregateInput
    _sum?: QuestionnaireSectionSumOrderByAggregateInput
  }

  export type QuestionnaireSectionScalarWhereWithAggregatesInput = {
    AND?: QuestionnaireSectionScalarWhereWithAggregatesInput | QuestionnaireSectionScalarWhereWithAggregatesInput[]
    OR?: QuestionnaireSectionScalarWhereWithAggregatesInput[]
    NOT?: QuestionnaireSectionScalarWhereWithAggregatesInput | QuestionnaireSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionnaireSection"> | string
    name?: StringWithAggregatesFilter<"QuestionnaireSection"> | string
    description?: StringNullableWithAggregatesFilter<"QuestionnaireSection"> | string | null
    order?: IntWithAggregatesFilter<"QuestionnaireSection"> | number
    active?: BoolWithAggregatesFilter<"QuestionnaireSection"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"QuestionnaireSection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionnaireSection"> | Date | string
  }

  export type QuestionnaireQuestionWhereInput = {
    AND?: QuestionnaireQuestionWhereInput | QuestionnaireQuestionWhereInput[]
    OR?: QuestionnaireQuestionWhereInput[]
    NOT?: QuestionnaireQuestionWhereInput | QuestionnaireQuestionWhereInput[]
    id?: StringFilter<"QuestionnaireQuestion"> | string
    sectionId?: StringFilter<"QuestionnaireQuestion"> | string
    questionText?: StringFilter<"QuestionnaireQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"QuestionnaireQuestion"> | $Enums.QuestionType
    required?: BoolFilter<"QuestionnaireQuestion"> | boolean
    order?: IntFilter<"QuestionnaireQuestion"> | number
    conditionalLogic?: StringNullableFilter<"QuestionnaireQuestion"> | string | null
    createdAt?: DateTimeFilter<"QuestionnaireQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireQuestion"> | Date | string
    section?: XOR<QuestionnaireSectionScalarRelationFilter, QuestionnaireSectionWhereInput>
    answers?: QuestionnaireAnswerListRelationFilter
  }

  export type QuestionnaireQuestionOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    section?: QuestionnaireSectionOrderByWithRelationInput
    answers?: QuestionnaireAnswerOrderByRelationAggregateInput
  }

  export type QuestionnaireQuestionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: QuestionnaireQuestionWhereInput | QuestionnaireQuestionWhereInput[]
    OR?: QuestionnaireQuestionWhereInput[]
    NOT?: QuestionnaireQuestionWhereInput | QuestionnaireQuestionWhereInput[]
    sectionId?: StringFilter<"QuestionnaireQuestion"> | string
    questionText?: StringFilter<"QuestionnaireQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"QuestionnaireQuestion"> | $Enums.QuestionType
    required?: BoolFilter<"QuestionnaireQuestion"> | boolean
    order?: IntFilter<"QuestionnaireQuestion"> | number
    conditionalLogic?: StringNullableFilter<"QuestionnaireQuestion"> | string | null
    createdAt?: DateTimeFilter<"QuestionnaireQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireQuestion"> | Date | string
    section?: XOR<QuestionnaireSectionScalarRelationFilter, QuestionnaireSectionWhereInput>
    answers?: QuestionnaireAnswerListRelationFilter
  }, "id">

  export type QuestionnaireQuestionOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionnaireQuestionCountOrderByAggregateInput
    _avg?: QuestionnaireQuestionAvgOrderByAggregateInput
    _max?: QuestionnaireQuestionMaxOrderByAggregateInput
    _min?: QuestionnaireQuestionMinOrderByAggregateInput
    _sum?: QuestionnaireQuestionSumOrderByAggregateInput
  }

  export type QuestionnaireQuestionScalarWhereWithAggregatesInput = {
    AND?: QuestionnaireQuestionScalarWhereWithAggregatesInput | QuestionnaireQuestionScalarWhereWithAggregatesInput[]
    OR?: QuestionnaireQuestionScalarWhereWithAggregatesInput[]
    NOT?: QuestionnaireQuestionScalarWhereWithAggregatesInput | QuestionnaireQuestionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionnaireQuestion"> | string
    sectionId?: StringWithAggregatesFilter<"QuestionnaireQuestion"> | string
    questionText?: StringWithAggregatesFilter<"QuestionnaireQuestion"> | string
    questionType?: EnumQuestionTypeWithAggregatesFilter<"QuestionnaireQuestion"> | $Enums.QuestionType
    required?: BoolWithAggregatesFilter<"QuestionnaireQuestion"> | boolean
    order?: IntWithAggregatesFilter<"QuestionnaireQuestion"> | number
    conditionalLogic?: StringNullableWithAggregatesFilter<"QuestionnaireQuestion"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuestionnaireQuestion"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionnaireQuestion"> | Date | string
  }

  export type QuestionnaireAnswerWhereInput = {
    AND?: QuestionnaireAnswerWhereInput | QuestionnaireAnswerWhereInput[]
    OR?: QuestionnaireAnswerWhereInput[]
    NOT?: QuestionnaireAnswerWhereInput | QuestionnaireAnswerWhereInput[]
    id?: StringFilter<"QuestionnaireAnswer"> | string
    entityTaxYearId?: StringFilter<"QuestionnaireAnswer"> | string
    questionId?: StringFilter<"QuestionnaireAnswer"> | string
    answerValue?: StringNullableFilter<"QuestionnaireAnswer"> | string | null
    createdAt?: DateTimeFilter<"QuestionnaireAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireAnswer"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
    question?: XOR<QuestionnaireQuestionScalarRelationFilter, QuestionnaireQuestionWhereInput>
  }

  export type QuestionnaireAnswerOrderByWithRelationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    questionId?: SortOrder
    answerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entityTaxYear?: EntityTaxYearOrderByWithRelationInput
    question?: QuestionnaireQuestionOrderByWithRelationInput
  }

  export type QuestionnaireAnswerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityTaxYearId_questionId?: QuestionnaireAnswerEntityTaxYearIdQuestionIdCompoundUniqueInput
    AND?: QuestionnaireAnswerWhereInput | QuestionnaireAnswerWhereInput[]
    OR?: QuestionnaireAnswerWhereInput[]
    NOT?: QuestionnaireAnswerWhereInput | QuestionnaireAnswerWhereInput[]
    entityTaxYearId?: StringFilter<"QuestionnaireAnswer"> | string
    questionId?: StringFilter<"QuestionnaireAnswer"> | string
    answerValue?: StringNullableFilter<"QuestionnaireAnswer"> | string | null
    createdAt?: DateTimeFilter<"QuestionnaireAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireAnswer"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
    question?: XOR<QuestionnaireQuestionScalarRelationFilter, QuestionnaireQuestionWhereInput>
  }, "id" | "entityTaxYearId_questionId">

  export type QuestionnaireAnswerOrderByWithAggregationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    questionId?: SortOrder
    answerValue?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: QuestionnaireAnswerCountOrderByAggregateInput
    _max?: QuestionnaireAnswerMaxOrderByAggregateInput
    _min?: QuestionnaireAnswerMinOrderByAggregateInput
  }

  export type QuestionnaireAnswerScalarWhereWithAggregatesInput = {
    AND?: QuestionnaireAnswerScalarWhereWithAggregatesInput | QuestionnaireAnswerScalarWhereWithAggregatesInput[]
    OR?: QuestionnaireAnswerScalarWhereWithAggregatesInput[]
    NOT?: QuestionnaireAnswerScalarWhereWithAggregatesInput | QuestionnaireAnswerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"QuestionnaireAnswer"> | string
    entityTaxYearId?: StringWithAggregatesFilter<"QuestionnaireAnswer"> | string
    questionId?: StringWithAggregatesFilter<"QuestionnaireAnswer"> | string
    answerValue?: StringNullableWithAggregatesFilter<"QuestionnaireAnswer"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"QuestionnaireAnswer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"QuestionnaireAnswer"> | Date | string
  }

  export type EngagementSignatureWhereInput = {
    AND?: EngagementSignatureWhereInput | EngagementSignatureWhereInput[]
    OR?: EngagementSignatureWhereInput[]
    NOT?: EngagementSignatureWhereInput | EngagementSignatureWhereInput[]
    id?: StringFilter<"EngagementSignature"> | string
    entityTaxYearId?: StringFilter<"EngagementSignature"> | string
    signerName?: StringFilter<"EngagementSignature"> | string
    signerEmail?: StringFilter<"EngagementSignature"> | string
    signatureData?: StringFilter<"EngagementSignature"> | string
    signedAt?: DateTimeFilter<"EngagementSignature"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
  }

  export type EngagementSignatureOrderByWithRelationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
    entityTaxYear?: EntityTaxYearOrderByWithRelationInput
  }

  export type EngagementSignatureWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EngagementSignatureWhereInput | EngagementSignatureWhereInput[]
    OR?: EngagementSignatureWhereInput[]
    NOT?: EngagementSignatureWhereInput | EngagementSignatureWhereInput[]
    entityTaxYearId?: StringFilter<"EngagementSignature"> | string
    signerName?: StringFilter<"EngagementSignature"> | string
    signerEmail?: StringFilter<"EngagementSignature"> | string
    signatureData?: StringFilter<"EngagementSignature"> | string
    signedAt?: DateTimeFilter<"EngagementSignature"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
  }, "id">

  export type EngagementSignatureOrderByWithAggregationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
    _count?: EngagementSignatureCountOrderByAggregateInput
    _max?: EngagementSignatureMaxOrderByAggregateInput
    _min?: EngagementSignatureMinOrderByAggregateInput
  }

  export type EngagementSignatureScalarWhereWithAggregatesInput = {
    AND?: EngagementSignatureScalarWhereWithAggregatesInput | EngagementSignatureScalarWhereWithAggregatesInput[]
    OR?: EngagementSignatureScalarWhereWithAggregatesInput[]
    NOT?: EngagementSignatureScalarWhereWithAggregatesInput | EngagementSignatureScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EngagementSignature"> | string
    entityTaxYearId?: StringWithAggregatesFilter<"EngagementSignature"> | string
    signerName?: StringWithAggregatesFilter<"EngagementSignature"> | string
    signerEmail?: StringWithAggregatesFilter<"EngagementSignature"> | string
    signatureData?: StringWithAggregatesFilter<"EngagementSignature"> | string
    signedAt?: DateTimeWithAggregatesFilter<"EngagementSignature"> | Date | string
  }

  export type EfileAuthorizationWhereInput = {
    AND?: EfileAuthorizationWhereInput | EfileAuthorizationWhereInput[]
    OR?: EfileAuthorizationWhereInput[]
    NOT?: EfileAuthorizationWhereInput | EfileAuthorizationWhereInput[]
    id?: StringFilter<"EfileAuthorization"> | string
    entityTaxYearId?: StringFilter<"EfileAuthorization"> | string
    signerName?: StringFilter<"EfileAuthorization"> | string
    signerEmail?: StringFilter<"EfileAuthorization"> | string
    signatureData?: StringFilter<"EfileAuthorization"> | string
    signedAt?: DateTimeFilter<"EfileAuthorization"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
  }

  export type EfileAuthorizationOrderByWithRelationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
    entityTaxYear?: EntityTaxYearOrderByWithRelationInput
  }

  export type EfileAuthorizationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EfileAuthorizationWhereInput | EfileAuthorizationWhereInput[]
    OR?: EfileAuthorizationWhereInput[]
    NOT?: EfileAuthorizationWhereInput | EfileAuthorizationWhereInput[]
    entityTaxYearId?: StringFilter<"EfileAuthorization"> | string
    signerName?: StringFilter<"EfileAuthorization"> | string
    signerEmail?: StringFilter<"EfileAuthorization"> | string
    signatureData?: StringFilter<"EfileAuthorization"> | string
    signedAt?: DateTimeFilter<"EfileAuthorization"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
  }, "id">

  export type EfileAuthorizationOrderByWithAggregationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
    _count?: EfileAuthorizationCountOrderByAggregateInput
    _max?: EfileAuthorizationMaxOrderByAggregateInput
    _min?: EfileAuthorizationMinOrderByAggregateInput
  }

  export type EfileAuthorizationScalarWhereWithAggregatesInput = {
    AND?: EfileAuthorizationScalarWhereWithAggregatesInput | EfileAuthorizationScalarWhereWithAggregatesInput[]
    OR?: EfileAuthorizationScalarWhereWithAggregatesInput[]
    NOT?: EfileAuthorizationScalarWhereWithAggregatesInput | EfileAuthorizationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EfileAuthorization"> | string
    entityTaxYearId?: StringWithAggregatesFilter<"EfileAuthorization"> | string
    signerName?: StringWithAggregatesFilter<"EfileAuthorization"> | string
    signerEmail?: StringWithAggregatesFilter<"EfileAuthorization"> | string
    signatureData?: StringWithAggregatesFilter<"EfileAuthorization"> | string
    signedAt?: DateTimeWithAggregatesFilter<"EfileAuthorization"> | Date | string
  }

  export type MessageThreadWhereInput = {
    AND?: MessageThreadWhereInput | MessageThreadWhereInput[]
    OR?: MessageThreadWhereInput[]
    NOT?: MessageThreadWhereInput | MessageThreadWhereInput[]
    id?: StringFilter<"MessageThread"> | string
    entityTaxYearId?: StringFilter<"MessageThread"> | string
    archived?: BoolFilter<"MessageThread"> | boolean
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
    updatedAt?: DateTimeFilter<"MessageThread"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
    participants?: ThreadParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }

  export type MessageThreadOrderByWithRelationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entityTaxYear?: EntityTaxYearOrderByWithRelationInput
    participants?: ThreadParticipantOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
  }

  export type MessageThreadWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityTaxYearId?: string
    AND?: MessageThreadWhereInput | MessageThreadWhereInput[]
    OR?: MessageThreadWhereInput[]
    NOT?: MessageThreadWhereInput | MessageThreadWhereInput[]
    archived?: BoolFilter<"MessageThread"> | boolean
    createdAt?: DateTimeFilter<"MessageThread"> | Date | string
    updatedAt?: DateTimeFilter<"MessageThread"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
    participants?: ThreadParticipantListRelationFilter
    messages?: MessageListRelationFilter
  }, "id" | "entityTaxYearId">

  export type MessageThreadOrderByWithAggregationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageThreadCountOrderByAggregateInput
    _max?: MessageThreadMaxOrderByAggregateInput
    _min?: MessageThreadMinOrderByAggregateInput
  }

  export type MessageThreadScalarWhereWithAggregatesInput = {
    AND?: MessageThreadScalarWhereWithAggregatesInput | MessageThreadScalarWhereWithAggregatesInput[]
    OR?: MessageThreadScalarWhereWithAggregatesInput[]
    NOT?: MessageThreadScalarWhereWithAggregatesInput | MessageThreadScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MessageThread"> | string
    entityTaxYearId?: StringWithAggregatesFilter<"MessageThread"> | string
    archived?: BoolWithAggregatesFilter<"MessageThread"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MessageThread"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageThread"> | Date | string
  }

  export type ThreadParticipantWhereInput = {
    AND?: ThreadParticipantWhereInput | ThreadParticipantWhereInput[]
    OR?: ThreadParticipantWhereInput[]
    NOT?: ThreadParticipantWhereInput | ThreadParticipantWhereInput[]
    id?: StringFilter<"ThreadParticipant"> | string
    threadId?: StringFilter<"ThreadParticipant"> | string
    userId?: StringFilter<"ThreadParticipant"> | string
    userType?: EnumUserTypeFilter<"ThreadParticipant"> | $Enums.UserType
    createdAt?: DateTimeFilter<"ThreadParticipant"> | Date | string
    thread?: XOR<MessageThreadScalarRelationFilter, MessageThreadWhereInput>
    staff?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }

  export type ThreadParticipantOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    thread?: MessageThreadOrderByWithRelationInput
    staff?: StaffProfileOrderByWithRelationInput
  }

  export type ThreadParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    threadId_userId?: ThreadParticipantThreadIdUserIdCompoundUniqueInput
    AND?: ThreadParticipantWhereInput | ThreadParticipantWhereInput[]
    OR?: ThreadParticipantWhereInput[]
    NOT?: ThreadParticipantWhereInput | ThreadParticipantWhereInput[]
    threadId?: StringFilter<"ThreadParticipant"> | string
    userId?: StringFilter<"ThreadParticipant"> | string
    userType?: EnumUserTypeFilter<"ThreadParticipant"> | $Enums.UserType
    createdAt?: DateTimeFilter<"ThreadParticipant"> | Date | string
    thread?: XOR<MessageThreadScalarRelationFilter, MessageThreadWhereInput>
    staff?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }, "id" | "threadId_userId">

  export type ThreadParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
    _count?: ThreadParticipantCountOrderByAggregateInput
    _max?: ThreadParticipantMaxOrderByAggregateInput
    _min?: ThreadParticipantMinOrderByAggregateInput
  }

  export type ThreadParticipantScalarWhereWithAggregatesInput = {
    AND?: ThreadParticipantScalarWhereWithAggregatesInput | ThreadParticipantScalarWhereWithAggregatesInput[]
    OR?: ThreadParticipantScalarWhereWithAggregatesInput[]
    NOT?: ThreadParticipantScalarWhereWithAggregatesInput | ThreadParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ThreadParticipant"> | string
    threadId?: StringWithAggregatesFilter<"ThreadParticipant"> | string
    userId?: StringWithAggregatesFilter<"ThreadParticipant"> | string
    userType?: EnumUserTypeWithAggregatesFilter<"ThreadParticipant"> | $Enums.UserType
    createdAt?: DateTimeWithAggregatesFilter<"ThreadParticipant"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderType?: EnumUserTypeFilter<"Message"> | $Enums.UserType
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    thread?: XOR<MessageThreadScalarRelationFilter, MessageThreadWhereInput>
    sender?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    thread?: MessageThreadOrderByWithRelationInput
    sender?: StaffProfileOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderType?: EnumUserTypeFilter<"Message"> | $Enums.UserType
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    thread?: XOR<MessageThreadScalarRelationFilter, MessageThreadWhereInput>
    sender?: XOR<StaffProfileNullableScalarRelationFilter, StaffProfileWhereInput> | null
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    threadId?: StringWithAggregatesFilter<"Message"> | string
    senderId?: StringWithAggregatesFilter<"Message"> | string
    senderType?: EnumUserTypeWithAggregatesFilter<"Message"> | $Enums.UserType
    content?: StringWithAggregatesFilter<"Message"> | string
    read?: BoolWithAggregatesFilter<"Message"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
  }

  export type ReminderStateWhereInput = {
    AND?: ReminderStateWhereInput | ReminderStateWhereInput[]
    OR?: ReminderStateWhereInput[]
    NOT?: ReminderStateWhereInput | ReminderStateWhereInput[]
    id?: StringFilter<"ReminderState"> | string
    entityTaxYearId?: StringFilter<"ReminderState"> | string
    reminderType?: EnumReminderTypeFilter<"ReminderState"> | $Enums.ReminderType
    nextReminderAt?: DateTimeNullableFilter<"ReminderState"> | Date | string | null
    lastReminderAt?: DateTimeNullableFilter<"ReminderState"> | Date | string | null
    reminderCount?: IntFilter<"ReminderState"> | number
    paused?: BoolFilter<"ReminderState"> | boolean
    pausedReason?: StringNullableFilter<"ReminderState"> | string | null
    createdAt?: DateTimeFilter<"ReminderState"> | Date | string
    updatedAt?: DateTimeFilter<"ReminderState"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
  }

  export type ReminderStateOrderByWithRelationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    reminderType?: SortOrder
    nextReminderAt?: SortOrderInput | SortOrder
    lastReminderAt?: SortOrderInput | SortOrder
    reminderCount?: SortOrder
    paused?: SortOrder
    pausedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    entityTaxYear?: EntityTaxYearOrderByWithRelationInput
  }

  export type ReminderStateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    entityTaxYearId?: string
    AND?: ReminderStateWhereInput | ReminderStateWhereInput[]
    OR?: ReminderStateWhereInput[]
    NOT?: ReminderStateWhereInput | ReminderStateWhereInput[]
    reminderType?: EnumReminderTypeFilter<"ReminderState"> | $Enums.ReminderType
    nextReminderAt?: DateTimeNullableFilter<"ReminderState"> | Date | string | null
    lastReminderAt?: DateTimeNullableFilter<"ReminderState"> | Date | string | null
    reminderCount?: IntFilter<"ReminderState"> | number
    paused?: BoolFilter<"ReminderState"> | boolean
    pausedReason?: StringNullableFilter<"ReminderState"> | string | null
    createdAt?: DateTimeFilter<"ReminderState"> | Date | string
    updatedAt?: DateTimeFilter<"ReminderState"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
  }, "id" | "entityTaxYearId">

  export type ReminderStateOrderByWithAggregationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    reminderType?: SortOrder
    nextReminderAt?: SortOrderInput | SortOrder
    lastReminderAt?: SortOrderInput | SortOrder
    reminderCount?: SortOrder
    paused?: SortOrder
    pausedReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReminderStateCountOrderByAggregateInput
    _avg?: ReminderStateAvgOrderByAggregateInput
    _max?: ReminderStateMaxOrderByAggregateInput
    _min?: ReminderStateMinOrderByAggregateInput
    _sum?: ReminderStateSumOrderByAggregateInput
  }

  export type ReminderStateScalarWhereWithAggregatesInput = {
    AND?: ReminderStateScalarWhereWithAggregatesInput | ReminderStateScalarWhereWithAggregatesInput[]
    OR?: ReminderStateScalarWhereWithAggregatesInput[]
    NOT?: ReminderStateScalarWhereWithAggregatesInput | ReminderStateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReminderState"> | string
    entityTaxYearId?: StringWithAggregatesFilter<"ReminderState"> | string
    reminderType?: EnumReminderTypeWithAggregatesFilter<"ReminderState"> | $Enums.ReminderType
    nextReminderAt?: DateTimeNullableWithAggregatesFilter<"ReminderState"> | Date | string | null
    lastReminderAt?: DateTimeNullableWithAggregatesFilter<"ReminderState"> | Date | string | null
    reminderCount?: IntWithAggregatesFilter<"ReminderState"> | number
    paused?: BoolWithAggregatesFilter<"ReminderState"> | boolean
    pausedReason?: StringNullableWithAggregatesFilter<"ReminderState"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReminderState"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReminderState"> | Date | string
  }

  export type StatusAuditLogWhereInput = {
    AND?: StatusAuditLogWhereInput | StatusAuditLogWhereInput[]
    OR?: StatusAuditLogWhereInput[]
    NOT?: StatusAuditLogWhereInput | StatusAuditLogWhereInput[]
    id?: StringFilter<"StatusAuditLog"> | string
    entityTaxYearId?: StringFilter<"StatusAuditLog"> | string
    oldStatus?: StringNullableFilter<"StatusAuditLog"> | string | null
    newStatus?: StringFilter<"StatusAuditLog"> | string
    changedBy?: StringFilter<"StatusAuditLog"> | string
    reason?: StringNullableFilter<"StatusAuditLog"> | string | null
    createdAt?: DateTimeFilter<"StatusAuditLog"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }

  export type StatusAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    entityTaxYear?: EntityTaxYearOrderByWithRelationInput
    staff?: StaffProfileOrderByWithRelationInput
  }

  export type StatusAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: StatusAuditLogWhereInput | StatusAuditLogWhereInput[]
    OR?: StatusAuditLogWhereInput[]
    NOT?: StatusAuditLogWhereInput | StatusAuditLogWhereInput[]
    entityTaxYearId?: StringFilter<"StatusAuditLog"> | string
    oldStatus?: StringNullableFilter<"StatusAuditLog"> | string | null
    newStatus?: StringFilter<"StatusAuditLog"> | string
    changedBy?: StringFilter<"StatusAuditLog"> | string
    reason?: StringNullableFilter<"StatusAuditLog"> | string | null
    createdAt?: DateTimeFilter<"StatusAuditLog"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }, "id">

  export type StatusAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    oldStatus?: SortOrderInput | SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: StatusAuditLogCountOrderByAggregateInput
    _max?: StatusAuditLogMaxOrderByAggregateInput
    _min?: StatusAuditLogMinOrderByAggregateInput
  }

  export type StatusAuditLogScalarWhereWithAggregatesInput = {
    AND?: StatusAuditLogScalarWhereWithAggregatesInput | StatusAuditLogScalarWhereWithAggregatesInput[]
    OR?: StatusAuditLogScalarWhereWithAggregatesInput[]
    NOT?: StatusAuditLogScalarWhereWithAggregatesInput | StatusAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StatusAuditLog"> | string
    entityTaxYearId?: StringWithAggregatesFilter<"StatusAuditLog"> | string
    oldStatus?: StringNullableWithAggregatesFilter<"StatusAuditLog"> | string | null
    newStatus?: StringWithAggregatesFilter<"StatusAuditLog"> | string
    changedBy?: StringWithAggregatesFilter<"StatusAuditLog"> | string
    reason?: StringNullableWithAggregatesFilter<"StatusAuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StatusAuditLog"> | Date | string
  }

  export type PermissionAuditLogWhereInput = {
    AND?: PermissionAuditLogWhereInput | PermissionAuditLogWhereInput[]
    OR?: PermissionAuditLogWhereInput[]
    NOT?: PermissionAuditLogWhereInput | PermissionAuditLogWhereInput[]
    id?: StringFilter<"PermissionAuditLog"> | string
    changeType?: StringFilter<"PermissionAuditLog"> | string
    clientId?: StringNullableFilter<"PermissionAuditLog"> | string | null
    staffUserId?: StringNullableFilter<"PermissionAuditLog"> | string | null
    oldValue?: StringNullableFilter<"PermissionAuditLog"> | string | null
    newValue?: StringNullableFilter<"PermissionAuditLog"> | string | null
    changedBy?: StringFilter<"PermissionAuditLog"> | string
    reason?: StringNullableFilter<"PermissionAuditLog"> | string | null
    createdAt?: DateTimeFilter<"PermissionAuditLog"> | Date | string
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }

  export type PermissionAuditLogOrderByWithRelationInput = {
    id?: SortOrder
    changeType?: SortOrder
    clientId?: SortOrderInput | SortOrder
    staffUserId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    staff?: StaffProfileOrderByWithRelationInput
  }

  export type PermissionAuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PermissionAuditLogWhereInput | PermissionAuditLogWhereInput[]
    OR?: PermissionAuditLogWhereInput[]
    NOT?: PermissionAuditLogWhereInput | PermissionAuditLogWhereInput[]
    changeType?: StringFilter<"PermissionAuditLog"> | string
    clientId?: StringNullableFilter<"PermissionAuditLog"> | string | null
    staffUserId?: StringNullableFilter<"PermissionAuditLog"> | string | null
    oldValue?: StringNullableFilter<"PermissionAuditLog"> | string | null
    newValue?: StringNullableFilter<"PermissionAuditLog"> | string | null
    changedBy?: StringFilter<"PermissionAuditLog"> | string
    reason?: StringNullableFilter<"PermissionAuditLog"> | string | null
    createdAt?: DateTimeFilter<"PermissionAuditLog"> | Date | string
    staff?: XOR<StaffProfileScalarRelationFilter, StaffProfileWhereInput>
  }, "id">

  export type PermissionAuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    changeType?: SortOrder
    clientId?: SortOrderInput | SortOrder
    staffUserId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    changedBy?: SortOrder
    reason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PermissionAuditLogCountOrderByAggregateInput
    _max?: PermissionAuditLogMaxOrderByAggregateInput
    _min?: PermissionAuditLogMinOrderByAggregateInput
  }

  export type PermissionAuditLogScalarWhereWithAggregatesInput = {
    AND?: PermissionAuditLogScalarWhereWithAggregatesInput | PermissionAuditLogScalarWhereWithAggregatesInput[]
    OR?: PermissionAuditLogScalarWhereWithAggregatesInput[]
    NOT?: PermissionAuditLogScalarWhereWithAggregatesInput | PermissionAuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PermissionAuditLog"> | string
    changeType?: StringWithAggregatesFilter<"PermissionAuditLog"> | string
    clientId?: StringNullableWithAggregatesFilter<"PermissionAuditLog"> | string | null
    staffUserId?: StringNullableWithAggregatesFilter<"PermissionAuditLog"> | string | null
    oldValue?: StringNullableWithAggregatesFilter<"PermissionAuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"PermissionAuditLog"> | string | null
    changedBy?: StringWithAggregatesFilter<"PermissionAuditLog"> | string
    reason?: StringNullableWithAggregatesFilter<"PermissionAuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PermissionAuditLog"> | Date | string
  }

  export type DocumentEventWhereInput = {
    AND?: DocumentEventWhereInput | DocumentEventWhereInput[]
    OR?: DocumentEventWhereInput[]
    NOT?: DocumentEventWhereInput | DocumentEventWhereInput[]
    id?: StringFilter<"DocumentEvent"> | string
    entityTaxYearId?: StringFilter<"DocumentEvent"> | string
    eventType?: EnumDocumentEventTypeFilter<"DocumentEvent"> | $Enums.DocumentEventType
    documentId?: StringNullableFilter<"DocumentEvent"> | string | null
    description?: StringNullableFilter<"DocumentEvent"> | string | null
    metadata?: StringNullableFilter<"DocumentEvent"> | string | null
    createdAt?: DateTimeFilter<"DocumentEvent"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
  }

  export type DocumentEventOrderByWithRelationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    eventType?: SortOrder
    documentId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    entityTaxYear?: EntityTaxYearOrderByWithRelationInput
  }

  export type DocumentEventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentEventWhereInput | DocumentEventWhereInput[]
    OR?: DocumentEventWhereInput[]
    NOT?: DocumentEventWhereInput | DocumentEventWhereInput[]
    entityTaxYearId?: StringFilter<"DocumentEvent"> | string
    eventType?: EnumDocumentEventTypeFilter<"DocumentEvent"> | $Enums.DocumentEventType
    documentId?: StringNullableFilter<"DocumentEvent"> | string | null
    description?: StringNullableFilter<"DocumentEvent"> | string | null
    metadata?: StringNullableFilter<"DocumentEvent"> | string | null
    createdAt?: DateTimeFilter<"DocumentEvent"> | Date | string
    entityTaxYear?: XOR<EntityTaxYearScalarRelationFilter, EntityTaxYearWhereInput>
  }, "id">

  export type DocumentEventOrderByWithAggregationInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    eventType?: SortOrder
    documentId?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: DocumentEventCountOrderByAggregateInput
    _max?: DocumentEventMaxOrderByAggregateInput
    _min?: DocumentEventMinOrderByAggregateInput
  }

  export type DocumentEventScalarWhereWithAggregatesInput = {
    AND?: DocumentEventScalarWhereWithAggregatesInput | DocumentEventScalarWhereWithAggregatesInput[]
    OR?: DocumentEventScalarWhereWithAggregatesInput[]
    NOT?: DocumentEventScalarWhereWithAggregatesInput | DocumentEventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DocumentEvent"> | string
    entityTaxYearId?: StringWithAggregatesFilter<"DocumentEvent"> | string
    eventType?: EnumDocumentEventTypeWithAggregatesFilter<"DocumentEvent"> | $Enums.DocumentEventType
    documentId?: StringNullableWithAggregatesFilter<"DocumentEvent"> | string | null
    description?: StringNullableWithAggregatesFilter<"DocumentEvent"> | string | null
    metadata?: StringNullableWithAggregatesFilter<"DocumentEvent"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"DocumentEvent"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
    staffProfile?: StaffProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
    staffProfile?: StaffProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    staffProfile?: StaffProfileCreateNestedOneWithoutProfileInput
    accountUsers?: AccountUserCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutProfileInput
    accountUsers?: AccountUserUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    staffProfile?: StaffProfileUpdateOneWithoutProfileNestedInput
    accountUsers?: AccountUserUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutProfileNestedInput
    accountUsers?: AccountUserUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffProfileCreateInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileCreateManyInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StaffProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StaffProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountUsers?: AccountUserCreateNestedManyWithoutAccountInput
    entities?: ClientEntityCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountUsers?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
    entities?: ClientEntityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountUsers?: AccountUserUpdateManyWithoutAccountNestedInput
    entities?: ClientEntityUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountUsers?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
    entities?: ClientEntityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserCreateInput = {
    id?: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAccountUsersInput
    profile: ProfileCreateNestedOneWithoutAccountUsersInput
  }

  export type AccountUserUncheckedCreateInput = {
    id?: string
    accountId: string
    userId: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAccountUsersNestedInput
    profile?: ProfileUpdateOneRequiredWithoutAccountUsersNestedInput
  }

  export type AccountUserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserCreateManyInput = {
    id?: string
    accountId: string
    userId: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEntityCreateInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutEntitiesInput
    entityTaxYears?: EntityTaxYearCreateNestedManyWithoutClientEntityInput
    folders?: FolderCreateNestedManyWithoutClientEntityInput
    documents?: DocumentCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUncheckedCreateInput = {
    id?: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYears?: EntityTaxYearUncheckedCreateNestedManyWithoutClientEntityInput
    folders?: FolderUncheckedCreateNestedManyWithoutClientEntityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntitiesNestedInput
    entityTaxYears?: EntityTaxYearUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYears?: EntityTaxYearUncheckedUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUncheckedUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityCreateManyInput = {
    id?: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientEntityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEntityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityTaxYearCreateInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearCreateManyInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityTaxYearUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityTaxYearUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAclCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutClientAclInput
    staff: StaffProfileCreateNestedOneWithoutClientAclInput
  }

  export type ClientAclUncheckedCreateInput = {
    id?: string
    clientId: string
    staffUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAclUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutClientAclNestedInput
    staff?: StaffProfileUpdateOneRequiredWithoutClientAclNestedInput
  }

  export type ClientAclUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAclCreateManyInput = {
    id?: string
    clientId: string
    staffUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAclUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAclUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffPermissionCreateInput = {
    id?: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutClientStaffPermissionsInput
    staff: StaffProfileCreateNestedOneWithoutClientStaffPermissionsInput
  }

  export type ClientStaffPermissionUncheckedCreateInput = {
    id?: string
    clientId: string
    staffUserId: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutClientStaffPermissionsNestedInput
    staff?: StaffProfileUpdateOneRequiredWithoutClientStaffPermissionsNestedInput
  }

  export type ClientStaffPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffPermissionCreateManyInput = {
    id?: string
    clientId: string
    staffUserId: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffAssignmentCreateInput = {
    id?: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutClientStaffAssignmentsInput
    staff: StaffProfileCreateNestedOneWithoutClientStaffAssignmentsInput
  }

  export type ClientStaffAssignmentUncheckedCreateInput = {
    id?: string
    clientId: string
    staffUserId: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutClientStaffAssignmentsNestedInput
    staff?: StaffProfileUpdateOneRequiredWithoutClientStaffAssignmentsNestedInput
  }

  export type ClientStaffAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffAssignmentCreateManyInput = {
    id?: string
    clientId: string
    staffUserId: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderCreateInput = {
    id?: string
    name: string
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutFoldersInput
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
    folderAcl?: FolderAclCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateInput = {
    id?: string
    clientId: string
    name: string
    parentId?: string | null
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutFoldersNestedInput
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
    folderAcl?: FolderAclUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderCreateManyInput = {
    id?: string
    clientId: string
    name: string
    parentId?: string | null
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderAclCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    folder: FolderCreateNestedOneWithoutFolderAclInput
    staff: StaffProfileCreateNestedOneWithoutFolderAclInput
  }

  export type FolderAclUncheckedCreateInput = {
    id?: string
    folderId: string
    staffUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderAclUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneRequiredWithoutFolderAclNestedInput
    staff?: StaffProfileUpdateOneRequiredWithoutFolderAclNestedInput
  }

  export type FolderAclUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderAclCreateManyInput = {
    id?: string
    folderId: string
    staffUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderAclUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderAclUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentCreateInput = {
    id?: string
    storagePath: string
    displayName: string
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutDocumentsInput
    folder?: FolderCreateNestedOneWithoutDocumentsInput
    uploader?: StaffProfileCreateNestedOneWithoutUploadedDocumentsInput
    checklistItems?: ChecklistItemFileCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateInput = {
    id?: string
    clientId: string
    folderId?: string | null
    storagePath: string
    displayName: string
    uploadedBy?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemFileUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutDocumentsNestedInput
    folder?: FolderUpdateOneWithoutDocumentsNestedInput
    uploader?: StaffProfileUpdateOneWithoutUploadedDocumentsNestedInput
    checklistItems?: ChecklistItemFileUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemFileUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentCreateManyInput = {
    id?: string
    clientId: string
    folderId?: string | null
    storagePath: string
    displayName: string
    uploadedBy?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemCreateInput = {
    id?: string
    itemName: string
    itemType?: string | null
    required?: boolean
    status?: $Enums.ChecklistItemStatus
    receivedAt?: Date | string | null
    markedNotApplicableAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutChecklistItemsInput
    files?: ChecklistItemFileCreateNestedManyWithoutChecklistItemInput
  }

  export type ChecklistItemUncheckedCreateInput = {
    id?: string
    entityTaxYearId: string
    itemName: string
    itemType?: string | null
    required?: boolean
    status?: $Enums.ChecklistItemStatus
    receivedAt?: Date | string | null
    markedNotApplicableAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: ChecklistItemFileUncheckedCreateNestedManyWithoutChecklistItemInput
  }

  export type ChecklistItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutChecklistItemsNestedInput
    files?: ChecklistItemFileUpdateManyWithoutChecklistItemNestedInput
  }

  export type ChecklistItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ChecklistItemFileUncheckedUpdateManyWithoutChecklistItemNestedInput
  }

  export type ChecklistItemCreateManyInput = {
    id?: string
    entityTaxYearId: string
    itemName: string
    itemType?: string | null
    required?: boolean
    status?: $Enums.ChecklistItemStatus
    receivedAt?: Date | string | null
    markedNotApplicableAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemFileCreateInput = {
    id?: string
    createdAt?: Date | string
    checklistItem: ChecklistItemCreateNestedOneWithoutFilesInput
    document: DocumentCreateNestedOneWithoutChecklistItemsInput
  }

  export type ChecklistItemFileUncheckedCreateInput = {
    id?: string
    checklistItemId: string
    documentId: string
    createdAt?: Date | string
  }

  export type ChecklistItemFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItem?: ChecklistItemUpdateOneRequiredWithoutFilesNestedInput
    document?: DocumentUpdateOneRequiredWithoutChecklistItemsNestedInput
  }

  export type ChecklistItemFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklistItemId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemFileCreateManyInput = {
    id?: string
    checklistItemId: string
    documentId: string
    createdAt?: Date | string
  }

  export type ChecklistItemFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklistItemId?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireSectionCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionnaireQuestionCreateNestedManyWithoutSectionInput
  }

  export type QuestionnaireSectionUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    questions?: QuestionnaireQuestionUncheckedCreateNestedManyWithoutSectionInput
  }

  export type QuestionnaireSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionnaireQuestionUpdateManyWithoutSectionNestedInput
  }

  export type QuestionnaireSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questions?: QuestionnaireQuestionUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type QuestionnaireSectionCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireQuestionCreateInput = {
    id?: string
    questionText: string
    questionType: $Enums.QuestionType
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    section: QuestionnaireSectionCreateNestedOneWithoutQuestionsInput
    answers?: QuestionnaireAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionnaireQuestionUncheckedCreateInput = {
    id?: string
    sectionId: string
    questionText: string
    questionType: $Enums.QuestionType
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionnaireQuestionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: QuestionnaireSectionUpdateOneRequiredWithoutQuestionsNestedInput
    answers?: QuestionnaireAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionnaireQuestionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: QuestionnaireAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionnaireQuestionCreateManyInput = {
    id?: string
    sectionId: string
    questionText: string
    questionType: $Enums.QuestionType
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireQuestionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireQuestionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireAnswerCreateInput = {
    id?: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutQuestionnaireAnswersInput
    question: QuestionnaireQuestionCreateNestedOneWithoutAnswersInput
  }

  export type QuestionnaireAnswerUncheckedCreateInput = {
    id?: string
    entityTaxYearId: string
    questionId: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireAnswerUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutQuestionnaireAnswersNestedInput
    question?: QuestionnaireQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuestionnaireAnswerUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireAnswerCreateManyInput = {
    id?: string
    entityTaxYearId: string
    questionId: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireAnswerUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireAnswerUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementSignatureCreateInput = {
    id?: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutEngagementSignaturesInput
  }

  export type EngagementSignatureUncheckedCreateInput = {
    id?: string
    entityTaxYearId: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EngagementSignatureUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutEngagementSignaturesNestedInput
  }

  export type EngagementSignatureUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementSignatureCreateManyInput = {
    id?: string
    entityTaxYearId: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EngagementSignatureUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementSignatureUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EfileAuthorizationCreateInput = {
    id?: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutEfileAuthorizationsInput
  }

  export type EfileAuthorizationUncheckedCreateInput = {
    id?: string
    entityTaxYearId: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EfileAuthorizationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutEfileAuthorizationsNestedInput
  }

  export type EfileAuthorizationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EfileAuthorizationCreateManyInput = {
    id?: string
    entityTaxYearId: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EfileAuthorizationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EfileAuthorizationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadCreateInput = {
    id?: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutMessageThreadInput
    participants?: ThreadParticipantCreateNestedManyWithoutThreadInput
    messages?: MessageCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateInput = {
    id?: string
    entityTaxYearId: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ThreadParticipantUncheckedCreateNestedManyWithoutThreadInput
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutMessageThreadNestedInput
    participants?: ThreadParticipantUpdateManyWithoutThreadNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ThreadParticipantUncheckedUpdateManyWithoutThreadNestedInput
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadCreateManyInput = {
    id?: string
    entityTaxYearId: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageThreadUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageThreadUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreadParticipantCreateInput = {
    id?: string
    userType: $Enums.UserType
    createdAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutParticipantsInput
    staff?: StaffProfileCreateNestedOneWithoutAssignedThreadsInput
  }

  export type ThreadParticipantUncheckedCreateInput = {
    id?: string
    threadId: string
    userId: string
    userType: $Enums.UserType
    createdAt?: Date | string
  }

  export type ThreadParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutParticipantsNestedInput
    staff?: StaffProfileUpdateOneWithoutAssignedThreadsNestedInput
  }

  export type ThreadParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreadParticipantCreateManyInput = {
    id?: string
    threadId: string
    userId: string
    userType: $Enums.UserType
    createdAt?: Date | string
  }

  export type ThreadParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreadParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutMessagesInput
    sender?: StaffProfileCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    threadId: string
    senderId: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutMessagesNestedInput
    sender?: StaffProfileUpdateOneWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateManyInput = {
    id?: string
    threadId: string
    senderId: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderStateCreateInput = {
    id?: string
    reminderType: $Enums.ReminderType
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    reminderCount?: number
    paused?: boolean
    pausedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutReminderStateInput
  }

  export type ReminderStateUncheckedCreateInput = {
    id?: string
    entityTaxYearId: string
    reminderType: $Enums.ReminderType
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    reminderCount?: number
    paused?: boolean
    pausedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderStateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderCount?: IntFieldUpdateOperationsInput | number
    paused?: BoolFieldUpdateOperationsInput | boolean
    pausedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutReminderStateNestedInput
  }

  export type ReminderStateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderCount?: IntFieldUpdateOperationsInput | number
    paused?: BoolFieldUpdateOperationsInput | boolean
    pausedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderStateCreateManyInput = {
    id?: string
    entityTaxYearId: string
    reminderType: $Enums.ReminderType
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    reminderCount?: number
    paused?: boolean
    pausedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderStateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderCount?: IntFieldUpdateOperationsInput | number
    paused?: BoolFieldUpdateOperationsInput | boolean
    pausedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderStateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderCount?: IntFieldUpdateOperationsInput | number
    paused?: BoolFieldUpdateOperationsInput | boolean
    pausedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAuditLogCreateInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    reason?: string | null
    createdAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutStatusAuditLogsInput
    staff: StaffProfileCreateNestedOneWithoutStatusAuditLogsInput
  }

  export type StatusAuditLogUncheckedCreateInput = {
    id?: string
    entityTaxYearId: string
    oldStatus?: string | null
    newStatus: string
    changedBy: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type StatusAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutStatusAuditLogsNestedInput
    staff?: StaffProfileUpdateOneRequiredWithoutStatusAuditLogsNestedInput
  }

  export type StatusAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAuditLogCreateManyInput = {
    id?: string
    entityTaxYearId: string
    oldStatus?: string | null
    newStatus: string
    changedBy: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type StatusAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditLogCreateInput = {
    id?: string
    changeType: string
    clientId?: string | null
    staffUserId?: string | null
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
    staff: StaffProfileCreateNestedOneWithoutPermissionAuditLogsInput
  }

  export type PermissionAuditLogUncheckedCreateInput = {
    id?: string
    changeType: string
    clientId?: string | null
    staffUserId?: string | null
    oldValue?: string | null
    newValue?: string | null
    changedBy: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    staffUserId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffProfileUpdateOneRequiredWithoutPermissionAuditLogsNestedInput
  }

  export type PermissionAuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    staffUserId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditLogCreateManyInput = {
    id?: string
    changeType: string
    clientId?: string | null
    staffUserId?: string | null
    oldValue?: string | null
    newValue?: string | null
    changedBy: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    staffUserId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    staffUserId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentEventCreateInput = {
    id?: string
    eventType: $Enums.DocumentEventType
    documentId?: string | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutDocumentEventsInput
  }

  export type DocumentEventUncheckedCreateInput = {
    id?: string
    entityTaxYearId: string
    eventType: $Enums.DocumentEventType
    documentId?: string | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type DocumentEventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumDocumentEventTypeFieldUpdateOperationsInput | $Enums.DocumentEventType
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutDocumentEventsNestedInput
  }

  export type DocumentEventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumDocumentEventTypeFieldUpdateOperationsInput | $Enums.DocumentEventType
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentEventCreateManyInput = {
    id?: string
    entityTaxYearId: string
    eventType: $Enums.DocumentEventType
    documentId?: string | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type DocumentEventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumDocumentEventTypeFieldUpdateOperationsInput | $Enums.DocumentEventType
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentEventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    eventType?: EnumDocumentEventTypeFieldUpdateOperationsInput | $Enums.DocumentEventType
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type StaffProfileNullableScalarRelationFilter = {
    is?: StaffProfileWhereInput | null
    isNot?: StaffProfileWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AccountUserListRelationFilter = {
    every?: AccountUserWhereInput
    some?: AccountUserWhereInput
    none?: AccountUserWhereInput
  }

  export type AccountUserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    fullName?: SortOrder
    email?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumStaffRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffRole | EnumStaffRoleFieldRefInput<$PrismaModel>
    in?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffRoleFilter<$PrismaModel> | $Enums.StaffRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type ClientAclListRelationFilter = {
    every?: ClientAclWhereInput
    some?: ClientAclWhereInput
    none?: ClientAclWhereInput
  }

  export type ClientStaffPermissionListRelationFilter = {
    every?: ClientStaffPermissionWhereInput
    some?: ClientStaffPermissionWhereInput
    none?: ClientStaffPermissionWhereInput
  }

  export type ClientStaffAssignmentListRelationFilter = {
    every?: ClientStaffAssignmentWhereInput
    some?: ClientStaffAssignmentWhereInput
    none?: ClientStaffAssignmentWhereInput
  }

  export type FolderAclListRelationFilter = {
    every?: FolderAclWhereInput
    some?: FolderAclWhereInput
    none?: FolderAclWhereInput
  }

  export type DocumentListRelationFilter = {
    every?: DocumentWhereInput
    some?: DocumentWhereInput
    none?: DocumentWhereInput
  }

  export type ThreadParticipantListRelationFilter = {
    every?: ThreadParticipantWhereInput
    some?: ThreadParticipantWhereInput
    none?: ThreadParticipantWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type StatusAuditLogListRelationFilter = {
    every?: StatusAuditLogWhereInput
    some?: StatusAuditLogWhereInput
    none?: StatusAuditLogWhereInput
  }

  export type PermissionAuditLogListRelationFilter = {
    every?: PermissionAuditLogWhereInput
    some?: PermissionAuditLogWhereInput
    none?: PermissionAuditLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ClientAclOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientStaffPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientStaffAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderAclOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ThreadParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StatusAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PermissionAuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StaffProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffRole?: SortOrder
    staffTeamReporting?: SortOrder
    jobTitle?: SortOrder
    phone?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffRole?: SortOrder
    staffTeamReporting?: SortOrder
    jobTitle?: SortOrder
    phone?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StaffProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    staffRole?: SortOrder
    staffTeamReporting?: SortOrder
    jobTitle?: SortOrder
    phone?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumStaffRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffRole | EnumStaffRoleFieldRefInput<$PrismaModel>
    in?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffRoleWithAggregatesFilter<$PrismaModel> | $Enums.StaffRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffRoleFilter<$PrismaModel>
    _max?: NestedEnumStaffRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type ClientEntityListRelationFilter = {
    every?: ClientEntityWhereInput
    some?: ClientEntityWhereInput
    none?: ClientEntityWhereInput
  }

  export type ClientEntityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClientRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientRole | EnumClientRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClientRole[] | ListEnumClientRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientRole[] | ListEnumClientRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClientRoleFilter<$PrismaModel> | $Enums.ClientRole
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type AccountUserAccountIdUserIdCompoundUniqueInput = {
    accountId: string
    userId: string
  }

  export type AccountUserCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    clientRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountUserMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    clientRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AccountUserMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userId?: SortOrder
    clientRole?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumClientRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientRole | EnumClientRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClientRole[] | ListEnumClientRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientRole[] | ListEnumClientRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClientRoleWithAggregatesFilter<$PrismaModel> | $Enums.ClientRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientRoleFilter<$PrismaModel>
    _max?: NestedEnumClientRoleFilter<$PrismaModel>
  }

  export type EnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type EntityTaxYearListRelationFilter = {
    every?: EntityTaxYearWhereInput
    some?: EntityTaxYearWhereInput
    none?: EntityTaxYearWhereInput
  }

  export type FolderListRelationFilter = {
    every?: FolderWhereInput
    some?: FolderWhereInput
    none?: FolderWhereInput
  }

  export type EntityTaxYearOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FolderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClientEntityCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    entityName?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    isRestricted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientEntityMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    entityName?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    isRestricted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientEntityMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    entityName?: SortOrder
    entityType?: SortOrder
    status?: SortOrder
    isRestricted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumEngagementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementStatus | EnumEngagementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementStatus[] | ListEnumEngagementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementStatus[] | ListEnumEngagementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementStatusFilter<$PrismaModel> | $Enums.EngagementStatus
  }

  export type EnumConfirmationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfirmationStatus | EnumConfirmationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfirmationStatusFilter<$PrismaModel> | $Enums.ConfirmationStatus
  }

  export type EnumQuestionnaireStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireStatus | EnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireStatusFilter<$PrismaModel> | $Enums.QuestionnaireStatus
  }

  export type EnumIdStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IdStatus | EnumIdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdStatus[] | ListEnumIdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdStatus[] | ListEnumIdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdStatusFilter<$PrismaModel> | $Enums.IdStatus
  }

  export type EnumInternalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InternalStatus | EnumInternalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternalStatus[] | ListEnumInternalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InternalStatus[] | ListEnumInternalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInternalStatusFilter<$PrismaModel> | $Enums.InternalStatus
  }

  export type ClientEntityScalarRelationFilter = {
    is?: ClientEntityWhereInput
    isNot?: ClientEntityWhereInput
  }

  export type ChecklistItemListRelationFilter = {
    every?: ChecklistItemWhereInput
    some?: ChecklistItemWhereInput
    none?: ChecklistItemWhereInput
  }

  export type QuestionnaireAnswerListRelationFilter = {
    every?: QuestionnaireAnswerWhereInput
    some?: QuestionnaireAnswerWhereInput
    none?: QuestionnaireAnswerWhereInput
  }

  export type MessageThreadNullableScalarRelationFilter = {
    is?: MessageThreadWhereInput | null
    isNot?: MessageThreadWhereInput | null
  }

  export type ReminderStateNullableScalarRelationFilter = {
    is?: ReminderStateWhereInput | null
    isNot?: ReminderStateWhereInput | null
  }

  export type DocumentEventListRelationFilter = {
    every?: DocumentEventWhereInput
    some?: DocumentEventWhereInput
    none?: DocumentEventWhereInput
  }

  export type EngagementSignatureListRelationFilter = {
    every?: EngagementSignatureWhereInput
    some?: EngagementSignatureWhereInput
    none?: EngagementSignatureWhereInput
  }

  export type EfileAuthorizationListRelationFilter = {
    every?: EfileAuthorizationWhereInput
    some?: EfileAuthorizationWhereInput
    none?: EfileAuthorizationWhereInput
  }

  export type ChecklistItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionnaireAnswerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentEventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EngagementSignatureOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EfileAuthorizationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EntityTaxYearClientEntityIdTaxYearCompoundUniqueInput = {
    clientEntityId: string
    taxYear: number
  }

  export type EntityTaxYearCountOrderByAggregateInput = {
    id?: SortOrder
    clientEntityId?: SortOrder
    taxYear?: SortOrder
    taxReturnExpected?: SortOrder
    inviteStatus?: SortOrder
    inviteSentAt?: SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrder
    engagementStatus?: SortOrder
    engagementSignedAt?: SortOrder
    engagementSigner1Id?: SortOrder
    engagementSigner2Id?: SortOrder
    docsRequiredCount?: SortOrder
    docsReceivedCount?: SortOrder
    checklistCompleteAt?: SortOrder
    docConfirmationStatus?: SortOrder
    docConfirmationSignedAt?: SortOrder
    docConfirmationSignerId?: SortOrder
    questionnaireStatus?: SortOrder
    questionnaireCompletedAt?: SortOrder
    idStatus?: SortOrder
    idValidUntil?: SortOrder
    readyForPrep?: SortOrder
    extensionRequested?: SortOrder
    extensionFiled?: SortOrder
    extendedDueDate?: SortOrder
    internalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityTaxYearAvgOrderByAggregateInput = {
    taxYear?: SortOrder
    attemptCount?: SortOrder
    docsRequiredCount?: SortOrder
    docsReceivedCount?: SortOrder
  }

  export type EntityTaxYearMaxOrderByAggregateInput = {
    id?: SortOrder
    clientEntityId?: SortOrder
    taxYear?: SortOrder
    taxReturnExpected?: SortOrder
    inviteStatus?: SortOrder
    inviteSentAt?: SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrder
    engagementStatus?: SortOrder
    engagementSignedAt?: SortOrder
    engagementSigner1Id?: SortOrder
    engagementSigner2Id?: SortOrder
    docsRequiredCount?: SortOrder
    docsReceivedCount?: SortOrder
    checklistCompleteAt?: SortOrder
    docConfirmationStatus?: SortOrder
    docConfirmationSignedAt?: SortOrder
    docConfirmationSignerId?: SortOrder
    questionnaireStatus?: SortOrder
    questionnaireCompletedAt?: SortOrder
    idStatus?: SortOrder
    idValidUntil?: SortOrder
    readyForPrep?: SortOrder
    extensionRequested?: SortOrder
    extensionFiled?: SortOrder
    extendedDueDate?: SortOrder
    internalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityTaxYearMinOrderByAggregateInput = {
    id?: SortOrder
    clientEntityId?: SortOrder
    taxYear?: SortOrder
    taxReturnExpected?: SortOrder
    inviteStatus?: SortOrder
    inviteSentAt?: SortOrder
    attemptCount?: SortOrder
    lastError?: SortOrder
    engagementStatus?: SortOrder
    engagementSignedAt?: SortOrder
    engagementSigner1Id?: SortOrder
    engagementSigner2Id?: SortOrder
    docsRequiredCount?: SortOrder
    docsReceivedCount?: SortOrder
    checklistCompleteAt?: SortOrder
    docConfirmationStatus?: SortOrder
    docConfirmationSignedAt?: SortOrder
    docConfirmationSignerId?: SortOrder
    questionnaireStatus?: SortOrder
    questionnaireCompletedAt?: SortOrder
    idStatus?: SortOrder
    idValidUntil?: SortOrder
    readyForPrep?: SortOrder
    extensionRequested?: SortOrder
    extensionFiled?: SortOrder
    extendedDueDate?: SortOrder
    internalStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EntityTaxYearSumOrderByAggregateInput = {
    taxYear?: SortOrder
    attemptCount?: SortOrder
    docsRequiredCount?: SortOrder
    docsReceivedCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumEngagementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementStatus | EnumEngagementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementStatus[] | ListEnumEngagementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementStatus[] | ListEnumEngagementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementStatusWithAggregatesFilter<$PrismaModel> | $Enums.EngagementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEngagementStatusFilter<$PrismaModel>
    _max?: NestedEnumEngagementStatusFilter<$PrismaModel>
  }

  export type EnumConfirmationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfirmationStatus | EnumConfirmationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfirmationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConfirmationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfirmationStatusFilter<$PrismaModel>
    _max?: NestedEnumConfirmationStatusFilter<$PrismaModel>
  }

  export type EnumQuestionnaireStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireStatus | EnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionnaireStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionnaireStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionnaireStatusFilter<$PrismaModel>
  }

  export type EnumIdStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdStatus | EnumIdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdStatus[] | ListEnumIdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdStatus[] | ListEnumIdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdStatusWithAggregatesFilter<$PrismaModel> | $Enums.IdStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdStatusFilter<$PrismaModel>
    _max?: NestedEnumIdStatusFilter<$PrismaModel>
  }

  export type EnumInternalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InternalStatus | EnumInternalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternalStatus[] | ListEnumInternalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InternalStatus[] | ListEnumInternalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInternalStatusWithAggregatesFilter<$PrismaModel> | $Enums.InternalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInternalStatusFilter<$PrismaModel>
    _max?: NestedEnumInternalStatusFilter<$PrismaModel>
  }

  export type StaffProfileScalarRelationFilter = {
    is?: StaffProfileWhereInput
    isNot?: StaffProfileWhereInput
  }

  export type ClientAclClientIdStaffUserIdCompoundUniqueInput = {
    clientId: string
    staffUserId: string
  }

  export type ClientAclCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAclMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientAclMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientStaffPermissionClientIdStaffUserIdCompoundUniqueInput = {
    clientId: string
    staffUserId: string
  }

  export type ClientStaffPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    canSeeTaxes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientStaffPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    canSeeTaxes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientStaffPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    canSeeTaxes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientStaffAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    roleOnClient?: SortOrder
    active?: SortOrder
    assignedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientStaffAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    roleOnClient?: SortOrder
    active?: SortOrder
    assignedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClientStaffAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    roleOnClient?: SortOrder
    active?: SortOrder
    assignedBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderNullableScalarRelationFilter = {
    is?: FolderWhereInput | null
    isNot?: FolderWhereInput | null
  }

  export type FolderCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    folderType?: SortOrder
    isSystem?: SortOrder
    clientVisible?: SortOrder
    staffOnly?: SortOrder
    adminOnly?: SortOrder
    superAdminOnly?: SortOrder
    restrictedAcl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    folderType?: SortOrder
    isSystem?: SortOrder
    clientVisible?: SortOrder
    staffOnly?: SortOrder
    adminOnly?: SortOrder
    superAdminOnly?: SortOrder
    restrictedAcl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    name?: SortOrder
    parentId?: SortOrder
    folderType?: SortOrder
    isSystem?: SortOrder
    clientVisible?: SortOrder
    staffOnly?: SortOrder
    adminOnly?: SortOrder
    superAdminOnly?: SortOrder
    restrictedAcl?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderScalarRelationFilter = {
    is?: FolderWhereInput
    isNot?: FolderWhereInput
  }

  export type FolderAclFolderIdStaffUserIdCompoundUniqueInput = {
    folderId: string
    staffUserId: string
  }

  export type FolderAclCountOrderByAggregateInput = {
    id?: SortOrder
    folderId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderAclMaxOrderByAggregateInput = {
    id?: SortOrder
    folderId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FolderAclMinOrderByAggregateInput = {
    id?: SortOrder
    folderId?: SortOrder
    staffUserId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ChecklistItemFileListRelationFilter = {
    every?: ChecklistItemFileWhereInput
    some?: ChecklistItemFileWhereInput
    none?: ChecklistItemFileWhereInput
  }

  export type ChecklistItemFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentCountOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    folderId?: SortOrder
    storagePath?: SortOrder
    displayName?: SortOrder
    uploadedBy?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type DocumentMaxOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    folderId?: SortOrder
    storagePath?: SortOrder
    displayName?: SortOrder
    uploadedBy?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentMinOrderByAggregateInput = {
    id?: SortOrder
    clientId?: SortOrder
    folderId?: SortOrder
    storagePath?: SortOrder
    displayName?: SortOrder
    uploadedBy?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DocumentSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumChecklistItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistItemStatus | EnumChecklistItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistItemStatus[] | ListEnumChecklistItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistItemStatus[] | ListEnumChecklistItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistItemStatusFilter<$PrismaModel> | $Enums.ChecklistItemStatus
  }

  export type EntityTaxYearScalarRelationFilter = {
    is?: EntityTaxYearWhereInput
    isNot?: EntityTaxYearWhereInput
  }

  export type ChecklistItemCountOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    required?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrder
    markedNotApplicableAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChecklistItemMaxOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    required?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrder
    markedNotApplicableAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChecklistItemMinOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    itemName?: SortOrder
    itemType?: SortOrder
    required?: SortOrder
    status?: SortOrder
    receivedAt?: SortOrder
    markedNotApplicableAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumChecklistItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistItemStatus | EnumChecklistItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistItemStatus[] | ListEnumChecklistItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistItemStatus[] | ListEnumChecklistItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChecklistItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChecklistItemStatusFilter<$PrismaModel>
    _max?: NestedEnumChecklistItemStatusFilter<$PrismaModel>
  }

  export type ChecklistItemScalarRelationFilter = {
    is?: ChecklistItemWhereInput
    isNot?: ChecklistItemWhereInput
  }

  export type DocumentScalarRelationFilter = {
    is?: DocumentWhereInput
    isNot?: DocumentWhereInput
  }

  export type ChecklistItemFileChecklistItemIdDocumentIdCompoundUniqueInput = {
    checklistItemId: string
    documentId: string
  }

  export type ChecklistItemFileCountOrderByAggregateInput = {
    id?: SortOrder
    checklistItemId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChecklistItemFileMaxOrderByAggregateInput = {
    id?: SortOrder
    checklistItemId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
  }

  export type ChecklistItemFileMinOrderByAggregateInput = {
    id?: SortOrder
    checklistItemId?: SortOrder
    documentId?: SortOrder
    createdAt?: SortOrder
  }

  export type QuestionnaireQuestionListRelationFilter = {
    every?: QuestionnaireQuestionWhereInput
    some?: QuestionnaireQuestionWhereInput
    none?: QuestionnaireQuestionWhereInput
  }

  export type QuestionnaireQuestionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type QuestionnaireSectionCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireSectionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type QuestionnaireSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireSectionMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    order?: SortOrder
    active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireSectionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type QuestionnaireSectionScalarRelationFilter = {
    is?: QuestionnaireSectionWhereInput
    isNot?: QuestionnaireSectionWhereInput
  }

  export type QuestionnaireQuestionCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireQuestionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type QuestionnaireQuestionMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireQuestionMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    questionText?: SortOrder
    questionType?: SortOrder
    required?: SortOrder
    order?: SortOrder
    conditionalLogic?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireQuestionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type EnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type QuestionnaireQuestionScalarRelationFilter = {
    is?: QuestionnaireQuestionWhereInput
    isNot?: QuestionnaireQuestionWhereInput
  }

  export type QuestionnaireAnswerEntityTaxYearIdQuestionIdCompoundUniqueInput = {
    entityTaxYearId: string
    questionId: string
  }

  export type QuestionnaireAnswerCountOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    questionId?: SortOrder
    answerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireAnswerMaxOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    questionId?: SortOrder
    answerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type QuestionnaireAnswerMinOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    questionId?: SortOrder
    answerValue?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EngagementSignatureCountOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
  }

  export type EngagementSignatureMaxOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
  }

  export type EngagementSignatureMinOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
  }

  export type EfileAuthorizationCountOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
  }

  export type EfileAuthorizationMaxOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
  }

  export type EfileAuthorizationMinOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    signerName?: SortOrder
    signerEmail?: SortOrder
    signatureData?: SortOrder
    signedAt?: SortOrder
  }

  export type MessageThreadCountOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageThreadMaxOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageThreadMinOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    archived?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageThreadScalarRelationFilter = {
    is?: MessageThreadWhereInput
    isNot?: MessageThreadWhereInput
  }

  export type ThreadParticipantThreadIdUserIdCompoundUniqueInput = {
    threadId: string
    userId: string
  }

  export type ThreadParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
  }

  export type ThreadParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
  }

  export type ThreadParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    userId?: SortOrder
    userType?: SortOrder
    createdAt?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    threadId?: SortOrder
    senderId?: SortOrder
    senderType?: SortOrder
    content?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type ReminderStateCountOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    reminderType?: SortOrder
    nextReminderAt?: SortOrder
    lastReminderAt?: SortOrder
    reminderCount?: SortOrder
    paused?: SortOrder
    pausedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReminderStateAvgOrderByAggregateInput = {
    reminderCount?: SortOrder
  }

  export type ReminderStateMaxOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    reminderType?: SortOrder
    nextReminderAt?: SortOrder
    lastReminderAt?: SortOrder
    reminderCount?: SortOrder
    paused?: SortOrder
    pausedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReminderStateMinOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    reminderType?: SortOrder
    nextReminderAt?: SortOrder
    lastReminderAt?: SortOrder
    reminderCount?: SortOrder
    paused?: SortOrder
    pausedReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReminderStateSumOrderByAggregateInput = {
    reminderCount?: SortOrder
  }

  export type EnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type StatusAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type StatusAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type StatusAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    oldStatus?: SortOrder
    newStatus?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type PermissionAuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    changeType?: SortOrder
    clientId?: SortOrder
    staffUserId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    changedBy?: SortOrder
    reason?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDocumentEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentEventType | EnumDocumentEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentEventType[] | ListEnumDocumentEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentEventType[] | ListEnumDocumentEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentEventTypeFilter<$PrismaModel> | $Enums.DocumentEventType
  }

  export type DocumentEventCountOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    eventType?: SortOrder
    documentId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentEventMaxOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    eventType?: SortOrder
    documentId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type DocumentEventMinOrderByAggregateInput = {
    id?: SortOrder
    entityTaxYearId?: SortOrder
    eventType?: SortOrder
    documentId?: SortOrder
    description?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumDocumentEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentEventType | EnumDocumentEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentEventType[] | ListEnumDocumentEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentEventType[] | ListEnumDocumentEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentEventTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentEventTypeFilter<$PrismaModel>
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type StaffProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type StaffProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    upsert?: StaffProfileUpsertWithoutUserInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutUserInput, StaffProfileUpdateWithoutUserInput>, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type StaffProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUserInput
    upsert?: StaffProfileUpsertWithoutUserInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutUserInput, StaffProfileUpdateWithoutUserInput>, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutProfileInput = {
    create?: XOR<StaffProfileCreateWithoutProfileInput, StaffProfileUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutProfileInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type AccountUserCreateNestedManyWithoutProfileInput = {
    create?: XOR<AccountUserCreateWithoutProfileInput, AccountUserUncheckedCreateWithoutProfileInput> | AccountUserCreateWithoutProfileInput[] | AccountUserUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AccountUserCreateOrConnectWithoutProfileInput | AccountUserCreateOrConnectWithoutProfileInput[]
    createMany?: AccountUserCreateManyProfileInputEnvelope
    connect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
  }

  export type StaffProfileUncheckedCreateNestedOneWithoutProfileInput = {
    create?: XOR<StaffProfileCreateWithoutProfileInput, StaffProfileUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutProfileInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type AccountUserUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<AccountUserCreateWithoutProfileInput, AccountUserUncheckedCreateWithoutProfileInput> | AccountUserCreateWithoutProfileInput[] | AccountUserUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AccountUserCreateOrConnectWithoutProfileInput | AccountUserCreateOrConnectWithoutProfileInput[]
    createMany?: AccountUserCreateManyProfileInputEnvelope
    connect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
  }

  export type EnumUserTypeFieldUpdateOperationsInput = {
    set?: $Enums.UserType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type StaffProfileUpdateOneWithoutProfileNestedInput = {
    create?: XOR<StaffProfileCreateWithoutProfileInput, StaffProfileUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutProfileInput
    upsert?: StaffProfileUpsertWithoutProfileInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutProfileInput, StaffProfileUpdateWithoutProfileInput>, StaffProfileUncheckedUpdateWithoutProfileInput>
  }

  export type AccountUserUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AccountUserCreateWithoutProfileInput, AccountUserUncheckedCreateWithoutProfileInput> | AccountUserCreateWithoutProfileInput[] | AccountUserUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AccountUserCreateOrConnectWithoutProfileInput | AccountUserCreateOrConnectWithoutProfileInput[]
    upsert?: AccountUserUpsertWithWhereUniqueWithoutProfileInput | AccountUserUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AccountUserCreateManyProfileInputEnvelope
    set?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    disconnect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    delete?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    connect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    update?: AccountUserUpdateWithWhereUniqueWithoutProfileInput | AccountUserUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AccountUserUpdateManyWithWhereWithoutProfileInput | AccountUserUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AccountUserScalarWhereInput | AccountUserScalarWhereInput[]
  }

  export type StaffProfileUncheckedUpdateOneWithoutProfileNestedInput = {
    create?: XOR<StaffProfileCreateWithoutProfileInput, StaffProfileUncheckedCreateWithoutProfileInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutProfileInput
    upsert?: StaffProfileUpsertWithoutProfileInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutProfileInput, StaffProfileUpdateWithoutProfileInput>, StaffProfileUncheckedUpdateWithoutProfileInput>
  }

  export type AccountUserUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<AccountUserCreateWithoutProfileInput, AccountUserUncheckedCreateWithoutProfileInput> | AccountUserCreateWithoutProfileInput[] | AccountUserUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: AccountUserCreateOrConnectWithoutProfileInput | AccountUserCreateOrConnectWithoutProfileInput[]
    upsert?: AccountUserUpsertWithWhereUniqueWithoutProfileInput | AccountUserUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: AccountUserCreateManyProfileInputEnvelope
    set?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    disconnect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    delete?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    connect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    update?: AccountUserUpdateWithWhereUniqueWithoutProfileInput | AccountUserUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: AccountUserUpdateManyWithWhereWithoutProfileInput | AccountUserUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: AccountUserScalarWhereInput | AccountUserScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStaffProfileInput = {
    create?: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffProfileInput
    connect?: UserWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutStaffProfileInput = {
    create?: XOR<ProfileCreateWithoutStaffProfileInput, ProfileUncheckedCreateWithoutStaffProfileInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStaffProfileInput
    connect?: ProfileWhereUniqueInput
  }

  export type ClientAclCreateNestedManyWithoutStaffInput = {
    create?: XOR<ClientAclCreateWithoutStaffInput, ClientAclUncheckedCreateWithoutStaffInput> | ClientAclCreateWithoutStaffInput[] | ClientAclUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientAclCreateOrConnectWithoutStaffInput | ClientAclCreateOrConnectWithoutStaffInput[]
    createMany?: ClientAclCreateManyStaffInputEnvelope
    connect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
  }

  export type ClientStaffPermissionCreateNestedManyWithoutStaffInput = {
    create?: XOR<ClientStaffPermissionCreateWithoutStaffInput, ClientStaffPermissionUncheckedCreateWithoutStaffInput> | ClientStaffPermissionCreateWithoutStaffInput[] | ClientStaffPermissionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientStaffPermissionCreateOrConnectWithoutStaffInput | ClientStaffPermissionCreateOrConnectWithoutStaffInput[]
    createMany?: ClientStaffPermissionCreateManyStaffInputEnvelope
    connect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
  }

  export type ClientStaffAssignmentCreateNestedManyWithoutStaffInput = {
    create?: XOR<ClientStaffAssignmentCreateWithoutStaffInput, ClientStaffAssignmentUncheckedCreateWithoutStaffInput> | ClientStaffAssignmentCreateWithoutStaffInput[] | ClientStaffAssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientStaffAssignmentCreateOrConnectWithoutStaffInput | ClientStaffAssignmentCreateOrConnectWithoutStaffInput[]
    createMany?: ClientStaffAssignmentCreateManyStaffInputEnvelope
    connect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
  }

  export type FolderAclCreateNestedManyWithoutStaffInput = {
    create?: XOR<FolderAclCreateWithoutStaffInput, FolderAclUncheckedCreateWithoutStaffInput> | FolderAclCreateWithoutStaffInput[] | FolderAclUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: FolderAclCreateOrConnectWithoutStaffInput | FolderAclCreateOrConnectWithoutStaffInput[]
    createMany?: FolderAclCreateManyStaffInputEnvelope
    connect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ThreadParticipantCreateNestedManyWithoutStaffInput = {
    create?: XOR<ThreadParticipantCreateWithoutStaffInput, ThreadParticipantUncheckedCreateWithoutStaffInput> | ThreadParticipantCreateWithoutStaffInput[] | ThreadParticipantUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ThreadParticipantCreateOrConnectWithoutStaffInput | ThreadParticipantCreateOrConnectWithoutStaffInput[]
    createMany?: ThreadParticipantCreateManyStaffInputEnvelope
    connect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type StatusAuditLogCreateNestedManyWithoutStaffInput = {
    create?: XOR<StatusAuditLogCreateWithoutStaffInput, StatusAuditLogUncheckedCreateWithoutStaffInput> | StatusAuditLogCreateWithoutStaffInput[] | StatusAuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StatusAuditLogCreateOrConnectWithoutStaffInput | StatusAuditLogCreateOrConnectWithoutStaffInput[]
    createMany?: StatusAuditLogCreateManyStaffInputEnvelope
    connect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
  }

  export type PermissionAuditLogCreateNestedManyWithoutStaffInput = {
    create?: XOR<PermissionAuditLogCreateWithoutStaffInput, PermissionAuditLogUncheckedCreateWithoutStaffInput> | PermissionAuditLogCreateWithoutStaffInput[] | PermissionAuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PermissionAuditLogCreateOrConnectWithoutStaffInput | PermissionAuditLogCreateOrConnectWithoutStaffInput[]
    createMany?: PermissionAuditLogCreateManyStaffInputEnvelope
    connect?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
  }

  export type ClientAclUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ClientAclCreateWithoutStaffInput, ClientAclUncheckedCreateWithoutStaffInput> | ClientAclCreateWithoutStaffInput[] | ClientAclUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientAclCreateOrConnectWithoutStaffInput | ClientAclCreateOrConnectWithoutStaffInput[]
    createMany?: ClientAclCreateManyStaffInputEnvelope
    connect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
  }

  export type ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ClientStaffPermissionCreateWithoutStaffInput, ClientStaffPermissionUncheckedCreateWithoutStaffInput> | ClientStaffPermissionCreateWithoutStaffInput[] | ClientStaffPermissionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientStaffPermissionCreateOrConnectWithoutStaffInput | ClientStaffPermissionCreateOrConnectWithoutStaffInput[]
    createMany?: ClientStaffPermissionCreateManyStaffInputEnvelope
    connect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
  }

  export type ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ClientStaffAssignmentCreateWithoutStaffInput, ClientStaffAssignmentUncheckedCreateWithoutStaffInput> | ClientStaffAssignmentCreateWithoutStaffInput[] | ClientStaffAssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientStaffAssignmentCreateOrConnectWithoutStaffInput | ClientStaffAssignmentCreateOrConnectWithoutStaffInput[]
    createMany?: ClientStaffAssignmentCreateManyStaffInputEnvelope
    connect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
  }

  export type FolderAclUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<FolderAclCreateWithoutStaffInput, FolderAclUncheckedCreateWithoutStaffInput> | FolderAclCreateWithoutStaffInput[] | FolderAclUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: FolderAclCreateOrConnectWithoutStaffInput | FolderAclCreateOrConnectWithoutStaffInput[]
    createMany?: FolderAclCreateManyStaffInputEnvelope
    connect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<ThreadParticipantCreateWithoutStaffInput, ThreadParticipantUncheckedCreateWithoutStaffInput> | ThreadParticipantCreateWithoutStaffInput[] | ThreadParticipantUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ThreadParticipantCreateOrConnectWithoutStaffInput | ThreadParticipantCreateOrConnectWithoutStaffInput[]
    createMany?: ThreadParticipantCreateManyStaffInputEnvelope
    connect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<StatusAuditLogCreateWithoutStaffInput, StatusAuditLogUncheckedCreateWithoutStaffInput> | StatusAuditLogCreateWithoutStaffInput[] | StatusAuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StatusAuditLogCreateOrConnectWithoutStaffInput | StatusAuditLogCreateOrConnectWithoutStaffInput[]
    createMany?: StatusAuditLogCreateManyStaffInputEnvelope
    connect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
  }

  export type PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput = {
    create?: XOR<PermissionAuditLogCreateWithoutStaffInput, PermissionAuditLogUncheckedCreateWithoutStaffInput> | PermissionAuditLogCreateWithoutStaffInput[] | PermissionAuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PermissionAuditLogCreateOrConnectWithoutStaffInput | PermissionAuditLogCreateOrConnectWithoutStaffInput[]
    createMany?: PermissionAuditLogCreateManyStaffInputEnvelope
    connect?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
  }

  export type EnumStaffRoleFieldUpdateOperationsInput = {
    set?: $Enums.StaffRole
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type UserUpdateOneRequiredWithoutStaffProfileNestedInput = {
    create?: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStaffProfileInput
    upsert?: UserUpsertWithoutStaffProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStaffProfileInput, UserUpdateWithoutStaffProfileInput>, UserUncheckedUpdateWithoutStaffProfileInput>
  }

  export type ProfileUpdateOneRequiredWithoutStaffProfileNestedInput = {
    create?: XOR<ProfileCreateWithoutStaffProfileInput, ProfileUncheckedCreateWithoutStaffProfileInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutStaffProfileInput
    upsert?: ProfileUpsertWithoutStaffProfileInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutStaffProfileInput, ProfileUpdateWithoutStaffProfileInput>, ProfileUncheckedUpdateWithoutStaffProfileInput>
  }

  export type ClientAclUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ClientAclCreateWithoutStaffInput, ClientAclUncheckedCreateWithoutStaffInput> | ClientAclCreateWithoutStaffInput[] | ClientAclUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientAclCreateOrConnectWithoutStaffInput | ClientAclCreateOrConnectWithoutStaffInput[]
    upsert?: ClientAclUpsertWithWhereUniqueWithoutStaffInput | ClientAclUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ClientAclCreateManyStaffInputEnvelope
    set?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    disconnect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    delete?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    connect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    update?: ClientAclUpdateWithWhereUniqueWithoutStaffInput | ClientAclUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ClientAclUpdateManyWithWhereWithoutStaffInput | ClientAclUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ClientAclScalarWhereInput | ClientAclScalarWhereInput[]
  }

  export type ClientStaffPermissionUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ClientStaffPermissionCreateWithoutStaffInput, ClientStaffPermissionUncheckedCreateWithoutStaffInput> | ClientStaffPermissionCreateWithoutStaffInput[] | ClientStaffPermissionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientStaffPermissionCreateOrConnectWithoutStaffInput | ClientStaffPermissionCreateOrConnectWithoutStaffInput[]
    upsert?: ClientStaffPermissionUpsertWithWhereUniqueWithoutStaffInput | ClientStaffPermissionUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ClientStaffPermissionCreateManyStaffInputEnvelope
    set?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    disconnect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    delete?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    connect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    update?: ClientStaffPermissionUpdateWithWhereUniqueWithoutStaffInput | ClientStaffPermissionUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ClientStaffPermissionUpdateManyWithWhereWithoutStaffInput | ClientStaffPermissionUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ClientStaffPermissionScalarWhereInput | ClientStaffPermissionScalarWhereInput[]
  }

  export type ClientStaffAssignmentUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ClientStaffAssignmentCreateWithoutStaffInput, ClientStaffAssignmentUncheckedCreateWithoutStaffInput> | ClientStaffAssignmentCreateWithoutStaffInput[] | ClientStaffAssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientStaffAssignmentCreateOrConnectWithoutStaffInput | ClientStaffAssignmentCreateOrConnectWithoutStaffInput[]
    upsert?: ClientStaffAssignmentUpsertWithWhereUniqueWithoutStaffInput | ClientStaffAssignmentUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ClientStaffAssignmentCreateManyStaffInputEnvelope
    set?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    disconnect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    delete?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    connect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    update?: ClientStaffAssignmentUpdateWithWhereUniqueWithoutStaffInput | ClientStaffAssignmentUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ClientStaffAssignmentUpdateManyWithWhereWithoutStaffInput | ClientStaffAssignmentUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ClientStaffAssignmentScalarWhereInput | ClientStaffAssignmentScalarWhereInput[]
  }

  export type FolderAclUpdateManyWithoutStaffNestedInput = {
    create?: XOR<FolderAclCreateWithoutStaffInput, FolderAclUncheckedCreateWithoutStaffInput> | FolderAclCreateWithoutStaffInput[] | FolderAclUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: FolderAclCreateOrConnectWithoutStaffInput | FolderAclCreateOrConnectWithoutStaffInput[]
    upsert?: FolderAclUpsertWithWhereUniqueWithoutStaffInput | FolderAclUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: FolderAclCreateManyStaffInputEnvelope
    set?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    disconnect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    delete?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    connect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    update?: FolderAclUpdateWithWhereUniqueWithoutStaffInput | FolderAclUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: FolderAclUpdateManyWithWhereWithoutStaffInput | FolderAclUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: FolderAclScalarWhereInput | FolderAclScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploaderInput | DocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploaderInput | DocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploaderInput | DocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ThreadParticipantUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ThreadParticipantCreateWithoutStaffInput, ThreadParticipantUncheckedCreateWithoutStaffInput> | ThreadParticipantCreateWithoutStaffInput[] | ThreadParticipantUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ThreadParticipantCreateOrConnectWithoutStaffInput | ThreadParticipantCreateOrConnectWithoutStaffInput[]
    upsert?: ThreadParticipantUpsertWithWhereUniqueWithoutStaffInput | ThreadParticipantUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ThreadParticipantCreateManyStaffInputEnvelope
    set?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    disconnect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    delete?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    connect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    update?: ThreadParticipantUpdateWithWhereUniqueWithoutStaffInput | ThreadParticipantUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ThreadParticipantUpdateManyWithWhereWithoutStaffInput | ThreadParticipantUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ThreadParticipantScalarWhereInput | ThreadParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type StatusAuditLogUpdateManyWithoutStaffNestedInput = {
    create?: XOR<StatusAuditLogCreateWithoutStaffInput, StatusAuditLogUncheckedCreateWithoutStaffInput> | StatusAuditLogCreateWithoutStaffInput[] | StatusAuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StatusAuditLogCreateOrConnectWithoutStaffInput | StatusAuditLogCreateOrConnectWithoutStaffInput[]
    upsert?: StatusAuditLogUpsertWithWhereUniqueWithoutStaffInput | StatusAuditLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: StatusAuditLogCreateManyStaffInputEnvelope
    set?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    disconnect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    delete?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    connect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    update?: StatusAuditLogUpdateWithWhereUniqueWithoutStaffInput | StatusAuditLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: StatusAuditLogUpdateManyWithWhereWithoutStaffInput | StatusAuditLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: StatusAuditLogScalarWhereInput | StatusAuditLogScalarWhereInput[]
  }

  export type PermissionAuditLogUpdateManyWithoutStaffNestedInput = {
    create?: XOR<PermissionAuditLogCreateWithoutStaffInput, PermissionAuditLogUncheckedCreateWithoutStaffInput> | PermissionAuditLogCreateWithoutStaffInput[] | PermissionAuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PermissionAuditLogCreateOrConnectWithoutStaffInput | PermissionAuditLogCreateOrConnectWithoutStaffInput[]
    upsert?: PermissionAuditLogUpsertWithWhereUniqueWithoutStaffInput | PermissionAuditLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: PermissionAuditLogCreateManyStaffInputEnvelope
    set?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
    disconnect?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
    delete?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
    connect?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
    update?: PermissionAuditLogUpdateWithWhereUniqueWithoutStaffInput | PermissionAuditLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: PermissionAuditLogUpdateManyWithWhereWithoutStaffInput | PermissionAuditLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: PermissionAuditLogScalarWhereInput | PermissionAuditLogScalarWhereInput[]
  }

  export type ClientAclUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ClientAclCreateWithoutStaffInput, ClientAclUncheckedCreateWithoutStaffInput> | ClientAclCreateWithoutStaffInput[] | ClientAclUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientAclCreateOrConnectWithoutStaffInput | ClientAclCreateOrConnectWithoutStaffInput[]
    upsert?: ClientAclUpsertWithWhereUniqueWithoutStaffInput | ClientAclUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ClientAclCreateManyStaffInputEnvelope
    set?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    disconnect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    delete?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    connect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    update?: ClientAclUpdateWithWhereUniqueWithoutStaffInput | ClientAclUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ClientAclUpdateManyWithWhereWithoutStaffInput | ClientAclUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ClientAclScalarWhereInput | ClientAclScalarWhereInput[]
  }

  export type ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ClientStaffPermissionCreateWithoutStaffInput, ClientStaffPermissionUncheckedCreateWithoutStaffInput> | ClientStaffPermissionCreateWithoutStaffInput[] | ClientStaffPermissionUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientStaffPermissionCreateOrConnectWithoutStaffInput | ClientStaffPermissionCreateOrConnectWithoutStaffInput[]
    upsert?: ClientStaffPermissionUpsertWithWhereUniqueWithoutStaffInput | ClientStaffPermissionUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ClientStaffPermissionCreateManyStaffInputEnvelope
    set?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    disconnect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    delete?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    connect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    update?: ClientStaffPermissionUpdateWithWhereUniqueWithoutStaffInput | ClientStaffPermissionUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ClientStaffPermissionUpdateManyWithWhereWithoutStaffInput | ClientStaffPermissionUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ClientStaffPermissionScalarWhereInput | ClientStaffPermissionScalarWhereInput[]
  }

  export type ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ClientStaffAssignmentCreateWithoutStaffInput, ClientStaffAssignmentUncheckedCreateWithoutStaffInput> | ClientStaffAssignmentCreateWithoutStaffInput[] | ClientStaffAssignmentUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ClientStaffAssignmentCreateOrConnectWithoutStaffInput | ClientStaffAssignmentCreateOrConnectWithoutStaffInput[]
    upsert?: ClientStaffAssignmentUpsertWithWhereUniqueWithoutStaffInput | ClientStaffAssignmentUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ClientStaffAssignmentCreateManyStaffInputEnvelope
    set?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    disconnect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    delete?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    connect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    update?: ClientStaffAssignmentUpdateWithWhereUniqueWithoutStaffInput | ClientStaffAssignmentUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ClientStaffAssignmentUpdateManyWithWhereWithoutStaffInput | ClientStaffAssignmentUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ClientStaffAssignmentScalarWhereInput | ClientStaffAssignmentScalarWhereInput[]
  }

  export type FolderAclUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<FolderAclCreateWithoutStaffInput, FolderAclUncheckedCreateWithoutStaffInput> | FolderAclCreateWithoutStaffInput[] | FolderAclUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: FolderAclCreateOrConnectWithoutStaffInput | FolderAclCreateOrConnectWithoutStaffInput[]
    upsert?: FolderAclUpsertWithWhereUniqueWithoutStaffInput | FolderAclUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: FolderAclCreateManyStaffInputEnvelope
    set?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    disconnect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    delete?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    connect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    update?: FolderAclUpdateWithWhereUniqueWithoutStaffInput | FolderAclUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: FolderAclUpdateManyWithWhereWithoutStaffInput | FolderAclUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: FolderAclScalarWhereInput | FolderAclScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput> | DocumentCreateWithoutUploaderInput[] | DocumentUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutUploaderInput | DocumentCreateOrConnectWithoutUploaderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutUploaderInput | DocumentUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: DocumentCreateManyUploaderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutUploaderInput | DocumentUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutUploaderInput | DocumentUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<ThreadParticipantCreateWithoutStaffInput, ThreadParticipantUncheckedCreateWithoutStaffInput> | ThreadParticipantCreateWithoutStaffInput[] | ThreadParticipantUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: ThreadParticipantCreateOrConnectWithoutStaffInput | ThreadParticipantCreateOrConnectWithoutStaffInput[]
    upsert?: ThreadParticipantUpsertWithWhereUniqueWithoutStaffInput | ThreadParticipantUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: ThreadParticipantCreateManyStaffInputEnvelope
    set?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    disconnect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    delete?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    connect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    update?: ThreadParticipantUpdateWithWhereUniqueWithoutStaffInput | ThreadParticipantUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: ThreadParticipantUpdateManyWithWhereWithoutStaffInput | ThreadParticipantUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: ThreadParticipantScalarWhereInput | ThreadParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<StatusAuditLogCreateWithoutStaffInput, StatusAuditLogUncheckedCreateWithoutStaffInput> | StatusAuditLogCreateWithoutStaffInput[] | StatusAuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: StatusAuditLogCreateOrConnectWithoutStaffInput | StatusAuditLogCreateOrConnectWithoutStaffInput[]
    upsert?: StatusAuditLogUpsertWithWhereUniqueWithoutStaffInput | StatusAuditLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: StatusAuditLogCreateManyStaffInputEnvelope
    set?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    disconnect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    delete?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    connect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    update?: StatusAuditLogUpdateWithWhereUniqueWithoutStaffInput | StatusAuditLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: StatusAuditLogUpdateManyWithWhereWithoutStaffInput | StatusAuditLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: StatusAuditLogScalarWhereInput | StatusAuditLogScalarWhereInput[]
  }

  export type PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput = {
    create?: XOR<PermissionAuditLogCreateWithoutStaffInput, PermissionAuditLogUncheckedCreateWithoutStaffInput> | PermissionAuditLogCreateWithoutStaffInput[] | PermissionAuditLogUncheckedCreateWithoutStaffInput[]
    connectOrCreate?: PermissionAuditLogCreateOrConnectWithoutStaffInput | PermissionAuditLogCreateOrConnectWithoutStaffInput[]
    upsert?: PermissionAuditLogUpsertWithWhereUniqueWithoutStaffInput | PermissionAuditLogUpsertWithWhereUniqueWithoutStaffInput[]
    createMany?: PermissionAuditLogCreateManyStaffInputEnvelope
    set?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
    disconnect?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
    delete?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
    connect?: PermissionAuditLogWhereUniqueInput | PermissionAuditLogWhereUniqueInput[]
    update?: PermissionAuditLogUpdateWithWhereUniqueWithoutStaffInput | PermissionAuditLogUpdateWithWhereUniqueWithoutStaffInput[]
    updateMany?: PermissionAuditLogUpdateManyWithWhereWithoutStaffInput | PermissionAuditLogUpdateManyWithWhereWithoutStaffInput[]
    deleteMany?: PermissionAuditLogScalarWhereInput | PermissionAuditLogScalarWhereInput[]
  }

  export type AccountUserCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput> | AccountUserCreateWithoutAccountInput[] | AccountUserUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountUserCreateOrConnectWithoutAccountInput | AccountUserCreateOrConnectWithoutAccountInput[]
    createMany?: AccountUserCreateManyAccountInputEnvelope
    connect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
  }

  export type ClientEntityCreateNestedManyWithoutAccountInput = {
    create?: XOR<ClientEntityCreateWithoutAccountInput, ClientEntityUncheckedCreateWithoutAccountInput> | ClientEntityCreateWithoutAccountInput[] | ClientEntityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ClientEntityCreateOrConnectWithoutAccountInput | ClientEntityCreateOrConnectWithoutAccountInput[]
    createMany?: ClientEntityCreateManyAccountInputEnvelope
    connect?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
  }

  export type AccountUserUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput> | AccountUserCreateWithoutAccountInput[] | AccountUserUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountUserCreateOrConnectWithoutAccountInput | AccountUserCreateOrConnectWithoutAccountInput[]
    createMany?: AccountUserCreateManyAccountInputEnvelope
    connect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
  }

  export type ClientEntityUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<ClientEntityCreateWithoutAccountInput, ClientEntityUncheckedCreateWithoutAccountInput> | ClientEntityCreateWithoutAccountInput[] | ClientEntityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ClientEntityCreateOrConnectWithoutAccountInput | ClientEntityCreateOrConnectWithoutAccountInput[]
    createMany?: ClientEntityCreateManyAccountInputEnvelope
    connect?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
  }

  export type AccountUserUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput> | AccountUserCreateWithoutAccountInput[] | AccountUserUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountUserCreateOrConnectWithoutAccountInput | AccountUserCreateOrConnectWithoutAccountInput[]
    upsert?: AccountUserUpsertWithWhereUniqueWithoutAccountInput | AccountUserUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountUserCreateManyAccountInputEnvelope
    set?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    disconnect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    delete?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    connect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    update?: AccountUserUpdateWithWhereUniqueWithoutAccountInput | AccountUserUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountUserUpdateManyWithWhereWithoutAccountInput | AccountUserUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountUserScalarWhereInput | AccountUserScalarWhereInput[]
  }

  export type ClientEntityUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ClientEntityCreateWithoutAccountInput, ClientEntityUncheckedCreateWithoutAccountInput> | ClientEntityCreateWithoutAccountInput[] | ClientEntityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ClientEntityCreateOrConnectWithoutAccountInput | ClientEntityCreateOrConnectWithoutAccountInput[]
    upsert?: ClientEntityUpsertWithWhereUniqueWithoutAccountInput | ClientEntityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ClientEntityCreateManyAccountInputEnvelope
    set?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
    disconnect?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
    delete?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
    connect?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
    update?: ClientEntityUpdateWithWhereUniqueWithoutAccountInput | ClientEntityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ClientEntityUpdateManyWithWhereWithoutAccountInput | ClientEntityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ClientEntityScalarWhereInput | ClientEntityScalarWhereInput[]
  }

  export type AccountUserUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput> | AccountUserCreateWithoutAccountInput[] | AccountUserUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: AccountUserCreateOrConnectWithoutAccountInput | AccountUserCreateOrConnectWithoutAccountInput[]
    upsert?: AccountUserUpsertWithWhereUniqueWithoutAccountInput | AccountUserUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: AccountUserCreateManyAccountInputEnvelope
    set?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    disconnect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    delete?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    connect?: AccountUserWhereUniqueInput | AccountUserWhereUniqueInput[]
    update?: AccountUserUpdateWithWhereUniqueWithoutAccountInput | AccountUserUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: AccountUserUpdateManyWithWhereWithoutAccountInput | AccountUserUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: AccountUserScalarWhereInput | AccountUserScalarWhereInput[]
  }

  export type ClientEntityUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<ClientEntityCreateWithoutAccountInput, ClientEntityUncheckedCreateWithoutAccountInput> | ClientEntityCreateWithoutAccountInput[] | ClientEntityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: ClientEntityCreateOrConnectWithoutAccountInput | ClientEntityCreateOrConnectWithoutAccountInput[]
    upsert?: ClientEntityUpsertWithWhereUniqueWithoutAccountInput | ClientEntityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: ClientEntityCreateManyAccountInputEnvelope
    set?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
    disconnect?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
    delete?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
    connect?: ClientEntityWhereUniqueInput | ClientEntityWhereUniqueInput[]
    update?: ClientEntityUpdateWithWhereUniqueWithoutAccountInput | ClientEntityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: ClientEntityUpdateManyWithWhereWithoutAccountInput | ClientEntityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: ClientEntityScalarWhereInput | ClientEntityScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutAccountUsersInput = {
    create?: XOR<AccountCreateWithoutAccountUsersInput, AccountUncheckedCreateWithoutAccountUsersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccountUsersInput
    connect?: AccountWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutAccountUsersInput = {
    create?: XOR<ProfileCreateWithoutAccountUsersInput, ProfileUncheckedCreateWithoutAccountUsersInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAccountUsersInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumClientRoleFieldUpdateOperationsInput = {
    set?: $Enums.ClientRole
  }

  export type AccountUpdateOneRequiredWithoutAccountUsersNestedInput = {
    create?: XOR<AccountCreateWithoutAccountUsersInput, AccountUncheckedCreateWithoutAccountUsersInput>
    connectOrCreate?: AccountCreateOrConnectWithoutAccountUsersInput
    upsert?: AccountUpsertWithoutAccountUsersInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutAccountUsersInput, AccountUpdateWithoutAccountUsersInput>, AccountUncheckedUpdateWithoutAccountUsersInput>
  }

  export type ProfileUpdateOneRequiredWithoutAccountUsersNestedInput = {
    create?: XOR<ProfileCreateWithoutAccountUsersInput, ProfileUncheckedCreateWithoutAccountUsersInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAccountUsersInput
    upsert?: ProfileUpsertWithoutAccountUsersInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutAccountUsersInput, ProfileUpdateWithoutAccountUsersInput>, ProfileUncheckedUpdateWithoutAccountUsersInput>
  }

  export type AccountCreateNestedOneWithoutEntitiesInput = {
    create?: XOR<AccountCreateWithoutEntitiesInput, AccountUncheckedCreateWithoutEntitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEntitiesInput
    connect?: AccountWhereUniqueInput
  }

  export type EntityTaxYearCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<EntityTaxYearCreateWithoutClientEntityInput, EntityTaxYearUncheckedCreateWithoutClientEntityInput> | EntityTaxYearCreateWithoutClientEntityInput[] | EntityTaxYearUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutClientEntityInput | EntityTaxYearCreateOrConnectWithoutClientEntityInput[]
    createMany?: EntityTaxYearCreateManyClientEntityInputEnvelope
    connect?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
  }

  export type FolderCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<FolderCreateWithoutClientEntityInput, FolderUncheckedCreateWithoutClientEntityInput> | FolderCreateWithoutClientEntityInput[] | FolderUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutClientEntityInput | FolderCreateOrConnectWithoutClientEntityInput[]
    createMany?: FolderCreateManyClientEntityInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<DocumentCreateWithoutClientEntityInput, DocumentUncheckedCreateWithoutClientEntityInput> | DocumentCreateWithoutClientEntityInput[] | DocumentUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientEntityInput | DocumentCreateOrConnectWithoutClientEntityInput[]
    createMany?: DocumentCreateManyClientEntityInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClientAclCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<ClientAclCreateWithoutClientEntityInput, ClientAclUncheckedCreateWithoutClientEntityInput> | ClientAclCreateWithoutClientEntityInput[] | ClientAclUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientAclCreateOrConnectWithoutClientEntityInput | ClientAclCreateOrConnectWithoutClientEntityInput[]
    createMany?: ClientAclCreateManyClientEntityInputEnvelope
    connect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
  }

  export type ClientStaffPermissionCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<ClientStaffPermissionCreateWithoutClientEntityInput, ClientStaffPermissionUncheckedCreateWithoutClientEntityInput> | ClientStaffPermissionCreateWithoutClientEntityInput[] | ClientStaffPermissionUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientStaffPermissionCreateOrConnectWithoutClientEntityInput | ClientStaffPermissionCreateOrConnectWithoutClientEntityInput[]
    createMany?: ClientStaffPermissionCreateManyClientEntityInputEnvelope
    connect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
  }

  export type ClientStaffAssignmentCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<ClientStaffAssignmentCreateWithoutClientEntityInput, ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput> | ClientStaffAssignmentCreateWithoutClientEntityInput[] | ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput | ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput[]
    createMany?: ClientStaffAssignmentCreateManyClientEntityInputEnvelope
    connect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
  }

  export type EntityTaxYearUncheckedCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<EntityTaxYearCreateWithoutClientEntityInput, EntityTaxYearUncheckedCreateWithoutClientEntityInput> | EntityTaxYearCreateWithoutClientEntityInput[] | EntityTaxYearUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutClientEntityInput | EntityTaxYearCreateOrConnectWithoutClientEntityInput[]
    createMany?: EntityTaxYearCreateManyClientEntityInputEnvelope
    connect?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<FolderCreateWithoutClientEntityInput, FolderUncheckedCreateWithoutClientEntityInput> | FolderCreateWithoutClientEntityInput[] | FolderUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutClientEntityInput | FolderCreateOrConnectWithoutClientEntityInput[]
    createMany?: FolderCreateManyClientEntityInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<DocumentCreateWithoutClientEntityInput, DocumentUncheckedCreateWithoutClientEntityInput> | DocumentCreateWithoutClientEntityInput[] | DocumentUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientEntityInput | DocumentCreateOrConnectWithoutClientEntityInput[]
    createMany?: DocumentCreateManyClientEntityInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type ClientAclUncheckedCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<ClientAclCreateWithoutClientEntityInput, ClientAclUncheckedCreateWithoutClientEntityInput> | ClientAclCreateWithoutClientEntityInput[] | ClientAclUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientAclCreateOrConnectWithoutClientEntityInput | ClientAclCreateOrConnectWithoutClientEntityInput[]
    createMany?: ClientAclCreateManyClientEntityInputEnvelope
    connect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
  }

  export type ClientStaffPermissionUncheckedCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<ClientStaffPermissionCreateWithoutClientEntityInput, ClientStaffPermissionUncheckedCreateWithoutClientEntityInput> | ClientStaffPermissionCreateWithoutClientEntityInput[] | ClientStaffPermissionUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientStaffPermissionCreateOrConnectWithoutClientEntityInput | ClientStaffPermissionCreateOrConnectWithoutClientEntityInput[]
    createMany?: ClientStaffPermissionCreateManyClientEntityInputEnvelope
    connect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
  }

  export type ClientStaffAssignmentUncheckedCreateNestedManyWithoutClientEntityInput = {
    create?: XOR<ClientStaffAssignmentCreateWithoutClientEntityInput, ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput> | ClientStaffAssignmentCreateWithoutClientEntityInput[] | ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput | ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput[]
    createMany?: ClientStaffAssignmentCreateManyClientEntityInputEnvelope
    connect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
  }

  export type EnumEntityTypeFieldUpdateOperationsInput = {
    set?: $Enums.EntityType
  }

  export type AccountUpdateOneRequiredWithoutEntitiesNestedInput = {
    create?: XOR<AccountCreateWithoutEntitiesInput, AccountUncheckedCreateWithoutEntitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutEntitiesInput
    upsert?: AccountUpsertWithoutEntitiesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutEntitiesInput, AccountUpdateWithoutEntitiesInput>, AccountUncheckedUpdateWithoutEntitiesInput>
  }

  export type EntityTaxYearUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutClientEntityInput, EntityTaxYearUncheckedCreateWithoutClientEntityInput> | EntityTaxYearCreateWithoutClientEntityInput[] | EntityTaxYearUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutClientEntityInput | EntityTaxYearCreateOrConnectWithoutClientEntityInput[]
    upsert?: EntityTaxYearUpsertWithWhereUniqueWithoutClientEntityInput | EntityTaxYearUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: EntityTaxYearCreateManyClientEntityInputEnvelope
    set?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
    disconnect?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
    delete?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
    connect?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
    update?: EntityTaxYearUpdateWithWhereUniqueWithoutClientEntityInput | EntityTaxYearUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: EntityTaxYearUpdateManyWithWhereWithoutClientEntityInput | EntityTaxYearUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: EntityTaxYearScalarWhereInput | EntityTaxYearScalarWhereInput[]
  }

  export type FolderUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<FolderCreateWithoutClientEntityInput, FolderUncheckedCreateWithoutClientEntityInput> | FolderCreateWithoutClientEntityInput[] | FolderUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutClientEntityInput | FolderCreateOrConnectWithoutClientEntityInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutClientEntityInput | FolderUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: FolderCreateManyClientEntityInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutClientEntityInput | FolderUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutClientEntityInput | FolderUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<DocumentCreateWithoutClientEntityInput, DocumentUncheckedCreateWithoutClientEntityInput> | DocumentCreateWithoutClientEntityInput[] | DocumentUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientEntityInput | DocumentCreateOrConnectWithoutClientEntityInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientEntityInput | DocumentUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: DocumentCreateManyClientEntityInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientEntityInput | DocumentUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientEntityInput | DocumentUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClientAclUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<ClientAclCreateWithoutClientEntityInput, ClientAclUncheckedCreateWithoutClientEntityInput> | ClientAclCreateWithoutClientEntityInput[] | ClientAclUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientAclCreateOrConnectWithoutClientEntityInput | ClientAclCreateOrConnectWithoutClientEntityInput[]
    upsert?: ClientAclUpsertWithWhereUniqueWithoutClientEntityInput | ClientAclUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: ClientAclCreateManyClientEntityInputEnvelope
    set?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    disconnect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    delete?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    connect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    update?: ClientAclUpdateWithWhereUniqueWithoutClientEntityInput | ClientAclUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: ClientAclUpdateManyWithWhereWithoutClientEntityInput | ClientAclUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: ClientAclScalarWhereInput | ClientAclScalarWhereInput[]
  }

  export type ClientStaffPermissionUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<ClientStaffPermissionCreateWithoutClientEntityInput, ClientStaffPermissionUncheckedCreateWithoutClientEntityInput> | ClientStaffPermissionCreateWithoutClientEntityInput[] | ClientStaffPermissionUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientStaffPermissionCreateOrConnectWithoutClientEntityInput | ClientStaffPermissionCreateOrConnectWithoutClientEntityInput[]
    upsert?: ClientStaffPermissionUpsertWithWhereUniqueWithoutClientEntityInput | ClientStaffPermissionUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: ClientStaffPermissionCreateManyClientEntityInputEnvelope
    set?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    disconnect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    delete?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    connect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    update?: ClientStaffPermissionUpdateWithWhereUniqueWithoutClientEntityInput | ClientStaffPermissionUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: ClientStaffPermissionUpdateManyWithWhereWithoutClientEntityInput | ClientStaffPermissionUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: ClientStaffPermissionScalarWhereInput | ClientStaffPermissionScalarWhereInput[]
  }

  export type ClientStaffAssignmentUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<ClientStaffAssignmentCreateWithoutClientEntityInput, ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput> | ClientStaffAssignmentCreateWithoutClientEntityInput[] | ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput | ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput[]
    upsert?: ClientStaffAssignmentUpsertWithWhereUniqueWithoutClientEntityInput | ClientStaffAssignmentUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: ClientStaffAssignmentCreateManyClientEntityInputEnvelope
    set?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    disconnect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    delete?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    connect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    update?: ClientStaffAssignmentUpdateWithWhereUniqueWithoutClientEntityInput | ClientStaffAssignmentUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: ClientStaffAssignmentUpdateManyWithWhereWithoutClientEntityInput | ClientStaffAssignmentUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: ClientStaffAssignmentScalarWhereInput | ClientStaffAssignmentScalarWhereInput[]
  }

  export type EntityTaxYearUncheckedUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutClientEntityInput, EntityTaxYearUncheckedCreateWithoutClientEntityInput> | EntityTaxYearCreateWithoutClientEntityInput[] | EntityTaxYearUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutClientEntityInput | EntityTaxYearCreateOrConnectWithoutClientEntityInput[]
    upsert?: EntityTaxYearUpsertWithWhereUniqueWithoutClientEntityInput | EntityTaxYearUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: EntityTaxYearCreateManyClientEntityInputEnvelope
    set?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
    disconnect?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
    delete?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
    connect?: EntityTaxYearWhereUniqueInput | EntityTaxYearWhereUniqueInput[]
    update?: EntityTaxYearUpdateWithWhereUniqueWithoutClientEntityInput | EntityTaxYearUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: EntityTaxYearUpdateManyWithWhereWithoutClientEntityInput | EntityTaxYearUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: EntityTaxYearScalarWhereInput | EntityTaxYearScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<FolderCreateWithoutClientEntityInput, FolderUncheckedCreateWithoutClientEntityInput> | FolderCreateWithoutClientEntityInput[] | FolderUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutClientEntityInput | FolderCreateOrConnectWithoutClientEntityInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutClientEntityInput | FolderUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: FolderCreateManyClientEntityInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutClientEntityInput | FolderUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutClientEntityInput | FolderUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<DocumentCreateWithoutClientEntityInput, DocumentUncheckedCreateWithoutClientEntityInput> | DocumentCreateWithoutClientEntityInput[] | DocumentUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutClientEntityInput | DocumentCreateOrConnectWithoutClientEntityInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutClientEntityInput | DocumentUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: DocumentCreateManyClientEntityInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutClientEntityInput | DocumentUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutClientEntityInput | DocumentUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type ClientAclUncheckedUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<ClientAclCreateWithoutClientEntityInput, ClientAclUncheckedCreateWithoutClientEntityInput> | ClientAclCreateWithoutClientEntityInput[] | ClientAclUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientAclCreateOrConnectWithoutClientEntityInput | ClientAclCreateOrConnectWithoutClientEntityInput[]
    upsert?: ClientAclUpsertWithWhereUniqueWithoutClientEntityInput | ClientAclUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: ClientAclCreateManyClientEntityInputEnvelope
    set?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    disconnect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    delete?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    connect?: ClientAclWhereUniqueInput | ClientAclWhereUniqueInput[]
    update?: ClientAclUpdateWithWhereUniqueWithoutClientEntityInput | ClientAclUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: ClientAclUpdateManyWithWhereWithoutClientEntityInput | ClientAclUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: ClientAclScalarWhereInput | ClientAclScalarWhereInput[]
  }

  export type ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<ClientStaffPermissionCreateWithoutClientEntityInput, ClientStaffPermissionUncheckedCreateWithoutClientEntityInput> | ClientStaffPermissionCreateWithoutClientEntityInput[] | ClientStaffPermissionUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientStaffPermissionCreateOrConnectWithoutClientEntityInput | ClientStaffPermissionCreateOrConnectWithoutClientEntityInput[]
    upsert?: ClientStaffPermissionUpsertWithWhereUniqueWithoutClientEntityInput | ClientStaffPermissionUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: ClientStaffPermissionCreateManyClientEntityInputEnvelope
    set?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    disconnect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    delete?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    connect?: ClientStaffPermissionWhereUniqueInput | ClientStaffPermissionWhereUniqueInput[]
    update?: ClientStaffPermissionUpdateWithWhereUniqueWithoutClientEntityInput | ClientStaffPermissionUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: ClientStaffPermissionUpdateManyWithWhereWithoutClientEntityInput | ClientStaffPermissionUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: ClientStaffPermissionScalarWhereInput | ClientStaffPermissionScalarWhereInput[]
  }

  export type ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityNestedInput = {
    create?: XOR<ClientStaffAssignmentCreateWithoutClientEntityInput, ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput> | ClientStaffAssignmentCreateWithoutClientEntityInput[] | ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput[]
    connectOrCreate?: ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput | ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput[]
    upsert?: ClientStaffAssignmentUpsertWithWhereUniqueWithoutClientEntityInput | ClientStaffAssignmentUpsertWithWhereUniqueWithoutClientEntityInput[]
    createMany?: ClientStaffAssignmentCreateManyClientEntityInputEnvelope
    set?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    disconnect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    delete?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    connect?: ClientStaffAssignmentWhereUniqueInput | ClientStaffAssignmentWhereUniqueInput[]
    update?: ClientStaffAssignmentUpdateWithWhereUniqueWithoutClientEntityInput | ClientStaffAssignmentUpdateWithWhereUniqueWithoutClientEntityInput[]
    updateMany?: ClientStaffAssignmentUpdateManyWithWhereWithoutClientEntityInput | ClientStaffAssignmentUpdateManyWithWhereWithoutClientEntityInput[]
    deleteMany?: ClientStaffAssignmentScalarWhereInput | ClientStaffAssignmentScalarWhereInput[]
  }

  export type ClientEntityCreateNestedOneWithoutEntityTaxYearsInput = {
    create?: XOR<ClientEntityCreateWithoutEntityTaxYearsInput, ClientEntityUncheckedCreateWithoutEntityTaxYearsInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutEntityTaxYearsInput
    connect?: ClientEntityWhereUniqueInput
  }

  export type ChecklistItemCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<ChecklistItemCreateWithoutEntityTaxYearInput, ChecklistItemUncheckedCreateWithoutEntityTaxYearInput> | ChecklistItemCreateWithoutEntityTaxYearInput[] | ChecklistItemUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutEntityTaxYearInput | ChecklistItemCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: ChecklistItemCreateManyEntityTaxYearInputEnvelope
    connect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
  }

  export type QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<QuestionnaireAnswerCreateWithoutEntityTaxYearInput, QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput> | QuestionnaireAnswerCreateWithoutEntityTaxYearInput[] | QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput | QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: QuestionnaireAnswerCreateManyEntityTaxYearInputEnvelope
    connect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
  }

  export type MessageThreadCreateNestedOneWithoutEntityTaxYearInput = {
    create?: XOR<MessageThreadCreateWithoutEntityTaxYearInput, MessageThreadUncheckedCreateWithoutEntityTaxYearInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutEntityTaxYearInput
    connect?: MessageThreadWhereUniqueInput
  }

  export type ReminderStateCreateNestedOneWithoutEntityTaxYearInput = {
    create?: XOR<ReminderStateCreateWithoutEntityTaxYearInput, ReminderStateUncheckedCreateWithoutEntityTaxYearInput>
    connectOrCreate?: ReminderStateCreateOrConnectWithoutEntityTaxYearInput
    connect?: ReminderStateWhereUniqueInput
  }

  export type StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<StatusAuditLogCreateWithoutEntityTaxYearInput, StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput> | StatusAuditLogCreateWithoutEntityTaxYearInput[] | StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput | StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: StatusAuditLogCreateManyEntityTaxYearInputEnvelope
    connect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
  }

  export type DocumentEventCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<DocumentEventCreateWithoutEntityTaxYearInput, DocumentEventUncheckedCreateWithoutEntityTaxYearInput> | DocumentEventCreateWithoutEntityTaxYearInput[] | DocumentEventUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: DocumentEventCreateOrConnectWithoutEntityTaxYearInput | DocumentEventCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: DocumentEventCreateManyEntityTaxYearInputEnvelope
    connect?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
  }

  export type EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<EngagementSignatureCreateWithoutEntityTaxYearInput, EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput> | EngagementSignatureCreateWithoutEntityTaxYearInput[] | EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput | EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: EngagementSignatureCreateManyEntityTaxYearInputEnvelope
    connect?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
  }

  export type EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<EfileAuthorizationCreateWithoutEntityTaxYearInput, EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput> | EfileAuthorizationCreateWithoutEntityTaxYearInput[] | EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput | EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: EfileAuthorizationCreateManyEntityTaxYearInputEnvelope
    connect?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
  }

  export type ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<ChecklistItemCreateWithoutEntityTaxYearInput, ChecklistItemUncheckedCreateWithoutEntityTaxYearInput> | ChecklistItemCreateWithoutEntityTaxYearInput[] | ChecklistItemUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutEntityTaxYearInput | ChecklistItemCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: ChecklistItemCreateManyEntityTaxYearInputEnvelope
    connect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
  }

  export type QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<QuestionnaireAnswerCreateWithoutEntityTaxYearInput, QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput> | QuestionnaireAnswerCreateWithoutEntityTaxYearInput[] | QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput | QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: QuestionnaireAnswerCreateManyEntityTaxYearInputEnvelope
    connect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
  }

  export type MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput = {
    create?: XOR<MessageThreadCreateWithoutEntityTaxYearInput, MessageThreadUncheckedCreateWithoutEntityTaxYearInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutEntityTaxYearInput
    connect?: MessageThreadWhereUniqueInput
  }

  export type ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput = {
    create?: XOR<ReminderStateCreateWithoutEntityTaxYearInput, ReminderStateUncheckedCreateWithoutEntityTaxYearInput>
    connectOrCreate?: ReminderStateCreateOrConnectWithoutEntityTaxYearInput
    connect?: ReminderStateWhereUniqueInput
  }

  export type StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<StatusAuditLogCreateWithoutEntityTaxYearInput, StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput> | StatusAuditLogCreateWithoutEntityTaxYearInput[] | StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput | StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: StatusAuditLogCreateManyEntityTaxYearInputEnvelope
    connect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
  }

  export type DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<DocumentEventCreateWithoutEntityTaxYearInput, DocumentEventUncheckedCreateWithoutEntityTaxYearInput> | DocumentEventCreateWithoutEntityTaxYearInput[] | DocumentEventUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: DocumentEventCreateOrConnectWithoutEntityTaxYearInput | DocumentEventCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: DocumentEventCreateManyEntityTaxYearInputEnvelope
    connect?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
  }

  export type EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<EngagementSignatureCreateWithoutEntityTaxYearInput, EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput> | EngagementSignatureCreateWithoutEntityTaxYearInput[] | EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput | EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: EngagementSignatureCreateManyEntityTaxYearInputEnvelope
    connect?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
  }

  export type EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput = {
    create?: XOR<EfileAuthorizationCreateWithoutEntityTaxYearInput, EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput> | EfileAuthorizationCreateWithoutEntityTaxYearInput[] | EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput | EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput[]
    createMany?: EfileAuthorizationCreateManyEntityTaxYearInputEnvelope
    connect?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumInviteStatusFieldUpdateOperationsInput = {
    set?: $Enums.InviteStatus
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumEngagementStatusFieldUpdateOperationsInput = {
    set?: $Enums.EngagementStatus
  }

  export type EnumConfirmationStatusFieldUpdateOperationsInput = {
    set?: $Enums.ConfirmationStatus
  }

  export type EnumQuestionnaireStatusFieldUpdateOperationsInput = {
    set?: $Enums.QuestionnaireStatus
  }

  export type EnumIdStatusFieldUpdateOperationsInput = {
    set?: $Enums.IdStatus
  }

  export type EnumInternalStatusFieldUpdateOperationsInput = {
    set?: $Enums.InternalStatus
  }

  export type ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput = {
    create?: XOR<ClientEntityCreateWithoutEntityTaxYearsInput, ClientEntityUncheckedCreateWithoutEntityTaxYearsInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutEntityTaxYearsInput
    upsert?: ClientEntityUpsertWithoutEntityTaxYearsInput
    connect?: ClientEntityWhereUniqueInput
    update?: XOR<XOR<ClientEntityUpdateToOneWithWhereWithoutEntityTaxYearsInput, ClientEntityUpdateWithoutEntityTaxYearsInput>, ClientEntityUncheckedUpdateWithoutEntityTaxYearsInput>
  }

  export type ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<ChecklistItemCreateWithoutEntityTaxYearInput, ChecklistItemUncheckedCreateWithoutEntityTaxYearInput> | ChecklistItemCreateWithoutEntityTaxYearInput[] | ChecklistItemUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutEntityTaxYearInput | ChecklistItemCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: ChecklistItemUpsertWithWhereUniqueWithoutEntityTaxYearInput | ChecklistItemUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: ChecklistItemCreateManyEntityTaxYearInputEnvelope
    set?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    disconnect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    delete?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    connect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    update?: ChecklistItemUpdateWithWhereUniqueWithoutEntityTaxYearInput | ChecklistItemUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: ChecklistItemUpdateManyWithWhereWithoutEntityTaxYearInput | ChecklistItemUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: ChecklistItemScalarWhereInput | ChecklistItemScalarWhereInput[]
  }

  export type QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<QuestionnaireAnswerCreateWithoutEntityTaxYearInput, QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput> | QuestionnaireAnswerCreateWithoutEntityTaxYearInput[] | QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput | QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: QuestionnaireAnswerUpsertWithWhereUniqueWithoutEntityTaxYearInput | QuestionnaireAnswerUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: QuestionnaireAnswerCreateManyEntityTaxYearInputEnvelope
    set?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    disconnect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    delete?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    connect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    update?: QuestionnaireAnswerUpdateWithWhereUniqueWithoutEntityTaxYearInput | QuestionnaireAnswerUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: QuestionnaireAnswerUpdateManyWithWhereWithoutEntityTaxYearInput | QuestionnaireAnswerUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: QuestionnaireAnswerScalarWhereInput | QuestionnaireAnswerScalarWhereInput[]
  }

  export type MessageThreadUpdateOneWithoutEntityTaxYearNestedInput = {
    create?: XOR<MessageThreadCreateWithoutEntityTaxYearInput, MessageThreadUncheckedCreateWithoutEntityTaxYearInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutEntityTaxYearInput
    upsert?: MessageThreadUpsertWithoutEntityTaxYearInput
    disconnect?: MessageThreadWhereInput | boolean
    delete?: MessageThreadWhereInput | boolean
    connect?: MessageThreadWhereUniqueInput
    update?: XOR<XOR<MessageThreadUpdateToOneWithWhereWithoutEntityTaxYearInput, MessageThreadUpdateWithoutEntityTaxYearInput>, MessageThreadUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type ReminderStateUpdateOneWithoutEntityTaxYearNestedInput = {
    create?: XOR<ReminderStateCreateWithoutEntityTaxYearInput, ReminderStateUncheckedCreateWithoutEntityTaxYearInput>
    connectOrCreate?: ReminderStateCreateOrConnectWithoutEntityTaxYearInput
    upsert?: ReminderStateUpsertWithoutEntityTaxYearInput
    disconnect?: ReminderStateWhereInput | boolean
    delete?: ReminderStateWhereInput | boolean
    connect?: ReminderStateWhereUniqueInput
    update?: XOR<XOR<ReminderStateUpdateToOneWithWhereWithoutEntityTaxYearInput, ReminderStateUpdateWithoutEntityTaxYearInput>, ReminderStateUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<StatusAuditLogCreateWithoutEntityTaxYearInput, StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput> | StatusAuditLogCreateWithoutEntityTaxYearInput[] | StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput | StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: StatusAuditLogUpsertWithWhereUniqueWithoutEntityTaxYearInput | StatusAuditLogUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: StatusAuditLogCreateManyEntityTaxYearInputEnvelope
    set?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    disconnect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    delete?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    connect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    update?: StatusAuditLogUpdateWithWhereUniqueWithoutEntityTaxYearInput | StatusAuditLogUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: StatusAuditLogUpdateManyWithWhereWithoutEntityTaxYearInput | StatusAuditLogUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: StatusAuditLogScalarWhereInput | StatusAuditLogScalarWhereInput[]
  }

  export type DocumentEventUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<DocumentEventCreateWithoutEntityTaxYearInput, DocumentEventUncheckedCreateWithoutEntityTaxYearInput> | DocumentEventCreateWithoutEntityTaxYearInput[] | DocumentEventUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: DocumentEventCreateOrConnectWithoutEntityTaxYearInput | DocumentEventCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: DocumentEventUpsertWithWhereUniqueWithoutEntityTaxYearInput | DocumentEventUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: DocumentEventCreateManyEntityTaxYearInputEnvelope
    set?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
    disconnect?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
    delete?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
    connect?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
    update?: DocumentEventUpdateWithWhereUniqueWithoutEntityTaxYearInput | DocumentEventUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: DocumentEventUpdateManyWithWhereWithoutEntityTaxYearInput | DocumentEventUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: DocumentEventScalarWhereInput | DocumentEventScalarWhereInput[]
  }

  export type EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<EngagementSignatureCreateWithoutEntityTaxYearInput, EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput> | EngagementSignatureCreateWithoutEntityTaxYearInput[] | EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput | EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: EngagementSignatureUpsertWithWhereUniqueWithoutEntityTaxYearInput | EngagementSignatureUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: EngagementSignatureCreateManyEntityTaxYearInputEnvelope
    set?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
    disconnect?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
    delete?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
    connect?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
    update?: EngagementSignatureUpdateWithWhereUniqueWithoutEntityTaxYearInput | EngagementSignatureUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: EngagementSignatureUpdateManyWithWhereWithoutEntityTaxYearInput | EngagementSignatureUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: EngagementSignatureScalarWhereInput | EngagementSignatureScalarWhereInput[]
  }

  export type EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<EfileAuthorizationCreateWithoutEntityTaxYearInput, EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput> | EfileAuthorizationCreateWithoutEntityTaxYearInput[] | EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput | EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: EfileAuthorizationUpsertWithWhereUniqueWithoutEntityTaxYearInput | EfileAuthorizationUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: EfileAuthorizationCreateManyEntityTaxYearInputEnvelope
    set?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
    disconnect?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
    delete?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
    connect?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
    update?: EfileAuthorizationUpdateWithWhereUniqueWithoutEntityTaxYearInput | EfileAuthorizationUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: EfileAuthorizationUpdateManyWithWhereWithoutEntityTaxYearInput | EfileAuthorizationUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: EfileAuthorizationScalarWhereInput | EfileAuthorizationScalarWhereInput[]
  }

  export type ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<ChecklistItemCreateWithoutEntityTaxYearInput, ChecklistItemUncheckedCreateWithoutEntityTaxYearInput> | ChecklistItemCreateWithoutEntityTaxYearInput[] | ChecklistItemUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutEntityTaxYearInput | ChecklistItemCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: ChecklistItemUpsertWithWhereUniqueWithoutEntityTaxYearInput | ChecklistItemUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: ChecklistItemCreateManyEntityTaxYearInputEnvelope
    set?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    disconnect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    delete?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    connect?: ChecklistItemWhereUniqueInput | ChecklistItemWhereUniqueInput[]
    update?: ChecklistItemUpdateWithWhereUniqueWithoutEntityTaxYearInput | ChecklistItemUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: ChecklistItemUpdateManyWithWhereWithoutEntityTaxYearInput | ChecklistItemUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: ChecklistItemScalarWhereInput | ChecklistItemScalarWhereInput[]
  }

  export type QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<QuestionnaireAnswerCreateWithoutEntityTaxYearInput, QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput> | QuestionnaireAnswerCreateWithoutEntityTaxYearInput[] | QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput | QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: QuestionnaireAnswerUpsertWithWhereUniqueWithoutEntityTaxYearInput | QuestionnaireAnswerUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: QuestionnaireAnswerCreateManyEntityTaxYearInputEnvelope
    set?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    disconnect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    delete?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    connect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    update?: QuestionnaireAnswerUpdateWithWhereUniqueWithoutEntityTaxYearInput | QuestionnaireAnswerUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: QuestionnaireAnswerUpdateManyWithWhereWithoutEntityTaxYearInput | QuestionnaireAnswerUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: QuestionnaireAnswerScalarWhereInput | QuestionnaireAnswerScalarWhereInput[]
  }

  export type MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput = {
    create?: XOR<MessageThreadCreateWithoutEntityTaxYearInput, MessageThreadUncheckedCreateWithoutEntityTaxYearInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutEntityTaxYearInput
    upsert?: MessageThreadUpsertWithoutEntityTaxYearInput
    disconnect?: MessageThreadWhereInput | boolean
    delete?: MessageThreadWhereInput | boolean
    connect?: MessageThreadWhereUniqueInput
    update?: XOR<XOR<MessageThreadUpdateToOneWithWhereWithoutEntityTaxYearInput, MessageThreadUpdateWithoutEntityTaxYearInput>, MessageThreadUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput = {
    create?: XOR<ReminderStateCreateWithoutEntityTaxYearInput, ReminderStateUncheckedCreateWithoutEntityTaxYearInput>
    connectOrCreate?: ReminderStateCreateOrConnectWithoutEntityTaxYearInput
    upsert?: ReminderStateUpsertWithoutEntityTaxYearInput
    disconnect?: ReminderStateWhereInput | boolean
    delete?: ReminderStateWhereInput | boolean
    connect?: ReminderStateWhereUniqueInput
    update?: XOR<XOR<ReminderStateUpdateToOneWithWhereWithoutEntityTaxYearInput, ReminderStateUpdateWithoutEntityTaxYearInput>, ReminderStateUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<StatusAuditLogCreateWithoutEntityTaxYearInput, StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput> | StatusAuditLogCreateWithoutEntityTaxYearInput[] | StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput | StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: StatusAuditLogUpsertWithWhereUniqueWithoutEntityTaxYearInput | StatusAuditLogUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: StatusAuditLogCreateManyEntityTaxYearInputEnvelope
    set?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    disconnect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    delete?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    connect?: StatusAuditLogWhereUniqueInput | StatusAuditLogWhereUniqueInput[]
    update?: StatusAuditLogUpdateWithWhereUniqueWithoutEntityTaxYearInput | StatusAuditLogUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: StatusAuditLogUpdateManyWithWhereWithoutEntityTaxYearInput | StatusAuditLogUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: StatusAuditLogScalarWhereInput | StatusAuditLogScalarWhereInput[]
  }

  export type DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<DocumentEventCreateWithoutEntityTaxYearInput, DocumentEventUncheckedCreateWithoutEntityTaxYearInput> | DocumentEventCreateWithoutEntityTaxYearInput[] | DocumentEventUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: DocumentEventCreateOrConnectWithoutEntityTaxYearInput | DocumentEventCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: DocumentEventUpsertWithWhereUniqueWithoutEntityTaxYearInput | DocumentEventUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: DocumentEventCreateManyEntityTaxYearInputEnvelope
    set?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
    disconnect?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
    delete?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
    connect?: DocumentEventWhereUniqueInput | DocumentEventWhereUniqueInput[]
    update?: DocumentEventUpdateWithWhereUniqueWithoutEntityTaxYearInput | DocumentEventUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: DocumentEventUpdateManyWithWhereWithoutEntityTaxYearInput | DocumentEventUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: DocumentEventScalarWhereInput | DocumentEventScalarWhereInput[]
  }

  export type EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<EngagementSignatureCreateWithoutEntityTaxYearInput, EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput> | EngagementSignatureCreateWithoutEntityTaxYearInput[] | EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput | EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: EngagementSignatureUpsertWithWhereUniqueWithoutEntityTaxYearInput | EngagementSignatureUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: EngagementSignatureCreateManyEntityTaxYearInputEnvelope
    set?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
    disconnect?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
    delete?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
    connect?: EngagementSignatureWhereUniqueInput | EngagementSignatureWhereUniqueInput[]
    update?: EngagementSignatureUpdateWithWhereUniqueWithoutEntityTaxYearInput | EngagementSignatureUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: EngagementSignatureUpdateManyWithWhereWithoutEntityTaxYearInput | EngagementSignatureUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: EngagementSignatureScalarWhereInput | EngagementSignatureScalarWhereInput[]
  }

  export type EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput = {
    create?: XOR<EfileAuthorizationCreateWithoutEntityTaxYearInput, EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput> | EfileAuthorizationCreateWithoutEntityTaxYearInput[] | EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput[]
    connectOrCreate?: EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput | EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput[]
    upsert?: EfileAuthorizationUpsertWithWhereUniqueWithoutEntityTaxYearInput | EfileAuthorizationUpsertWithWhereUniqueWithoutEntityTaxYearInput[]
    createMany?: EfileAuthorizationCreateManyEntityTaxYearInputEnvelope
    set?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
    disconnect?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
    delete?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
    connect?: EfileAuthorizationWhereUniqueInput | EfileAuthorizationWhereUniqueInput[]
    update?: EfileAuthorizationUpdateWithWhereUniqueWithoutEntityTaxYearInput | EfileAuthorizationUpdateWithWhereUniqueWithoutEntityTaxYearInput[]
    updateMany?: EfileAuthorizationUpdateManyWithWhereWithoutEntityTaxYearInput | EfileAuthorizationUpdateManyWithWhereWithoutEntityTaxYearInput[]
    deleteMany?: EfileAuthorizationScalarWhereInput | EfileAuthorizationScalarWhereInput[]
  }

  export type ClientEntityCreateNestedOneWithoutClientAclInput = {
    create?: XOR<ClientEntityCreateWithoutClientAclInput, ClientEntityUncheckedCreateWithoutClientAclInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutClientAclInput
    connect?: ClientEntityWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutClientAclInput = {
    create?: XOR<StaffProfileCreateWithoutClientAclInput, StaffProfileUncheckedCreateWithoutClientAclInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutClientAclInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type ClientEntityUpdateOneRequiredWithoutClientAclNestedInput = {
    create?: XOR<ClientEntityCreateWithoutClientAclInput, ClientEntityUncheckedCreateWithoutClientAclInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutClientAclInput
    upsert?: ClientEntityUpsertWithoutClientAclInput
    connect?: ClientEntityWhereUniqueInput
    update?: XOR<XOR<ClientEntityUpdateToOneWithWhereWithoutClientAclInput, ClientEntityUpdateWithoutClientAclInput>, ClientEntityUncheckedUpdateWithoutClientAclInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutClientAclNestedInput = {
    create?: XOR<StaffProfileCreateWithoutClientAclInput, StaffProfileUncheckedCreateWithoutClientAclInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutClientAclInput
    upsert?: StaffProfileUpsertWithoutClientAclInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutClientAclInput, StaffProfileUpdateWithoutClientAclInput>, StaffProfileUncheckedUpdateWithoutClientAclInput>
  }

  export type ClientEntityCreateNestedOneWithoutClientStaffPermissionsInput = {
    create?: XOR<ClientEntityCreateWithoutClientStaffPermissionsInput, ClientEntityUncheckedCreateWithoutClientStaffPermissionsInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutClientStaffPermissionsInput
    connect?: ClientEntityWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutClientStaffPermissionsInput = {
    create?: XOR<StaffProfileCreateWithoutClientStaffPermissionsInput, StaffProfileUncheckedCreateWithoutClientStaffPermissionsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutClientStaffPermissionsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type ClientEntityUpdateOneRequiredWithoutClientStaffPermissionsNestedInput = {
    create?: XOR<ClientEntityCreateWithoutClientStaffPermissionsInput, ClientEntityUncheckedCreateWithoutClientStaffPermissionsInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutClientStaffPermissionsInput
    upsert?: ClientEntityUpsertWithoutClientStaffPermissionsInput
    connect?: ClientEntityWhereUniqueInput
    update?: XOR<XOR<ClientEntityUpdateToOneWithWhereWithoutClientStaffPermissionsInput, ClientEntityUpdateWithoutClientStaffPermissionsInput>, ClientEntityUncheckedUpdateWithoutClientStaffPermissionsInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutClientStaffPermissionsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutClientStaffPermissionsInput, StaffProfileUncheckedCreateWithoutClientStaffPermissionsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutClientStaffPermissionsInput
    upsert?: StaffProfileUpsertWithoutClientStaffPermissionsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutClientStaffPermissionsInput, StaffProfileUpdateWithoutClientStaffPermissionsInput>, StaffProfileUncheckedUpdateWithoutClientStaffPermissionsInput>
  }

  export type ClientEntityCreateNestedOneWithoutClientStaffAssignmentsInput = {
    create?: XOR<ClientEntityCreateWithoutClientStaffAssignmentsInput, ClientEntityUncheckedCreateWithoutClientStaffAssignmentsInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutClientStaffAssignmentsInput
    connect?: ClientEntityWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutClientStaffAssignmentsInput = {
    create?: XOR<StaffProfileCreateWithoutClientStaffAssignmentsInput, StaffProfileUncheckedCreateWithoutClientStaffAssignmentsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutClientStaffAssignmentsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type ClientEntityUpdateOneRequiredWithoutClientStaffAssignmentsNestedInput = {
    create?: XOR<ClientEntityCreateWithoutClientStaffAssignmentsInput, ClientEntityUncheckedCreateWithoutClientStaffAssignmentsInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutClientStaffAssignmentsInput
    upsert?: ClientEntityUpsertWithoutClientStaffAssignmentsInput
    connect?: ClientEntityWhereUniqueInput
    update?: XOR<XOR<ClientEntityUpdateToOneWithWhereWithoutClientStaffAssignmentsInput, ClientEntityUpdateWithoutClientStaffAssignmentsInput>, ClientEntityUncheckedUpdateWithoutClientStaffAssignmentsInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutClientStaffAssignmentsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutClientStaffAssignmentsInput, StaffProfileUncheckedCreateWithoutClientStaffAssignmentsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutClientStaffAssignmentsInput
    upsert?: StaffProfileUpsertWithoutClientStaffAssignmentsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutClientStaffAssignmentsInput, StaffProfileUpdateWithoutClientStaffAssignmentsInput>, StaffProfileUncheckedUpdateWithoutClientStaffAssignmentsInput>
  }

  export type ClientEntityCreateNestedOneWithoutFoldersInput = {
    create?: XOR<ClientEntityCreateWithoutFoldersInput, ClientEntityUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutFoldersInput
    connect?: ClientEntityWhereUniqueInput
  }

  export type FolderCreateNestedOneWithoutChildrenInput = {
    create?: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FolderCreateOrConnectWithoutChildrenInput
    connect?: FolderWhereUniqueInput
  }

  export type FolderCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type DocumentCreateNestedManyWithoutFolderInput = {
    create?: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput> | DocumentCreateWithoutFolderInput[] | DocumentUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutFolderInput | DocumentCreateOrConnectWithoutFolderInput[]
    createMany?: DocumentCreateManyFolderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type FolderAclCreateNestedManyWithoutFolderInput = {
    create?: XOR<FolderAclCreateWithoutFolderInput, FolderAclUncheckedCreateWithoutFolderInput> | FolderAclCreateWithoutFolderInput[] | FolderAclUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderAclCreateOrConnectWithoutFolderInput | FolderAclCreateOrConnectWithoutFolderInput[]
    createMany?: FolderAclCreateManyFolderInputEnvelope
    connect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
  }

  export type FolderUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
  }

  export type DocumentUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput> | DocumentCreateWithoutFolderInput[] | DocumentUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutFolderInput | DocumentCreateOrConnectWithoutFolderInput[]
    createMany?: DocumentCreateManyFolderInputEnvelope
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
  }

  export type FolderAclUncheckedCreateNestedManyWithoutFolderInput = {
    create?: XOR<FolderAclCreateWithoutFolderInput, FolderAclUncheckedCreateWithoutFolderInput> | FolderAclCreateWithoutFolderInput[] | FolderAclUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderAclCreateOrConnectWithoutFolderInput | FolderAclCreateOrConnectWithoutFolderInput[]
    createMany?: FolderAclCreateManyFolderInputEnvelope
    connect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
  }

  export type ClientEntityUpdateOneRequiredWithoutFoldersNestedInput = {
    create?: XOR<ClientEntityCreateWithoutFoldersInput, ClientEntityUncheckedCreateWithoutFoldersInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutFoldersInput
    upsert?: ClientEntityUpsertWithoutFoldersInput
    connect?: ClientEntityWhereUniqueInput
    update?: XOR<XOR<ClientEntityUpdateToOneWithWhereWithoutFoldersInput, ClientEntityUpdateWithoutFoldersInput>, ClientEntityUncheckedUpdateWithoutFoldersInput>
  }

  export type FolderUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: FolderCreateOrConnectWithoutChildrenInput
    upsert?: FolderUpsertWithoutChildrenInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutChildrenInput, FolderUpdateWithoutChildrenInput>, FolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FolderUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type DocumentUpdateManyWithoutFolderNestedInput = {
    create?: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput> | DocumentCreateWithoutFolderInput[] | DocumentUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutFolderInput | DocumentCreateOrConnectWithoutFolderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutFolderInput | DocumentUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: DocumentCreateManyFolderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutFolderInput | DocumentUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutFolderInput | DocumentUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type FolderAclUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FolderAclCreateWithoutFolderInput, FolderAclUncheckedCreateWithoutFolderInput> | FolderAclCreateWithoutFolderInput[] | FolderAclUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderAclCreateOrConnectWithoutFolderInput | FolderAclCreateOrConnectWithoutFolderInput[]
    upsert?: FolderAclUpsertWithWhereUniqueWithoutFolderInput | FolderAclUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FolderAclCreateManyFolderInputEnvelope
    set?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    disconnect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    delete?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    connect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    update?: FolderAclUpdateWithWhereUniqueWithoutFolderInput | FolderAclUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FolderAclUpdateManyWithWhereWithoutFolderInput | FolderAclUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FolderAclScalarWhereInput | FolderAclScalarWhereInput[]
  }

  export type FolderUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput> | FolderCreateWithoutParentInput[] | FolderUncheckedCreateWithoutParentInput[]
    connectOrCreate?: FolderCreateOrConnectWithoutParentInput | FolderCreateOrConnectWithoutParentInput[]
    upsert?: FolderUpsertWithWhereUniqueWithoutParentInput | FolderUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: FolderCreateManyParentInputEnvelope
    set?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    disconnect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    delete?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    connect?: FolderWhereUniqueInput | FolderWhereUniqueInput[]
    update?: FolderUpdateWithWhereUniqueWithoutParentInput | FolderUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: FolderUpdateManyWithWhereWithoutParentInput | FolderUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: FolderScalarWhereInput | FolderScalarWhereInput[]
  }

  export type DocumentUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput> | DocumentCreateWithoutFolderInput[] | DocumentUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: DocumentCreateOrConnectWithoutFolderInput | DocumentCreateOrConnectWithoutFolderInput[]
    upsert?: DocumentUpsertWithWhereUniqueWithoutFolderInput | DocumentUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: DocumentCreateManyFolderInputEnvelope
    set?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    disconnect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    delete?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    connect?: DocumentWhereUniqueInput | DocumentWhereUniqueInput[]
    update?: DocumentUpdateWithWhereUniqueWithoutFolderInput | DocumentUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: DocumentUpdateManyWithWhereWithoutFolderInput | DocumentUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
  }

  export type FolderAclUncheckedUpdateManyWithoutFolderNestedInput = {
    create?: XOR<FolderAclCreateWithoutFolderInput, FolderAclUncheckedCreateWithoutFolderInput> | FolderAclCreateWithoutFolderInput[] | FolderAclUncheckedCreateWithoutFolderInput[]
    connectOrCreate?: FolderAclCreateOrConnectWithoutFolderInput | FolderAclCreateOrConnectWithoutFolderInput[]
    upsert?: FolderAclUpsertWithWhereUniqueWithoutFolderInput | FolderAclUpsertWithWhereUniqueWithoutFolderInput[]
    createMany?: FolderAclCreateManyFolderInputEnvelope
    set?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    disconnect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    delete?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    connect?: FolderAclWhereUniqueInput | FolderAclWhereUniqueInput[]
    update?: FolderAclUpdateWithWhereUniqueWithoutFolderInput | FolderAclUpdateWithWhereUniqueWithoutFolderInput[]
    updateMany?: FolderAclUpdateManyWithWhereWithoutFolderInput | FolderAclUpdateManyWithWhereWithoutFolderInput[]
    deleteMany?: FolderAclScalarWhereInput | FolderAclScalarWhereInput[]
  }

  export type FolderCreateNestedOneWithoutFolderAclInput = {
    create?: XOR<FolderCreateWithoutFolderAclInput, FolderUncheckedCreateWithoutFolderAclInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFolderAclInput
    connect?: FolderWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutFolderAclInput = {
    create?: XOR<StaffProfileCreateWithoutFolderAclInput, StaffProfileUncheckedCreateWithoutFolderAclInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutFolderAclInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type FolderUpdateOneRequiredWithoutFolderAclNestedInput = {
    create?: XOR<FolderCreateWithoutFolderAclInput, FolderUncheckedCreateWithoutFolderAclInput>
    connectOrCreate?: FolderCreateOrConnectWithoutFolderAclInput
    upsert?: FolderUpsertWithoutFolderAclInput
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutFolderAclInput, FolderUpdateWithoutFolderAclInput>, FolderUncheckedUpdateWithoutFolderAclInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutFolderAclNestedInput = {
    create?: XOR<StaffProfileCreateWithoutFolderAclInput, StaffProfileUncheckedCreateWithoutFolderAclInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutFolderAclInput
    upsert?: StaffProfileUpsertWithoutFolderAclInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutFolderAclInput, StaffProfileUpdateWithoutFolderAclInput>, StaffProfileUncheckedUpdateWithoutFolderAclInput>
  }

  export type ClientEntityCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ClientEntityCreateWithoutDocumentsInput, ClientEntityUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutDocumentsInput
    connect?: ClientEntityWhereUniqueInput
  }

  export type FolderCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<FolderCreateWithoutDocumentsInput, FolderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: FolderCreateOrConnectWithoutDocumentsInput
    connect?: FolderWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutUploadedDocumentsInput = {
    create?: XOR<StaffProfileCreateWithoutUploadedDocumentsInput, StaffProfileUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUploadedDocumentsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type ChecklistItemFileCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ChecklistItemFileCreateWithoutDocumentInput, ChecklistItemFileUncheckedCreateWithoutDocumentInput> | ChecklistItemFileCreateWithoutDocumentInput[] | ChecklistItemFileUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ChecklistItemFileCreateOrConnectWithoutDocumentInput | ChecklistItemFileCreateOrConnectWithoutDocumentInput[]
    createMany?: ChecklistItemFileCreateManyDocumentInputEnvelope
    connect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
  }

  export type ChecklistItemFileUncheckedCreateNestedManyWithoutDocumentInput = {
    create?: XOR<ChecklistItemFileCreateWithoutDocumentInput, ChecklistItemFileUncheckedCreateWithoutDocumentInput> | ChecklistItemFileCreateWithoutDocumentInput[] | ChecklistItemFileUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ChecklistItemFileCreateOrConnectWithoutDocumentInput | ChecklistItemFileCreateOrConnectWithoutDocumentInput[]
    createMany?: ChecklistItemFileCreateManyDocumentInputEnvelope
    connect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClientEntityUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ClientEntityCreateWithoutDocumentsInput, ClientEntityUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ClientEntityCreateOrConnectWithoutDocumentsInput
    upsert?: ClientEntityUpsertWithoutDocumentsInput
    connect?: ClientEntityWhereUniqueInput
    update?: XOR<XOR<ClientEntityUpdateToOneWithWhereWithoutDocumentsInput, ClientEntityUpdateWithoutDocumentsInput>, ClientEntityUncheckedUpdateWithoutDocumentsInput>
  }

  export type FolderUpdateOneWithoutDocumentsNestedInput = {
    create?: XOR<FolderCreateWithoutDocumentsInput, FolderUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: FolderCreateOrConnectWithoutDocumentsInput
    upsert?: FolderUpsertWithoutDocumentsInput
    disconnect?: FolderWhereInput | boolean
    delete?: FolderWhereInput | boolean
    connect?: FolderWhereUniqueInput
    update?: XOR<XOR<FolderUpdateToOneWithWhereWithoutDocumentsInput, FolderUpdateWithoutDocumentsInput>, FolderUncheckedUpdateWithoutDocumentsInput>
  }

  export type StaffProfileUpdateOneWithoutUploadedDocumentsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutUploadedDocumentsInput, StaffProfileUncheckedCreateWithoutUploadedDocumentsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutUploadedDocumentsInput
    upsert?: StaffProfileUpsertWithoutUploadedDocumentsInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutUploadedDocumentsInput, StaffProfileUpdateWithoutUploadedDocumentsInput>, StaffProfileUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type ChecklistItemFileUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ChecklistItemFileCreateWithoutDocumentInput, ChecklistItemFileUncheckedCreateWithoutDocumentInput> | ChecklistItemFileCreateWithoutDocumentInput[] | ChecklistItemFileUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ChecklistItemFileCreateOrConnectWithoutDocumentInput | ChecklistItemFileCreateOrConnectWithoutDocumentInput[]
    upsert?: ChecklistItemFileUpsertWithWhereUniqueWithoutDocumentInput | ChecklistItemFileUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ChecklistItemFileCreateManyDocumentInputEnvelope
    set?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    disconnect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    delete?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    connect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    update?: ChecklistItemFileUpdateWithWhereUniqueWithoutDocumentInput | ChecklistItemFileUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ChecklistItemFileUpdateManyWithWhereWithoutDocumentInput | ChecklistItemFileUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ChecklistItemFileScalarWhereInput | ChecklistItemFileScalarWhereInput[]
  }

  export type ChecklistItemFileUncheckedUpdateManyWithoutDocumentNestedInput = {
    create?: XOR<ChecklistItemFileCreateWithoutDocumentInput, ChecklistItemFileUncheckedCreateWithoutDocumentInput> | ChecklistItemFileCreateWithoutDocumentInput[] | ChecklistItemFileUncheckedCreateWithoutDocumentInput[]
    connectOrCreate?: ChecklistItemFileCreateOrConnectWithoutDocumentInput | ChecklistItemFileCreateOrConnectWithoutDocumentInput[]
    upsert?: ChecklistItemFileUpsertWithWhereUniqueWithoutDocumentInput | ChecklistItemFileUpsertWithWhereUniqueWithoutDocumentInput[]
    createMany?: ChecklistItemFileCreateManyDocumentInputEnvelope
    set?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    disconnect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    delete?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    connect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    update?: ChecklistItemFileUpdateWithWhereUniqueWithoutDocumentInput | ChecklistItemFileUpdateWithWhereUniqueWithoutDocumentInput[]
    updateMany?: ChecklistItemFileUpdateManyWithWhereWithoutDocumentInput | ChecklistItemFileUpdateManyWithWhereWithoutDocumentInput[]
    deleteMany?: ChecklistItemFileScalarWhereInput | ChecklistItemFileScalarWhereInput[]
  }

  export type EntityTaxYearCreateNestedOneWithoutChecklistItemsInput = {
    create?: XOR<EntityTaxYearCreateWithoutChecklistItemsInput, EntityTaxYearUncheckedCreateWithoutChecklistItemsInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutChecklistItemsInput
    connect?: EntityTaxYearWhereUniqueInput
  }

  export type ChecklistItemFileCreateNestedManyWithoutChecklistItemInput = {
    create?: XOR<ChecklistItemFileCreateWithoutChecklistItemInput, ChecklistItemFileUncheckedCreateWithoutChecklistItemInput> | ChecklistItemFileCreateWithoutChecklistItemInput[] | ChecklistItemFileUncheckedCreateWithoutChecklistItemInput[]
    connectOrCreate?: ChecklistItemFileCreateOrConnectWithoutChecklistItemInput | ChecklistItemFileCreateOrConnectWithoutChecklistItemInput[]
    createMany?: ChecklistItemFileCreateManyChecklistItemInputEnvelope
    connect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
  }

  export type ChecklistItemFileUncheckedCreateNestedManyWithoutChecklistItemInput = {
    create?: XOR<ChecklistItemFileCreateWithoutChecklistItemInput, ChecklistItemFileUncheckedCreateWithoutChecklistItemInput> | ChecklistItemFileCreateWithoutChecklistItemInput[] | ChecklistItemFileUncheckedCreateWithoutChecklistItemInput[]
    connectOrCreate?: ChecklistItemFileCreateOrConnectWithoutChecklistItemInput | ChecklistItemFileCreateOrConnectWithoutChecklistItemInput[]
    createMany?: ChecklistItemFileCreateManyChecklistItemInputEnvelope
    connect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
  }

  export type EnumChecklistItemStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChecklistItemStatus
  }

  export type EntityTaxYearUpdateOneRequiredWithoutChecklistItemsNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutChecklistItemsInput, EntityTaxYearUncheckedCreateWithoutChecklistItemsInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutChecklistItemsInput
    upsert?: EntityTaxYearUpsertWithoutChecklistItemsInput
    connect?: EntityTaxYearWhereUniqueInput
    update?: XOR<XOR<EntityTaxYearUpdateToOneWithWhereWithoutChecklistItemsInput, EntityTaxYearUpdateWithoutChecklistItemsInput>, EntityTaxYearUncheckedUpdateWithoutChecklistItemsInput>
  }

  export type ChecklistItemFileUpdateManyWithoutChecklistItemNestedInput = {
    create?: XOR<ChecklistItemFileCreateWithoutChecklistItemInput, ChecklistItemFileUncheckedCreateWithoutChecklistItemInput> | ChecklistItemFileCreateWithoutChecklistItemInput[] | ChecklistItemFileUncheckedCreateWithoutChecklistItemInput[]
    connectOrCreate?: ChecklistItemFileCreateOrConnectWithoutChecklistItemInput | ChecklistItemFileCreateOrConnectWithoutChecklistItemInput[]
    upsert?: ChecklistItemFileUpsertWithWhereUniqueWithoutChecklistItemInput | ChecklistItemFileUpsertWithWhereUniqueWithoutChecklistItemInput[]
    createMany?: ChecklistItemFileCreateManyChecklistItemInputEnvelope
    set?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    disconnect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    delete?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    connect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    update?: ChecklistItemFileUpdateWithWhereUniqueWithoutChecklistItemInput | ChecklistItemFileUpdateWithWhereUniqueWithoutChecklistItemInput[]
    updateMany?: ChecklistItemFileUpdateManyWithWhereWithoutChecklistItemInput | ChecklistItemFileUpdateManyWithWhereWithoutChecklistItemInput[]
    deleteMany?: ChecklistItemFileScalarWhereInput | ChecklistItemFileScalarWhereInput[]
  }

  export type ChecklistItemFileUncheckedUpdateManyWithoutChecklistItemNestedInput = {
    create?: XOR<ChecklistItemFileCreateWithoutChecklistItemInput, ChecklistItemFileUncheckedCreateWithoutChecklistItemInput> | ChecklistItemFileCreateWithoutChecklistItemInput[] | ChecklistItemFileUncheckedCreateWithoutChecklistItemInput[]
    connectOrCreate?: ChecklistItemFileCreateOrConnectWithoutChecklistItemInput | ChecklistItemFileCreateOrConnectWithoutChecklistItemInput[]
    upsert?: ChecklistItemFileUpsertWithWhereUniqueWithoutChecklistItemInput | ChecklistItemFileUpsertWithWhereUniqueWithoutChecklistItemInput[]
    createMany?: ChecklistItemFileCreateManyChecklistItemInputEnvelope
    set?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    disconnect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    delete?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    connect?: ChecklistItemFileWhereUniqueInput | ChecklistItemFileWhereUniqueInput[]
    update?: ChecklistItemFileUpdateWithWhereUniqueWithoutChecklistItemInput | ChecklistItemFileUpdateWithWhereUniqueWithoutChecklistItemInput[]
    updateMany?: ChecklistItemFileUpdateManyWithWhereWithoutChecklistItemInput | ChecklistItemFileUpdateManyWithWhereWithoutChecklistItemInput[]
    deleteMany?: ChecklistItemFileScalarWhereInput | ChecklistItemFileScalarWhereInput[]
  }

  export type ChecklistItemCreateNestedOneWithoutFilesInput = {
    create?: XOR<ChecklistItemCreateWithoutFilesInput, ChecklistItemUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutFilesInput
    connect?: ChecklistItemWhereUniqueInput
  }

  export type DocumentCreateNestedOneWithoutChecklistItemsInput = {
    create?: XOR<DocumentCreateWithoutChecklistItemsInput, DocumentUncheckedCreateWithoutChecklistItemsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutChecklistItemsInput
    connect?: DocumentWhereUniqueInput
  }

  export type ChecklistItemUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<ChecklistItemCreateWithoutFilesInput, ChecklistItemUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ChecklistItemCreateOrConnectWithoutFilesInput
    upsert?: ChecklistItemUpsertWithoutFilesInput
    connect?: ChecklistItemWhereUniqueInput
    update?: XOR<XOR<ChecklistItemUpdateToOneWithWhereWithoutFilesInput, ChecklistItemUpdateWithoutFilesInput>, ChecklistItemUncheckedUpdateWithoutFilesInput>
  }

  export type DocumentUpdateOneRequiredWithoutChecklistItemsNestedInput = {
    create?: XOR<DocumentCreateWithoutChecklistItemsInput, DocumentUncheckedCreateWithoutChecklistItemsInput>
    connectOrCreate?: DocumentCreateOrConnectWithoutChecklistItemsInput
    upsert?: DocumentUpsertWithoutChecklistItemsInput
    connect?: DocumentWhereUniqueInput
    update?: XOR<XOR<DocumentUpdateToOneWithWhereWithoutChecklistItemsInput, DocumentUpdateWithoutChecklistItemsInput>, DocumentUncheckedUpdateWithoutChecklistItemsInput>
  }

  export type QuestionnaireQuestionCreateNestedManyWithoutSectionInput = {
    create?: XOR<QuestionnaireQuestionCreateWithoutSectionInput, QuestionnaireQuestionUncheckedCreateWithoutSectionInput> | QuestionnaireQuestionCreateWithoutSectionInput[] | QuestionnaireQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuestionnaireQuestionCreateOrConnectWithoutSectionInput | QuestionnaireQuestionCreateOrConnectWithoutSectionInput[]
    createMany?: QuestionnaireQuestionCreateManySectionInputEnvelope
    connect?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
  }

  export type QuestionnaireQuestionUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<QuestionnaireQuestionCreateWithoutSectionInput, QuestionnaireQuestionUncheckedCreateWithoutSectionInput> | QuestionnaireQuestionCreateWithoutSectionInput[] | QuestionnaireQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuestionnaireQuestionCreateOrConnectWithoutSectionInput | QuestionnaireQuestionCreateOrConnectWithoutSectionInput[]
    createMany?: QuestionnaireQuestionCreateManySectionInputEnvelope
    connect?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
  }

  export type QuestionnaireQuestionUpdateManyWithoutSectionNestedInput = {
    create?: XOR<QuestionnaireQuestionCreateWithoutSectionInput, QuestionnaireQuestionUncheckedCreateWithoutSectionInput> | QuestionnaireQuestionCreateWithoutSectionInput[] | QuestionnaireQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuestionnaireQuestionCreateOrConnectWithoutSectionInput | QuestionnaireQuestionCreateOrConnectWithoutSectionInput[]
    upsert?: QuestionnaireQuestionUpsertWithWhereUniqueWithoutSectionInput | QuestionnaireQuestionUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: QuestionnaireQuestionCreateManySectionInputEnvelope
    set?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
    disconnect?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
    delete?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
    connect?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
    update?: QuestionnaireQuestionUpdateWithWhereUniqueWithoutSectionInput | QuestionnaireQuestionUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: QuestionnaireQuestionUpdateManyWithWhereWithoutSectionInput | QuestionnaireQuestionUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: QuestionnaireQuestionScalarWhereInput | QuestionnaireQuestionScalarWhereInput[]
  }

  export type QuestionnaireQuestionUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<QuestionnaireQuestionCreateWithoutSectionInput, QuestionnaireQuestionUncheckedCreateWithoutSectionInput> | QuestionnaireQuestionCreateWithoutSectionInput[] | QuestionnaireQuestionUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: QuestionnaireQuestionCreateOrConnectWithoutSectionInput | QuestionnaireQuestionCreateOrConnectWithoutSectionInput[]
    upsert?: QuestionnaireQuestionUpsertWithWhereUniqueWithoutSectionInput | QuestionnaireQuestionUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: QuestionnaireQuestionCreateManySectionInputEnvelope
    set?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
    disconnect?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
    delete?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
    connect?: QuestionnaireQuestionWhereUniqueInput | QuestionnaireQuestionWhereUniqueInput[]
    update?: QuestionnaireQuestionUpdateWithWhereUniqueWithoutSectionInput | QuestionnaireQuestionUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: QuestionnaireQuestionUpdateManyWithWhereWithoutSectionInput | QuestionnaireQuestionUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: QuestionnaireQuestionScalarWhereInput | QuestionnaireQuestionScalarWhereInput[]
  }

  export type QuestionnaireSectionCreateNestedOneWithoutQuestionsInput = {
    create?: XOR<QuestionnaireSectionCreateWithoutQuestionsInput, QuestionnaireSectionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuestionnaireSectionCreateOrConnectWithoutQuestionsInput
    connect?: QuestionnaireSectionWhereUniqueInput
  }

  export type QuestionnaireAnswerCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionnaireAnswerCreateWithoutQuestionInput, QuestionnaireAnswerUncheckedCreateWithoutQuestionInput> | QuestionnaireAnswerCreateWithoutQuestionInput[] | QuestionnaireAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionnaireAnswerCreateOrConnectWithoutQuestionInput | QuestionnaireAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionnaireAnswerCreateManyQuestionInputEnvelope
    connect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
  }

  export type QuestionnaireAnswerUncheckedCreateNestedManyWithoutQuestionInput = {
    create?: XOR<QuestionnaireAnswerCreateWithoutQuestionInput, QuestionnaireAnswerUncheckedCreateWithoutQuestionInput> | QuestionnaireAnswerCreateWithoutQuestionInput[] | QuestionnaireAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionnaireAnswerCreateOrConnectWithoutQuestionInput | QuestionnaireAnswerCreateOrConnectWithoutQuestionInput[]
    createMany?: QuestionnaireAnswerCreateManyQuestionInputEnvelope
    connect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
  }

  export type EnumQuestionTypeFieldUpdateOperationsInput = {
    set?: $Enums.QuestionType
  }

  export type QuestionnaireSectionUpdateOneRequiredWithoutQuestionsNestedInput = {
    create?: XOR<QuestionnaireSectionCreateWithoutQuestionsInput, QuestionnaireSectionUncheckedCreateWithoutQuestionsInput>
    connectOrCreate?: QuestionnaireSectionCreateOrConnectWithoutQuestionsInput
    upsert?: QuestionnaireSectionUpsertWithoutQuestionsInput
    connect?: QuestionnaireSectionWhereUniqueInput
    update?: XOR<XOR<QuestionnaireSectionUpdateToOneWithWhereWithoutQuestionsInput, QuestionnaireSectionUpdateWithoutQuestionsInput>, QuestionnaireSectionUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionnaireAnswerUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionnaireAnswerCreateWithoutQuestionInput, QuestionnaireAnswerUncheckedCreateWithoutQuestionInput> | QuestionnaireAnswerCreateWithoutQuestionInput[] | QuestionnaireAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionnaireAnswerCreateOrConnectWithoutQuestionInput | QuestionnaireAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionnaireAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuestionnaireAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionnaireAnswerCreateManyQuestionInputEnvelope
    set?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    disconnect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    delete?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    connect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    update?: QuestionnaireAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuestionnaireAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionnaireAnswerUpdateManyWithWhereWithoutQuestionInput | QuestionnaireAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionnaireAnswerScalarWhereInput | QuestionnaireAnswerScalarWhereInput[]
  }

  export type QuestionnaireAnswerUncheckedUpdateManyWithoutQuestionNestedInput = {
    create?: XOR<QuestionnaireAnswerCreateWithoutQuestionInput, QuestionnaireAnswerUncheckedCreateWithoutQuestionInput> | QuestionnaireAnswerCreateWithoutQuestionInput[] | QuestionnaireAnswerUncheckedCreateWithoutQuestionInput[]
    connectOrCreate?: QuestionnaireAnswerCreateOrConnectWithoutQuestionInput | QuestionnaireAnswerCreateOrConnectWithoutQuestionInput[]
    upsert?: QuestionnaireAnswerUpsertWithWhereUniqueWithoutQuestionInput | QuestionnaireAnswerUpsertWithWhereUniqueWithoutQuestionInput[]
    createMany?: QuestionnaireAnswerCreateManyQuestionInputEnvelope
    set?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    disconnect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    delete?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    connect?: QuestionnaireAnswerWhereUniqueInput | QuestionnaireAnswerWhereUniqueInput[]
    update?: QuestionnaireAnswerUpdateWithWhereUniqueWithoutQuestionInput | QuestionnaireAnswerUpdateWithWhereUniqueWithoutQuestionInput[]
    updateMany?: QuestionnaireAnswerUpdateManyWithWhereWithoutQuestionInput | QuestionnaireAnswerUpdateManyWithWhereWithoutQuestionInput[]
    deleteMany?: QuestionnaireAnswerScalarWhereInput | QuestionnaireAnswerScalarWhereInput[]
  }

  export type EntityTaxYearCreateNestedOneWithoutQuestionnaireAnswersInput = {
    create?: XOR<EntityTaxYearCreateWithoutQuestionnaireAnswersInput, EntityTaxYearUncheckedCreateWithoutQuestionnaireAnswersInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutQuestionnaireAnswersInput
    connect?: EntityTaxYearWhereUniqueInput
  }

  export type QuestionnaireQuestionCreateNestedOneWithoutAnswersInput = {
    create?: XOR<QuestionnaireQuestionCreateWithoutAnswersInput, QuestionnaireQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionnaireQuestionCreateOrConnectWithoutAnswersInput
    connect?: QuestionnaireQuestionWhereUniqueInput
  }

  export type EntityTaxYearUpdateOneRequiredWithoutQuestionnaireAnswersNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutQuestionnaireAnswersInput, EntityTaxYearUncheckedCreateWithoutQuestionnaireAnswersInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutQuestionnaireAnswersInput
    upsert?: EntityTaxYearUpsertWithoutQuestionnaireAnswersInput
    connect?: EntityTaxYearWhereUniqueInput
    update?: XOR<XOR<EntityTaxYearUpdateToOneWithWhereWithoutQuestionnaireAnswersInput, EntityTaxYearUpdateWithoutQuestionnaireAnswersInput>, EntityTaxYearUncheckedUpdateWithoutQuestionnaireAnswersInput>
  }

  export type QuestionnaireQuestionUpdateOneRequiredWithoutAnswersNestedInput = {
    create?: XOR<QuestionnaireQuestionCreateWithoutAnswersInput, QuestionnaireQuestionUncheckedCreateWithoutAnswersInput>
    connectOrCreate?: QuestionnaireQuestionCreateOrConnectWithoutAnswersInput
    upsert?: QuestionnaireQuestionUpsertWithoutAnswersInput
    connect?: QuestionnaireQuestionWhereUniqueInput
    update?: XOR<XOR<QuestionnaireQuestionUpdateToOneWithWhereWithoutAnswersInput, QuestionnaireQuestionUpdateWithoutAnswersInput>, QuestionnaireQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type EntityTaxYearCreateNestedOneWithoutEngagementSignaturesInput = {
    create?: XOR<EntityTaxYearCreateWithoutEngagementSignaturesInput, EntityTaxYearUncheckedCreateWithoutEngagementSignaturesInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutEngagementSignaturesInput
    connect?: EntityTaxYearWhereUniqueInput
  }

  export type EntityTaxYearUpdateOneRequiredWithoutEngagementSignaturesNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutEngagementSignaturesInput, EntityTaxYearUncheckedCreateWithoutEngagementSignaturesInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutEngagementSignaturesInput
    upsert?: EntityTaxYearUpsertWithoutEngagementSignaturesInput
    connect?: EntityTaxYearWhereUniqueInput
    update?: XOR<XOR<EntityTaxYearUpdateToOneWithWhereWithoutEngagementSignaturesInput, EntityTaxYearUpdateWithoutEngagementSignaturesInput>, EntityTaxYearUncheckedUpdateWithoutEngagementSignaturesInput>
  }

  export type EntityTaxYearCreateNestedOneWithoutEfileAuthorizationsInput = {
    create?: XOR<EntityTaxYearCreateWithoutEfileAuthorizationsInput, EntityTaxYearUncheckedCreateWithoutEfileAuthorizationsInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutEfileAuthorizationsInput
    connect?: EntityTaxYearWhereUniqueInput
  }

  export type EntityTaxYearUpdateOneRequiredWithoutEfileAuthorizationsNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutEfileAuthorizationsInput, EntityTaxYearUncheckedCreateWithoutEfileAuthorizationsInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutEfileAuthorizationsInput
    upsert?: EntityTaxYearUpsertWithoutEfileAuthorizationsInput
    connect?: EntityTaxYearWhereUniqueInput
    update?: XOR<XOR<EntityTaxYearUpdateToOneWithWhereWithoutEfileAuthorizationsInput, EntityTaxYearUpdateWithoutEfileAuthorizationsInput>, EntityTaxYearUncheckedUpdateWithoutEfileAuthorizationsInput>
  }

  export type EntityTaxYearCreateNestedOneWithoutMessageThreadInput = {
    create?: XOR<EntityTaxYearCreateWithoutMessageThreadInput, EntityTaxYearUncheckedCreateWithoutMessageThreadInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutMessageThreadInput
    connect?: EntityTaxYearWhereUniqueInput
  }

  export type ThreadParticipantCreateNestedManyWithoutThreadInput = {
    create?: XOR<ThreadParticipantCreateWithoutThreadInput, ThreadParticipantUncheckedCreateWithoutThreadInput> | ThreadParticipantCreateWithoutThreadInput[] | ThreadParticipantUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: ThreadParticipantCreateOrConnectWithoutThreadInput | ThreadParticipantCreateOrConnectWithoutThreadInput[]
    createMany?: ThreadParticipantCreateManyThreadInputEnvelope
    connect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type ThreadParticipantUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<ThreadParticipantCreateWithoutThreadInput, ThreadParticipantUncheckedCreateWithoutThreadInput> | ThreadParticipantCreateWithoutThreadInput[] | ThreadParticipantUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: ThreadParticipantCreateOrConnectWithoutThreadInput | ThreadParticipantCreateOrConnectWithoutThreadInput[]
    createMany?: ThreadParticipantCreateManyThreadInputEnvelope
    connect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutThreadInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type EntityTaxYearUpdateOneRequiredWithoutMessageThreadNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutMessageThreadInput, EntityTaxYearUncheckedCreateWithoutMessageThreadInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutMessageThreadInput
    upsert?: EntityTaxYearUpsertWithoutMessageThreadInput
    connect?: EntityTaxYearWhereUniqueInput
    update?: XOR<XOR<EntityTaxYearUpdateToOneWithWhereWithoutMessageThreadInput, EntityTaxYearUpdateWithoutMessageThreadInput>, EntityTaxYearUncheckedUpdateWithoutMessageThreadInput>
  }

  export type ThreadParticipantUpdateManyWithoutThreadNestedInput = {
    create?: XOR<ThreadParticipantCreateWithoutThreadInput, ThreadParticipantUncheckedCreateWithoutThreadInput> | ThreadParticipantCreateWithoutThreadInput[] | ThreadParticipantUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: ThreadParticipantCreateOrConnectWithoutThreadInput | ThreadParticipantCreateOrConnectWithoutThreadInput[]
    upsert?: ThreadParticipantUpsertWithWhereUniqueWithoutThreadInput | ThreadParticipantUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: ThreadParticipantCreateManyThreadInputEnvelope
    set?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    disconnect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    delete?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    connect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    update?: ThreadParticipantUpdateWithWhereUniqueWithoutThreadInput | ThreadParticipantUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: ThreadParticipantUpdateManyWithWhereWithoutThreadInput | ThreadParticipantUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: ThreadParticipantScalarWhereInput | ThreadParticipantScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutThreadInput | MessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutThreadInput | MessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutThreadInput | MessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type ThreadParticipantUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<ThreadParticipantCreateWithoutThreadInput, ThreadParticipantUncheckedCreateWithoutThreadInput> | ThreadParticipantCreateWithoutThreadInput[] | ThreadParticipantUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: ThreadParticipantCreateOrConnectWithoutThreadInput | ThreadParticipantCreateOrConnectWithoutThreadInput[]
    upsert?: ThreadParticipantUpsertWithWhereUniqueWithoutThreadInput | ThreadParticipantUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: ThreadParticipantCreateManyThreadInputEnvelope
    set?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    disconnect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    delete?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    connect?: ThreadParticipantWhereUniqueInput | ThreadParticipantWhereUniqueInput[]
    update?: ThreadParticipantUpdateWithWhereUniqueWithoutThreadInput | ThreadParticipantUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: ThreadParticipantUpdateManyWithWhereWithoutThreadInput | ThreadParticipantUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: ThreadParticipantScalarWhereInput | ThreadParticipantScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutThreadNestedInput = {
    create?: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput> | MessageCreateWithoutThreadInput[] | MessageUncheckedCreateWithoutThreadInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutThreadInput | MessageCreateOrConnectWithoutThreadInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutThreadInput | MessageUpsertWithWhereUniqueWithoutThreadInput[]
    createMany?: MessageCreateManyThreadInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutThreadInput | MessageUpdateWithWhereUniqueWithoutThreadInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutThreadInput | MessageUpdateManyWithWhereWithoutThreadInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageThreadCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<MessageThreadCreateWithoutParticipantsInput, MessageThreadUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutParticipantsInput
    connect?: MessageThreadWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutAssignedThreadsInput = {
    create?: XOR<StaffProfileCreateWithoutAssignedThreadsInput, StaffProfileUncheckedCreateWithoutAssignedThreadsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutAssignedThreadsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type MessageThreadUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<MessageThreadCreateWithoutParticipantsInput, MessageThreadUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutParticipantsInput
    upsert?: MessageThreadUpsertWithoutParticipantsInput
    connect?: MessageThreadWhereUniqueInput
    update?: XOR<XOR<MessageThreadUpdateToOneWithWhereWithoutParticipantsInput, MessageThreadUpdateWithoutParticipantsInput>, MessageThreadUncheckedUpdateWithoutParticipantsInput>
  }

  export type StaffProfileUpdateOneWithoutAssignedThreadsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutAssignedThreadsInput, StaffProfileUncheckedCreateWithoutAssignedThreadsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutAssignedThreadsInput
    upsert?: StaffProfileUpsertWithoutAssignedThreadsInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutAssignedThreadsInput, StaffProfileUpdateWithoutAssignedThreadsInput>, StaffProfileUncheckedUpdateWithoutAssignedThreadsInput>
  }

  export type MessageThreadCreateNestedOneWithoutMessagesInput = {
    create?: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutMessagesInput
    connect?: MessageThreadWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<StaffProfileCreateWithoutSentMessagesInput, StaffProfileUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutSentMessagesInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type MessageThreadUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: MessageThreadCreateOrConnectWithoutMessagesInput
    upsert?: MessageThreadUpsertWithoutMessagesInput
    connect?: MessageThreadWhereUniqueInput
    update?: XOR<XOR<MessageThreadUpdateToOneWithWhereWithoutMessagesInput, MessageThreadUpdateWithoutMessagesInput>, MessageThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type StaffProfileUpdateOneWithoutSentMessagesNestedInput = {
    create?: XOR<StaffProfileCreateWithoutSentMessagesInput, StaffProfileUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutSentMessagesInput
    upsert?: StaffProfileUpsertWithoutSentMessagesInput
    disconnect?: StaffProfileWhereInput | boolean
    delete?: StaffProfileWhereInput | boolean
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutSentMessagesInput, StaffProfileUpdateWithoutSentMessagesInput>, StaffProfileUncheckedUpdateWithoutSentMessagesInput>
  }

  export type EntityTaxYearCreateNestedOneWithoutReminderStateInput = {
    create?: XOR<EntityTaxYearCreateWithoutReminderStateInput, EntityTaxYearUncheckedCreateWithoutReminderStateInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutReminderStateInput
    connect?: EntityTaxYearWhereUniqueInput
  }

  export type EnumReminderTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReminderType
  }

  export type EntityTaxYearUpdateOneRequiredWithoutReminderStateNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutReminderStateInput, EntityTaxYearUncheckedCreateWithoutReminderStateInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutReminderStateInput
    upsert?: EntityTaxYearUpsertWithoutReminderStateInput
    connect?: EntityTaxYearWhereUniqueInput
    update?: XOR<XOR<EntityTaxYearUpdateToOneWithWhereWithoutReminderStateInput, EntityTaxYearUpdateWithoutReminderStateInput>, EntityTaxYearUncheckedUpdateWithoutReminderStateInput>
  }

  export type EntityTaxYearCreateNestedOneWithoutStatusAuditLogsInput = {
    create?: XOR<EntityTaxYearCreateWithoutStatusAuditLogsInput, EntityTaxYearUncheckedCreateWithoutStatusAuditLogsInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutStatusAuditLogsInput
    connect?: EntityTaxYearWhereUniqueInput
  }

  export type StaffProfileCreateNestedOneWithoutStatusAuditLogsInput = {
    create?: XOR<StaffProfileCreateWithoutStatusAuditLogsInput, StaffProfileUncheckedCreateWithoutStatusAuditLogsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutStatusAuditLogsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type EntityTaxYearUpdateOneRequiredWithoutStatusAuditLogsNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutStatusAuditLogsInput, EntityTaxYearUncheckedCreateWithoutStatusAuditLogsInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutStatusAuditLogsInput
    upsert?: EntityTaxYearUpsertWithoutStatusAuditLogsInput
    connect?: EntityTaxYearWhereUniqueInput
    update?: XOR<XOR<EntityTaxYearUpdateToOneWithWhereWithoutStatusAuditLogsInput, EntityTaxYearUpdateWithoutStatusAuditLogsInput>, EntityTaxYearUncheckedUpdateWithoutStatusAuditLogsInput>
  }

  export type StaffProfileUpdateOneRequiredWithoutStatusAuditLogsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutStatusAuditLogsInput, StaffProfileUncheckedCreateWithoutStatusAuditLogsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutStatusAuditLogsInput
    upsert?: StaffProfileUpsertWithoutStatusAuditLogsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutStatusAuditLogsInput, StaffProfileUpdateWithoutStatusAuditLogsInput>, StaffProfileUncheckedUpdateWithoutStatusAuditLogsInput>
  }

  export type StaffProfileCreateNestedOneWithoutPermissionAuditLogsInput = {
    create?: XOR<StaffProfileCreateWithoutPermissionAuditLogsInput, StaffProfileUncheckedCreateWithoutPermissionAuditLogsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutPermissionAuditLogsInput
    connect?: StaffProfileWhereUniqueInput
  }

  export type StaffProfileUpdateOneRequiredWithoutPermissionAuditLogsNestedInput = {
    create?: XOR<StaffProfileCreateWithoutPermissionAuditLogsInput, StaffProfileUncheckedCreateWithoutPermissionAuditLogsInput>
    connectOrCreate?: StaffProfileCreateOrConnectWithoutPermissionAuditLogsInput
    upsert?: StaffProfileUpsertWithoutPermissionAuditLogsInput
    connect?: StaffProfileWhereUniqueInput
    update?: XOR<XOR<StaffProfileUpdateToOneWithWhereWithoutPermissionAuditLogsInput, StaffProfileUpdateWithoutPermissionAuditLogsInput>, StaffProfileUncheckedUpdateWithoutPermissionAuditLogsInput>
  }

  export type EntityTaxYearCreateNestedOneWithoutDocumentEventsInput = {
    create?: XOR<EntityTaxYearCreateWithoutDocumentEventsInput, EntityTaxYearUncheckedCreateWithoutDocumentEventsInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutDocumentEventsInput
    connect?: EntityTaxYearWhereUniqueInput
  }

  export type EnumDocumentEventTypeFieldUpdateOperationsInput = {
    set?: $Enums.DocumentEventType
  }

  export type EntityTaxYearUpdateOneRequiredWithoutDocumentEventsNestedInput = {
    create?: XOR<EntityTaxYearCreateWithoutDocumentEventsInput, EntityTaxYearUncheckedCreateWithoutDocumentEventsInput>
    connectOrCreate?: EntityTaxYearCreateOrConnectWithoutDocumentEventsInput
    upsert?: EntityTaxYearUpsertWithoutDocumentEventsInput
    connect?: EntityTaxYearWhereUniqueInput
    update?: XOR<XOR<EntityTaxYearUpdateToOneWithWhereWithoutDocumentEventsInput, EntityTaxYearUpdateWithoutDocumentEventsInput>, EntityTaxYearUncheckedUpdateWithoutDocumentEventsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumUserTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeFilter<$PrismaModel> | $Enums.UserType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumUserTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserType | EnumUserTypeFieldRefInput<$PrismaModel>
    in?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserType[] | ListEnumUserTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumUserTypeWithAggregatesFilter<$PrismaModel> | $Enums.UserType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserTypeFilter<$PrismaModel>
    _max?: NestedEnumUserTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumStaffRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffRole | EnumStaffRoleFieldRefInput<$PrismaModel>
    in?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffRoleFilter<$PrismaModel> | $Enums.StaffRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumStaffRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.StaffRole | EnumStaffRoleFieldRefInput<$PrismaModel>
    in?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.StaffRole[] | ListEnumStaffRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumStaffRoleWithAggregatesFilter<$PrismaModel> | $Enums.StaffRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStaffRoleFilter<$PrismaModel>
    _max?: NestedEnumStaffRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumClientRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientRole | EnumClientRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClientRole[] | ListEnumClientRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientRole[] | ListEnumClientRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClientRoleFilter<$PrismaModel> | $Enums.ClientRole
  }

  export type NestedEnumClientRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ClientRole | EnumClientRoleFieldRefInput<$PrismaModel>
    in?: $Enums.ClientRole[] | ListEnumClientRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.ClientRole[] | ListEnumClientRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumClientRoleWithAggregatesFilter<$PrismaModel> | $Enums.ClientRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumClientRoleFilter<$PrismaModel>
    _max?: NestedEnumClientRoleFilter<$PrismaModel>
  }

  export type NestedEnumEntityTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeFilter<$PrismaModel> | $Enums.EntityType
  }

  export type NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EntityType | EnumEntityTypeFieldRefInput<$PrismaModel>
    in?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.EntityType[] | ListEnumEntityTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumEntityTypeWithAggregatesFilter<$PrismaModel> | $Enums.EntityType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEntityTypeFilter<$PrismaModel>
    _max?: NestedEnumEntityTypeFilter<$PrismaModel>
  }

  export type NestedEnumInviteStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusFilter<$PrismaModel> | $Enums.InviteStatus
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumEngagementStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementStatus | EnumEngagementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementStatus[] | ListEnumEngagementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementStatus[] | ListEnumEngagementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementStatusFilter<$PrismaModel> | $Enums.EngagementStatus
  }

  export type NestedEnumConfirmationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfirmationStatus | EnumConfirmationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfirmationStatusFilter<$PrismaModel> | $Enums.ConfirmationStatus
  }

  export type NestedEnumQuestionnaireStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireStatus | EnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireStatusFilter<$PrismaModel> | $Enums.QuestionnaireStatus
  }

  export type NestedEnumIdStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IdStatus | EnumIdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdStatus[] | ListEnumIdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdStatus[] | ListEnumIdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdStatusFilter<$PrismaModel> | $Enums.IdStatus
  }

  export type NestedEnumInternalStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InternalStatus | EnumInternalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternalStatus[] | ListEnumInternalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InternalStatus[] | ListEnumInternalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInternalStatusFilter<$PrismaModel> | $Enums.InternalStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InviteStatus | EnumInviteStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InviteStatus[] | ListEnumInviteStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInviteStatusWithAggregatesFilter<$PrismaModel> | $Enums.InviteStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInviteStatusFilter<$PrismaModel>
    _max?: NestedEnumInviteStatusFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEngagementStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EngagementStatus | EnumEngagementStatusFieldRefInput<$PrismaModel>
    in?: $Enums.EngagementStatus[] | ListEnumEngagementStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.EngagementStatus[] | ListEnumEngagementStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumEngagementStatusWithAggregatesFilter<$PrismaModel> | $Enums.EngagementStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEngagementStatusFilter<$PrismaModel>
    _max?: NestedEnumEngagementStatusFilter<$PrismaModel>
  }

  export type NestedEnumConfirmationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ConfirmationStatus | EnumConfirmationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ConfirmationStatus[] | ListEnumConfirmationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumConfirmationStatusWithAggregatesFilter<$PrismaModel> | $Enums.ConfirmationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumConfirmationStatusFilter<$PrismaModel>
    _max?: NestedEnumConfirmationStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuestionnaireStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionnaireStatus | EnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionnaireStatus[] | ListEnumQuestionnaireStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionnaireStatusWithAggregatesFilter<$PrismaModel> | $Enums.QuestionnaireStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionnaireStatusFilter<$PrismaModel>
    _max?: NestedEnumQuestionnaireStatusFilter<$PrismaModel>
  }

  export type NestedEnumIdStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IdStatus | EnumIdStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IdStatus[] | ListEnumIdStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IdStatus[] | ListEnumIdStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIdStatusWithAggregatesFilter<$PrismaModel> | $Enums.IdStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIdStatusFilter<$PrismaModel>
    _max?: NestedEnumIdStatusFilter<$PrismaModel>
  }

  export type NestedEnumInternalStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InternalStatus | EnumInternalStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InternalStatus[] | ListEnumInternalStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InternalStatus[] | ListEnumInternalStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInternalStatusWithAggregatesFilter<$PrismaModel> | $Enums.InternalStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInternalStatusFilter<$PrismaModel>
    _max?: NestedEnumInternalStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumChecklistItemStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistItemStatus | EnumChecklistItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistItemStatus[] | ListEnumChecklistItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistItemStatus[] | ListEnumChecklistItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistItemStatusFilter<$PrismaModel> | $Enums.ChecklistItemStatus
  }

  export type NestedEnumChecklistItemStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChecklistItemStatus | EnumChecklistItemStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChecklistItemStatus[] | ListEnumChecklistItemStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChecklistItemStatus[] | ListEnumChecklistItemStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChecklistItemStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChecklistItemStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChecklistItemStatusFilter<$PrismaModel>
    _max?: NestedEnumChecklistItemStatusFilter<$PrismaModel>
  }

  export type NestedEnumQuestionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeFilter<$PrismaModel> | $Enums.QuestionType
  }

  export type NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.QuestionType | EnumQuestionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.QuestionType[] | ListEnumQuestionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumQuestionTypeWithAggregatesFilter<$PrismaModel> | $Enums.QuestionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumQuestionTypeFilter<$PrismaModel>
    _max?: NestedEnumQuestionTypeFilter<$PrismaModel>
  }

  export type NestedEnumReminderTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeFilter<$PrismaModel> | $Enums.ReminderType
  }

  export type NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReminderType | EnumReminderTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReminderType[] | ListEnumReminderTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumReminderTypeWithAggregatesFilter<$PrismaModel> | $Enums.ReminderType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReminderTypeFilter<$PrismaModel>
    _max?: NestedEnumReminderTypeFilter<$PrismaModel>
  }

  export type NestedEnumDocumentEventTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentEventType | EnumDocumentEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentEventType[] | ListEnumDocumentEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentEventType[] | ListEnumDocumentEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentEventTypeFilter<$PrismaModel> | $Enums.DocumentEventType
  }

  export type NestedEnumDocumentEventTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DocumentEventType | EnumDocumentEventTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DocumentEventType[] | ListEnumDocumentEventTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DocumentEventType[] | ListEnumDocumentEventTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDocumentEventTypeWithAggregatesFilter<$PrismaModel> | $Enums.DocumentEventType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDocumentEventTypeFilter<$PrismaModel>
    _max?: NestedEnumDocumentEventTypeFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staffProfile?: StaffProfileCreateNestedOneWithoutProfileInput
    accountUsers?: AccountUserCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutProfileInput
    accountUsers?: AccountUserUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type StaffProfileCreateWithoutUserInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutUserInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutUserInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUpdateOneWithoutProfileNestedInput
    accountUsers?: AccountUserUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutProfileNestedInput
    accountUsers?: AccountUserUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type StaffProfileUpsertWithoutUserInput = {
    update: XOR<StaffProfileUpdateWithoutUserInput, StaffProfileUncheckedUpdateWithoutUserInput>
    create: XOR<StaffProfileCreateWithoutUserInput, StaffProfileUncheckedCreateWithoutUserInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutUserInput, StaffProfileUncheckedUpdateWithoutUserInput>
  }

  export type StaffProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    staffProfile?: StaffProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type StaffProfileCreateWithoutProfileInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutProfileInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutProfileInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutProfileInput, StaffProfileUncheckedCreateWithoutProfileInput>
  }

  export type AccountUserCreateWithoutProfileInput = {
    id?: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutAccountUsersInput
  }

  export type AccountUserUncheckedCreateWithoutProfileInput = {
    id?: string
    accountId: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUserCreateOrConnectWithoutProfileInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutProfileInput, AccountUserUncheckedCreateWithoutProfileInput>
  }

  export type AccountUserCreateManyProfileInputEnvelope = {
    data: AccountUserCreateManyProfileInput | AccountUserCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type StaffProfileUpsertWithoutProfileInput = {
    update: XOR<StaffProfileUpdateWithoutProfileInput, StaffProfileUncheckedUpdateWithoutProfileInput>
    create: XOR<StaffProfileCreateWithoutProfileInput, StaffProfileUncheckedCreateWithoutProfileInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutProfileInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutProfileInput, StaffProfileUncheckedUpdateWithoutProfileInput>
  }

  export type StaffProfileUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type AccountUserUpsertWithWhereUniqueWithoutProfileInput = {
    where: AccountUserWhereUniqueInput
    update: XOR<AccountUserUpdateWithoutProfileInput, AccountUserUncheckedUpdateWithoutProfileInput>
    create: XOR<AccountUserCreateWithoutProfileInput, AccountUserUncheckedCreateWithoutProfileInput>
  }

  export type AccountUserUpdateWithWhereUniqueWithoutProfileInput = {
    where: AccountUserWhereUniqueInput
    data: XOR<AccountUserUpdateWithoutProfileInput, AccountUserUncheckedUpdateWithoutProfileInput>
  }

  export type AccountUserUpdateManyWithWhereWithoutProfileInput = {
    where: AccountUserScalarWhereInput
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyWithoutProfileInput>
  }

  export type AccountUserScalarWhereInput = {
    AND?: AccountUserScalarWhereInput | AccountUserScalarWhereInput[]
    OR?: AccountUserScalarWhereInput[]
    NOT?: AccountUserScalarWhereInput | AccountUserScalarWhereInput[]
    id?: StringFilter<"AccountUser"> | string
    accountId?: StringFilter<"AccountUser"> | string
    userId?: StringFilter<"AccountUser"> | string
    clientRole?: EnumClientRoleFilter<"AccountUser"> | $Enums.ClientRole
    createdAt?: DateTimeFilter<"AccountUser"> | Date | string
    updatedAt?: DateTimeFilter<"AccountUser"> | Date | string
  }

  export type UserCreateWithoutStaffProfileInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutStaffProfileInput = {
    id?: string
    email: string
    passwordHash: string
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutStaffProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
  }

  export type ProfileCreateWithoutStaffProfileInput = {
    id?: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    accountUsers?: AccountUserCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutStaffProfileInput = {
    id?: string
    userId: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    accountUsers?: AccountUserUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutStaffProfileInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutStaffProfileInput, ProfileUncheckedCreateWithoutStaffProfileInput>
  }

  export type ClientAclCreateWithoutStaffInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutClientAclInput
  }

  export type ClientAclUncheckedCreateWithoutStaffInput = {
    id?: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAclCreateOrConnectWithoutStaffInput = {
    where: ClientAclWhereUniqueInput
    create: XOR<ClientAclCreateWithoutStaffInput, ClientAclUncheckedCreateWithoutStaffInput>
  }

  export type ClientAclCreateManyStaffInputEnvelope = {
    data: ClientAclCreateManyStaffInput | ClientAclCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type ClientStaffPermissionCreateWithoutStaffInput = {
    id?: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutClientStaffPermissionsInput
  }

  export type ClientStaffPermissionUncheckedCreateWithoutStaffInput = {
    id?: string
    clientId: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffPermissionCreateOrConnectWithoutStaffInput = {
    where: ClientStaffPermissionWhereUniqueInput
    create: XOR<ClientStaffPermissionCreateWithoutStaffInput, ClientStaffPermissionUncheckedCreateWithoutStaffInput>
  }

  export type ClientStaffPermissionCreateManyStaffInputEnvelope = {
    data: ClientStaffPermissionCreateManyStaffInput | ClientStaffPermissionCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type ClientStaffAssignmentCreateWithoutStaffInput = {
    id?: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutClientStaffAssignmentsInput
  }

  export type ClientStaffAssignmentUncheckedCreateWithoutStaffInput = {
    id?: string
    clientId: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffAssignmentCreateOrConnectWithoutStaffInput = {
    where: ClientStaffAssignmentWhereUniqueInput
    create: XOR<ClientStaffAssignmentCreateWithoutStaffInput, ClientStaffAssignmentUncheckedCreateWithoutStaffInput>
  }

  export type ClientStaffAssignmentCreateManyStaffInputEnvelope = {
    data: ClientStaffAssignmentCreateManyStaffInput | ClientStaffAssignmentCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type FolderAclCreateWithoutStaffInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    folder: FolderCreateNestedOneWithoutFolderAclInput
  }

  export type FolderAclUncheckedCreateWithoutStaffInput = {
    id?: string
    folderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderAclCreateOrConnectWithoutStaffInput = {
    where: FolderAclWhereUniqueInput
    create: XOR<FolderAclCreateWithoutStaffInput, FolderAclUncheckedCreateWithoutStaffInput>
  }

  export type FolderAclCreateManyStaffInputEnvelope = {
    data: FolderAclCreateManyStaffInput | FolderAclCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutUploaderInput = {
    id?: string
    storagePath: string
    displayName: string
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutDocumentsInput
    folder?: FolderCreateNestedOneWithoutDocumentsInput
    checklistItems?: ChecklistItemFileCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutUploaderInput = {
    id?: string
    clientId: string
    folderId?: string | null
    storagePath: string
    displayName: string
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemFileUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentCreateManyUploaderInputEnvelope = {
    data: DocumentCreateManyUploaderInput | DocumentCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type ThreadParticipantCreateWithoutStaffInput = {
    id?: string
    userType: $Enums.UserType
    createdAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutParticipantsInput
  }

  export type ThreadParticipantUncheckedCreateWithoutStaffInput = {
    id?: string
    threadId: string
    userType: $Enums.UserType
    createdAt?: Date | string
  }

  export type ThreadParticipantCreateOrConnectWithoutStaffInput = {
    where: ThreadParticipantWhereUniqueInput
    create: XOR<ThreadParticipantCreateWithoutStaffInput, ThreadParticipantUncheckedCreateWithoutStaffInput>
  }

  export type ThreadParticipantCreateManyStaffInputEnvelope = {
    data: ThreadParticipantCreateManyStaffInput | ThreadParticipantCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    thread: MessageThreadCreateNestedOneWithoutMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    threadId: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type StatusAuditLogCreateWithoutStaffInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    reason?: string | null
    createdAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutStatusAuditLogsInput
  }

  export type StatusAuditLogUncheckedCreateWithoutStaffInput = {
    id?: string
    entityTaxYearId: string
    oldStatus?: string | null
    newStatus: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type StatusAuditLogCreateOrConnectWithoutStaffInput = {
    where: StatusAuditLogWhereUniqueInput
    create: XOR<StatusAuditLogCreateWithoutStaffInput, StatusAuditLogUncheckedCreateWithoutStaffInput>
  }

  export type StatusAuditLogCreateManyStaffInputEnvelope = {
    data: StatusAuditLogCreateManyStaffInput | StatusAuditLogCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type PermissionAuditLogCreateWithoutStaffInput = {
    id?: string
    changeType: string
    clientId?: string | null
    staffUserId?: string | null
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditLogUncheckedCreateWithoutStaffInput = {
    id?: string
    changeType: string
    clientId?: string | null
    staffUserId?: string | null
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditLogCreateOrConnectWithoutStaffInput = {
    where: PermissionAuditLogWhereUniqueInput
    create: XOR<PermissionAuditLogCreateWithoutStaffInput, PermissionAuditLogUncheckedCreateWithoutStaffInput>
  }

  export type PermissionAuditLogCreateManyStaffInputEnvelope = {
    data: PermissionAuditLogCreateManyStaffInput | PermissionAuditLogCreateManyStaffInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStaffProfileInput = {
    update: XOR<UserUpdateWithoutStaffProfileInput, UserUncheckedUpdateWithoutStaffProfileInput>
    create: XOR<UserCreateWithoutStaffProfileInput, UserUncheckedCreateWithoutStaffProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStaffProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStaffProfileInput, UserUncheckedUpdateWithoutStaffProfileInput>
  }

  export type UserUpdateWithoutStaffProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutStaffProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type ProfileUpsertWithoutStaffProfileInput = {
    update: XOR<ProfileUpdateWithoutStaffProfileInput, ProfileUncheckedUpdateWithoutStaffProfileInput>
    create: XOR<ProfileCreateWithoutStaffProfileInput, ProfileUncheckedCreateWithoutStaffProfileInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutStaffProfileInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutStaffProfileInput, ProfileUncheckedUpdateWithoutStaffProfileInput>
  }

  export type ProfileUpdateWithoutStaffProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    accountUsers?: AccountUserUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutStaffProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountUsers?: AccountUserUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ClientAclUpsertWithWhereUniqueWithoutStaffInput = {
    where: ClientAclWhereUniqueInput
    update: XOR<ClientAclUpdateWithoutStaffInput, ClientAclUncheckedUpdateWithoutStaffInput>
    create: XOR<ClientAclCreateWithoutStaffInput, ClientAclUncheckedCreateWithoutStaffInput>
  }

  export type ClientAclUpdateWithWhereUniqueWithoutStaffInput = {
    where: ClientAclWhereUniqueInput
    data: XOR<ClientAclUpdateWithoutStaffInput, ClientAclUncheckedUpdateWithoutStaffInput>
  }

  export type ClientAclUpdateManyWithWhereWithoutStaffInput = {
    where: ClientAclScalarWhereInput
    data: XOR<ClientAclUpdateManyMutationInput, ClientAclUncheckedUpdateManyWithoutStaffInput>
  }

  export type ClientAclScalarWhereInput = {
    AND?: ClientAclScalarWhereInput | ClientAclScalarWhereInput[]
    OR?: ClientAclScalarWhereInput[]
    NOT?: ClientAclScalarWhereInput | ClientAclScalarWhereInput[]
    id?: StringFilter<"ClientAcl"> | string
    clientId?: StringFilter<"ClientAcl"> | string
    staffUserId?: StringFilter<"ClientAcl"> | string
    createdAt?: DateTimeFilter<"ClientAcl"> | Date | string
    updatedAt?: DateTimeFilter<"ClientAcl"> | Date | string
  }

  export type ClientStaffPermissionUpsertWithWhereUniqueWithoutStaffInput = {
    where: ClientStaffPermissionWhereUniqueInput
    update: XOR<ClientStaffPermissionUpdateWithoutStaffInput, ClientStaffPermissionUncheckedUpdateWithoutStaffInput>
    create: XOR<ClientStaffPermissionCreateWithoutStaffInput, ClientStaffPermissionUncheckedCreateWithoutStaffInput>
  }

  export type ClientStaffPermissionUpdateWithWhereUniqueWithoutStaffInput = {
    where: ClientStaffPermissionWhereUniqueInput
    data: XOR<ClientStaffPermissionUpdateWithoutStaffInput, ClientStaffPermissionUncheckedUpdateWithoutStaffInput>
  }

  export type ClientStaffPermissionUpdateManyWithWhereWithoutStaffInput = {
    where: ClientStaffPermissionScalarWhereInput
    data: XOR<ClientStaffPermissionUpdateManyMutationInput, ClientStaffPermissionUncheckedUpdateManyWithoutStaffInput>
  }

  export type ClientStaffPermissionScalarWhereInput = {
    AND?: ClientStaffPermissionScalarWhereInput | ClientStaffPermissionScalarWhereInput[]
    OR?: ClientStaffPermissionScalarWhereInput[]
    NOT?: ClientStaffPermissionScalarWhereInput | ClientStaffPermissionScalarWhereInput[]
    id?: StringFilter<"ClientStaffPermission"> | string
    clientId?: StringFilter<"ClientStaffPermission"> | string
    staffUserId?: StringFilter<"ClientStaffPermission"> | string
    canSeeTaxes?: BoolFilter<"ClientStaffPermission"> | boolean
    createdAt?: DateTimeFilter<"ClientStaffPermission"> | Date | string
    updatedAt?: DateTimeFilter<"ClientStaffPermission"> | Date | string
  }

  export type ClientStaffAssignmentUpsertWithWhereUniqueWithoutStaffInput = {
    where: ClientStaffAssignmentWhereUniqueInput
    update: XOR<ClientStaffAssignmentUpdateWithoutStaffInput, ClientStaffAssignmentUncheckedUpdateWithoutStaffInput>
    create: XOR<ClientStaffAssignmentCreateWithoutStaffInput, ClientStaffAssignmentUncheckedCreateWithoutStaffInput>
  }

  export type ClientStaffAssignmentUpdateWithWhereUniqueWithoutStaffInput = {
    where: ClientStaffAssignmentWhereUniqueInput
    data: XOR<ClientStaffAssignmentUpdateWithoutStaffInput, ClientStaffAssignmentUncheckedUpdateWithoutStaffInput>
  }

  export type ClientStaffAssignmentUpdateManyWithWhereWithoutStaffInput = {
    where: ClientStaffAssignmentScalarWhereInput
    data: XOR<ClientStaffAssignmentUpdateManyMutationInput, ClientStaffAssignmentUncheckedUpdateManyWithoutStaffInput>
  }

  export type ClientStaffAssignmentScalarWhereInput = {
    AND?: ClientStaffAssignmentScalarWhereInput | ClientStaffAssignmentScalarWhereInput[]
    OR?: ClientStaffAssignmentScalarWhereInput[]
    NOT?: ClientStaffAssignmentScalarWhereInput | ClientStaffAssignmentScalarWhereInput[]
    id?: StringFilter<"ClientStaffAssignment"> | string
    clientId?: StringFilter<"ClientStaffAssignment"> | string
    staffUserId?: StringFilter<"ClientStaffAssignment"> | string
    roleOnClient?: StringFilter<"ClientStaffAssignment"> | string
    active?: BoolFilter<"ClientStaffAssignment"> | boolean
    assignedBy?: StringNullableFilter<"ClientStaffAssignment"> | string | null
    createdAt?: DateTimeFilter<"ClientStaffAssignment"> | Date | string
    updatedAt?: DateTimeFilter<"ClientStaffAssignment"> | Date | string
  }

  export type FolderAclUpsertWithWhereUniqueWithoutStaffInput = {
    where: FolderAclWhereUniqueInput
    update: XOR<FolderAclUpdateWithoutStaffInput, FolderAclUncheckedUpdateWithoutStaffInput>
    create: XOR<FolderAclCreateWithoutStaffInput, FolderAclUncheckedCreateWithoutStaffInput>
  }

  export type FolderAclUpdateWithWhereUniqueWithoutStaffInput = {
    where: FolderAclWhereUniqueInput
    data: XOR<FolderAclUpdateWithoutStaffInput, FolderAclUncheckedUpdateWithoutStaffInput>
  }

  export type FolderAclUpdateManyWithWhereWithoutStaffInput = {
    where: FolderAclScalarWhereInput
    data: XOR<FolderAclUpdateManyMutationInput, FolderAclUncheckedUpdateManyWithoutStaffInput>
  }

  export type FolderAclScalarWhereInput = {
    AND?: FolderAclScalarWhereInput | FolderAclScalarWhereInput[]
    OR?: FolderAclScalarWhereInput[]
    NOT?: FolderAclScalarWhereInput | FolderAclScalarWhereInput[]
    id?: StringFilter<"FolderAcl"> | string
    folderId?: StringFilter<"FolderAcl"> | string
    staffUserId?: StringFilter<"FolderAcl"> | string
    createdAt?: DateTimeFilter<"FolderAcl"> | Date | string
    updatedAt?: DateTimeFilter<"FolderAcl"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutUploaderInput, DocumentUncheckedUpdateWithoutUploaderInput>
    create: XOR<DocumentCreateWithoutUploaderInput, DocumentUncheckedCreateWithoutUploaderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutUploaderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutUploaderInput, DocumentUncheckedUpdateWithoutUploaderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutUploaderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutUploaderInput>
  }

  export type DocumentScalarWhereInput = {
    AND?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    OR?: DocumentScalarWhereInput[]
    NOT?: DocumentScalarWhereInput | DocumentScalarWhereInput[]
    id?: StringFilter<"Document"> | string
    clientId?: StringFilter<"Document"> | string
    folderId?: StringNullableFilter<"Document"> | string | null
    storagePath?: StringFilter<"Document"> | string
    displayName?: StringFilter<"Document"> | string
    uploadedBy?: StringNullableFilter<"Document"> | string | null
    fileSize?: IntNullableFilter<"Document"> | number | null
    mimeType?: StringNullableFilter<"Document"> | string | null
    createdAt?: DateTimeFilter<"Document"> | Date | string
    updatedAt?: DateTimeFilter<"Document"> | Date | string
  }

  export type ThreadParticipantUpsertWithWhereUniqueWithoutStaffInput = {
    where: ThreadParticipantWhereUniqueInput
    update: XOR<ThreadParticipantUpdateWithoutStaffInput, ThreadParticipantUncheckedUpdateWithoutStaffInput>
    create: XOR<ThreadParticipantCreateWithoutStaffInput, ThreadParticipantUncheckedCreateWithoutStaffInput>
  }

  export type ThreadParticipantUpdateWithWhereUniqueWithoutStaffInput = {
    where: ThreadParticipantWhereUniqueInput
    data: XOR<ThreadParticipantUpdateWithoutStaffInput, ThreadParticipantUncheckedUpdateWithoutStaffInput>
  }

  export type ThreadParticipantUpdateManyWithWhereWithoutStaffInput = {
    where: ThreadParticipantScalarWhereInput
    data: XOR<ThreadParticipantUpdateManyMutationInput, ThreadParticipantUncheckedUpdateManyWithoutStaffInput>
  }

  export type ThreadParticipantScalarWhereInput = {
    AND?: ThreadParticipantScalarWhereInput | ThreadParticipantScalarWhereInput[]
    OR?: ThreadParticipantScalarWhereInput[]
    NOT?: ThreadParticipantScalarWhereInput | ThreadParticipantScalarWhereInput[]
    id?: StringFilter<"ThreadParticipant"> | string
    threadId?: StringFilter<"ThreadParticipant"> | string
    userId?: StringFilter<"ThreadParticipant"> | string
    userType?: EnumUserTypeFilter<"ThreadParticipant"> | $Enums.UserType
    createdAt?: DateTimeFilter<"ThreadParticipant"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    threadId?: StringFilter<"Message"> | string
    senderId?: StringFilter<"Message"> | string
    senderType?: EnumUserTypeFilter<"Message"> | $Enums.UserType
    content?: StringFilter<"Message"> | string
    read?: BoolFilter<"Message"> | boolean
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
  }

  export type StatusAuditLogUpsertWithWhereUniqueWithoutStaffInput = {
    where: StatusAuditLogWhereUniqueInput
    update: XOR<StatusAuditLogUpdateWithoutStaffInput, StatusAuditLogUncheckedUpdateWithoutStaffInput>
    create: XOR<StatusAuditLogCreateWithoutStaffInput, StatusAuditLogUncheckedCreateWithoutStaffInput>
  }

  export type StatusAuditLogUpdateWithWhereUniqueWithoutStaffInput = {
    where: StatusAuditLogWhereUniqueInput
    data: XOR<StatusAuditLogUpdateWithoutStaffInput, StatusAuditLogUncheckedUpdateWithoutStaffInput>
  }

  export type StatusAuditLogUpdateManyWithWhereWithoutStaffInput = {
    where: StatusAuditLogScalarWhereInput
    data: XOR<StatusAuditLogUpdateManyMutationInput, StatusAuditLogUncheckedUpdateManyWithoutStaffInput>
  }

  export type StatusAuditLogScalarWhereInput = {
    AND?: StatusAuditLogScalarWhereInput | StatusAuditLogScalarWhereInput[]
    OR?: StatusAuditLogScalarWhereInput[]
    NOT?: StatusAuditLogScalarWhereInput | StatusAuditLogScalarWhereInput[]
    id?: StringFilter<"StatusAuditLog"> | string
    entityTaxYearId?: StringFilter<"StatusAuditLog"> | string
    oldStatus?: StringNullableFilter<"StatusAuditLog"> | string | null
    newStatus?: StringFilter<"StatusAuditLog"> | string
    changedBy?: StringFilter<"StatusAuditLog"> | string
    reason?: StringNullableFilter<"StatusAuditLog"> | string | null
    createdAt?: DateTimeFilter<"StatusAuditLog"> | Date | string
  }

  export type PermissionAuditLogUpsertWithWhereUniqueWithoutStaffInput = {
    where: PermissionAuditLogWhereUniqueInput
    update: XOR<PermissionAuditLogUpdateWithoutStaffInput, PermissionAuditLogUncheckedUpdateWithoutStaffInput>
    create: XOR<PermissionAuditLogCreateWithoutStaffInput, PermissionAuditLogUncheckedCreateWithoutStaffInput>
  }

  export type PermissionAuditLogUpdateWithWhereUniqueWithoutStaffInput = {
    where: PermissionAuditLogWhereUniqueInput
    data: XOR<PermissionAuditLogUpdateWithoutStaffInput, PermissionAuditLogUncheckedUpdateWithoutStaffInput>
  }

  export type PermissionAuditLogUpdateManyWithWhereWithoutStaffInput = {
    where: PermissionAuditLogScalarWhereInput
    data: XOR<PermissionAuditLogUpdateManyMutationInput, PermissionAuditLogUncheckedUpdateManyWithoutStaffInput>
  }

  export type PermissionAuditLogScalarWhereInput = {
    AND?: PermissionAuditLogScalarWhereInput | PermissionAuditLogScalarWhereInput[]
    OR?: PermissionAuditLogScalarWhereInput[]
    NOT?: PermissionAuditLogScalarWhereInput | PermissionAuditLogScalarWhereInput[]
    id?: StringFilter<"PermissionAuditLog"> | string
    changeType?: StringFilter<"PermissionAuditLog"> | string
    clientId?: StringNullableFilter<"PermissionAuditLog"> | string | null
    staffUserId?: StringNullableFilter<"PermissionAuditLog"> | string | null
    oldValue?: StringNullableFilter<"PermissionAuditLog"> | string | null
    newValue?: StringNullableFilter<"PermissionAuditLog"> | string | null
    changedBy?: StringFilter<"PermissionAuditLog"> | string
    reason?: StringNullableFilter<"PermissionAuditLog"> | string | null
    createdAt?: DateTimeFilter<"PermissionAuditLog"> | Date | string
  }

  export type AccountUserCreateWithoutAccountInput = {
    id?: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
    profile: ProfileCreateNestedOneWithoutAccountUsersInput
  }

  export type AccountUserUncheckedCreateWithoutAccountInput = {
    id?: string
    userId: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUserCreateOrConnectWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    create: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput>
  }

  export type AccountUserCreateManyAccountInputEnvelope = {
    data: AccountUserCreateManyAccountInput | AccountUserCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type ClientEntityCreateWithoutAccountInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYears?: EntityTaxYearCreateNestedManyWithoutClientEntityInput
    folders?: FolderCreateNestedManyWithoutClientEntityInput
    documents?: DocumentCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUncheckedCreateWithoutAccountInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYears?: EntityTaxYearUncheckedCreateNestedManyWithoutClientEntityInput
    folders?: FolderUncheckedCreateNestedManyWithoutClientEntityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityCreateOrConnectWithoutAccountInput = {
    where: ClientEntityWhereUniqueInput
    create: XOR<ClientEntityCreateWithoutAccountInput, ClientEntityUncheckedCreateWithoutAccountInput>
  }

  export type ClientEntityCreateManyAccountInputEnvelope = {
    data: ClientEntityCreateManyAccountInput | ClientEntityCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type AccountUserUpsertWithWhereUniqueWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    update: XOR<AccountUserUpdateWithoutAccountInput, AccountUserUncheckedUpdateWithoutAccountInput>
    create: XOR<AccountUserCreateWithoutAccountInput, AccountUserUncheckedCreateWithoutAccountInput>
  }

  export type AccountUserUpdateWithWhereUniqueWithoutAccountInput = {
    where: AccountUserWhereUniqueInput
    data: XOR<AccountUserUpdateWithoutAccountInput, AccountUserUncheckedUpdateWithoutAccountInput>
  }

  export type AccountUserUpdateManyWithWhereWithoutAccountInput = {
    where: AccountUserScalarWhereInput
    data: XOR<AccountUserUpdateManyMutationInput, AccountUserUncheckedUpdateManyWithoutAccountInput>
  }

  export type ClientEntityUpsertWithWhereUniqueWithoutAccountInput = {
    where: ClientEntityWhereUniqueInput
    update: XOR<ClientEntityUpdateWithoutAccountInput, ClientEntityUncheckedUpdateWithoutAccountInput>
    create: XOR<ClientEntityCreateWithoutAccountInput, ClientEntityUncheckedCreateWithoutAccountInput>
  }

  export type ClientEntityUpdateWithWhereUniqueWithoutAccountInput = {
    where: ClientEntityWhereUniqueInput
    data: XOR<ClientEntityUpdateWithoutAccountInput, ClientEntityUncheckedUpdateWithoutAccountInput>
  }

  export type ClientEntityUpdateManyWithWhereWithoutAccountInput = {
    where: ClientEntityScalarWhereInput
    data: XOR<ClientEntityUpdateManyMutationInput, ClientEntityUncheckedUpdateManyWithoutAccountInput>
  }

  export type ClientEntityScalarWhereInput = {
    AND?: ClientEntityScalarWhereInput | ClientEntityScalarWhereInput[]
    OR?: ClientEntityScalarWhereInput[]
    NOT?: ClientEntityScalarWhereInput | ClientEntityScalarWhereInput[]
    id?: StringFilter<"ClientEntity"> | string
    accountId?: StringFilter<"ClientEntity"> | string
    entityName?: StringFilter<"ClientEntity"> | string
    entityType?: EnumEntityTypeFilter<"ClientEntity"> | $Enums.EntityType
    status?: StringNullableFilter<"ClientEntity"> | string | null
    isRestricted?: BoolFilter<"ClientEntity"> | boolean
    createdAt?: DateTimeFilter<"ClientEntity"> | Date | string
    updatedAt?: DateTimeFilter<"ClientEntity"> | Date | string
  }

  export type AccountCreateWithoutAccountUsersInput = {
    id?: string
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entities?: ClientEntityCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutAccountUsersInput = {
    id?: string
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    entities?: ClientEntityUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutAccountUsersInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutAccountUsersInput, AccountUncheckedCreateWithoutAccountUsersInput>
  }

  export type ProfileCreateWithoutAccountUsersInput = {
    id?: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    staffProfile?: StaffProfileCreateNestedOneWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutAccountUsersInput = {
    id?: string
    userId: string
    userType?: $Enums.UserType
    fullName: string
    email: string
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staffProfile?: StaffProfileUncheckedCreateNestedOneWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutAccountUsersInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutAccountUsersInput, ProfileUncheckedCreateWithoutAccountUsersInput>
  }

  export type AccountUpsertWithoutAccountUsersInput = {
    update: XOR<AccountUpdateWithoutAccountUsersInput, AccountUncheckedUpdateWithoutAccountUsersInput>
    create: XOR<AccountCreateWithoutAccountUsersInput, AccountUncheckedCreateWithoutAccountUsersInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutAccountUsersInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutAccountUsersInput, AccountUncheckedUpdateWithoutAccountUsersInput>
  }

  export type AccountUpdateWithoutAccountUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: ClientEntityUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutAccountUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entities?: ClientEntityUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ProfileUpsertWithoutAccountUsersInput = {
    update: XOR<ProfileUpdateWithoutAccountUsersInput, ProfileUncheckedUpdateWithoutAccountUsersInput>
    create: XOR<ProfileCreateWithoutAccountUsersInput, ProfileUncheckedCreateWithoutAccountUsersInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutAccountUsersInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutAccountUsersInput, ProfileUncheckedUpdateWithoutAccountUsersInput>
  }

  export type ProfileUpdateWithoutAccountUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    staffProfile?: StaffProfileUpdateOneWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutAccountUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    fullName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staffProfile?: StaffProfileUncheckedUpdateOneWithoutProfileNestedInput
  }

  export type AccountCreateWithoutEntitiesInput = {
    id?: string
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountUsers?: AccountUserCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutEntitiesInput = {
    id?: string
    displayName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    accountUsers?: AccountUserUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutEntitiesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutEntitiesInput, AccountUncheckedCreateWithoutEntitiesInput>
  }

  export type EntityTaxYearCreateWithoutClientEntityInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutClientEntityInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutClientEntityInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutClientEntityInput, EntityTaxYearUncheckedCreateWithoutClientEntityInput>
  }

  export type EntityTaxYearCreateManyClientEntityInputEnvelope = {
    data: EntityTaxYearCreateManyClientEntityInput | EntityTaxYearCreateManyClientEntityInput[]
    skipDuplicates?: boolean
  }

  export type FolderCreateWithoutClientEntityInput = {
    id?: string
    name: string
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
    folderAcl?: FolderAclCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutClientEntityInput = {
    id?: string
    name: string
    parentId?: string | null
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutClientEntityInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutClientEntityInput, FolderUncheckedCreateWithoutClientEntityInput>
  }

  export type FolderCreateManyClientEntityInputEnvelope = {
    data: FolderCreateManyClientEntityInput | FolderCreateManyClientEntityInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutClientEntityInput = {
    id?: string
    storagePath: string
    displayName: string
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    folder?: FolderCreateNestedOneWithoutDocumentsInput
    uploader?: StaffProfileCreateNestedOneWithoutUploadedDocumentsInput
    checklistItems?: ChecklistItemFileCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutClientEntityInput = {
    id?: string
    folderId?: string | null
    storagePath: string
    displayName: string
    uploadedBy?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemFileUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutClientEntityInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutClientEntityInput, DocumentUncheckedCreateWithoutClientEntityInput>
  }

  export type DocumentCreateManyClientEntityInputEnvelope = {
    data: DocumentCreateManyClientEntityInput | DocumentCreateManyClientEntityInput[]
    skipDuplicates?: boolean
  }

  export type ClientAclCreateWithoutClientEntityInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffProfileCreateNestedOneWithoutClientAclInput
  }

  export type ClientAclUncheckedCreateWithoutClientEntityInput = {
    id?: string
    staffUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAclCreateOrConnectWithoutClientEntityInput = {
    where: ClientAclWhereUniqueInput
    create: XOR<ClientAclCreateWithoutClientEntityInput, ClientAclUncheckedCreateWithoutClientEntityInput>
  }

  export type ClientAclCreateManyClientEntityInputEnvelope = {
    data: ClientAclCreateManyClientEntityInput | ClientAclCreateManyClientEntityInput[]
    skipDuplicates?: boolean
  }

  export type ClientStaffPermissionCreateWithoutClientEntityInput = {
    id?: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffProfileCreateNestedOneWithoutClientStaffPermissionsInput
  }

  export type ClientStaffPermissionUncheckedCreateWithoutClientEntityInput = {
    id?: string
    staffUserId: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffPermissionCreateOrConnectWithoutClientEntityInput = {
    where: ClientStaffPermissionWhereUniqueInput
    create: XOR<ClientStaffPermissionCreateWithoutClientEntityInput, ClientStaffPermissionUncheckedCreateWithoutClientEntityInput>
  }

  export type ClientStaffPermissionCreateManyClientEntityInputEnvelope = {
    data: ClientStaffPermissionCreateManyClientEntityInput | ClientStaffPermissionCreateManyClientEntityInput[]
    skipDuplicates?: boolean
  }

  export type ClientStaffAssignmentCreateWithoutClientEntityInput = {
    id?: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffProfileCreateNestedOneWithoutClientStaffAssignmentsInput
  }

  export type ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput = {
    id?: string
    staffUserId: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffAssignmentCreateOrConnectWithoutClientEntityInput = {
    where: ClientStaffAssignmentWhereUniqueInput
    create: XOR<ClientStaffAssignmentCreateWithoutClientEntityInput, ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput>
  }

  export type ClientStaffAssignmentCreateManyClientEntityInputEnvelope = {
    data: ClientStaffAssignmentCreateManyClientEntityInput | ClientStaffAssignmentCreateManyClientEntityInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutEntitiesInput = {
    update: XOR<AccountUpdateWithoutEntitiesInput, AccountUncheckedUpdateWithoutEntitiesInput>
    create: XOR<AccountCreateWithoutEntitiesInput, AccountUncheckedCreateWithoutEntitiesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutEntitiesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutEntitiesInput, AccountUncheckedUpdateWithoutEntitiesInput>
  }

  export type AccountUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountUsers?: AccountUserUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutEntitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    accountUsers?: AccountUserUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type EntityTaxYearUpsertWithWhereUniqueWithoutClientEntityInput = {
    where: EntityTaxYearWhereUniqueInput
    update: XOR<EntityTaxYearUpdateWithoutClientEntityInput, EntityTaxYearUncheckedUpdateWithoutClientEntityInput>
    create: XOR<EntityTaxYearCreateWithoutClientEntityInput, EntityTaxYearUncheckedCreateWithoutClientEntityInput>
  }

  export type EntityTaxYearUpdateWithWhereUniqueWithoutClientEntityInput = {
    where: EntityTaxYearWhereUniqueInput
    data: XOR<EntityTaxYearUpdateWithoutClientEntityInput, EntityTaxYearUncheckedUpdateWithoutClientEntityInput>
  }

  export type EntityTaxYearUpdateManyWithWhereWithoutClientEntityInput = {
    where: EntityTaxYearScalarWhereInput
    data: XOR<EntityTaxYearUpdateManyMutationInput, EntityTaxYearUncheckedUpdateManyWithoutClientEntityInput>
  }

  export type EntityTaxYearScalarWhereInput = {
    AND?: EntityTaxYearScalarWhereInput | EntityTaxYearScalarWhereInput[]
    OR?: EntityTaxYearScalarWhereInput[]
    NOT?: EntityTaxYearScalarWhereInput | EntityTaxYearScalarWhereInput[]
    id?: StringFilter<"EntityTaxYear"> | string
    clientEntityId?: StringFilter<"EntityTaxYear"> | string
    taxYear?: IntFilter<"EntityTaxYear"> | number
    taxReturnExpected?: BoolFilter<"EntityTaxYear"> | boolean
    inviteStatus?: EnumInviteStatusFilter<"EntityTaxYear"> | $Enums.InviteStatus
    inviteSentAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    attemptCount?: IntFilter<"EntityTaxYear"> | number
    lastError?: StringNullableFilter<"EntityTaxYear"> | string | null
    engagementStatus?: EnumEngagementStatusFilter<"EntityTaxYear"> | $Enums.EngagementStatus
    engagementSignedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    engagementSigner1Id?: StringNullableFilter<"EntityTaxYear"> | string | null
    engagementSigner2Id?: StringNullableFilter<"EntityTaxYear"> | string | null
    docsRequiredCount?: IntFilter<"EntityTaxYear"> | number
    docsReceivedCount?: IntFilter<"EntityTaxYear"> | number
    checklistCompleteAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFilter<"EntityTaxYear"> | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    docConfirmationSignerId?: StringNullableFilter<"EntityTaxYear"> | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFilter<"EntityTaxYear"> | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    idStatus?: EnumIdStatusFilter<"EntityTaxYear"> | $Enums.IdStatus
    idValidUntil?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    readyForPrep?: BoolFilter<"EntityTaxYear"> | boolean
    extensionRequested?: BoolFilter<"EntityTaxYear"> | boolean
    extensionFiled?: BoolFilter<"EntityTaxYear"> | boolean
    extendedDueDate?: DateTimeNullableFilter<"EntityTaxYear"> | Date | string | null
    internalStatus?: EnumInternalStatusFilter<"EntityTaxYear"> | $Enums.InternalStatus
    createdAt?: DateTimeFilter<"EntityTaxYear"> | Date | string
    updatedAt?: DateTimeFilter<"EntityTaxYear"> | Date | string
  }

  export type FolderUpsertWithWhereUniqueWithoutClientEntityInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutClientEntityInput, FolderUncheckedUpdateWithoutClientEntityInput>
    create: XOR<FolderCreateWithoutClientEntityInput, FolderUncheckedCreateWithoutClientEntityInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutClientEntityInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutClientEntityInput, FolderUncheckedUpdateWithoutClientEntityInput>
  }

  export type FolderUpdateManyWithWhereWithoutClientEntityInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutClientEntityInput>
  }

  export type FolderScalarWhereInput = {
    AND?: FolderScalarWhereInput | FolderScalarWhereInput[]
    OR?: FolderScalarWhereInput[]
    NOT?: FolderScalarWhereInput | FolderScalarWhereInput[]
    id?: StringFilter<"Folder"> | string
    clientId?: StringFilter<"Folder"> | string
    name?: StringFilter<"Folder"> | string
    parentId?: StringNullableFilter<"Folder"> | string | null
    folderType?: StringNullableFilter<"Folder"> | string | null
    isSystem?: BoolFilter<"Folder"> | boolean
    clientVisible?: BoolFilter<"Folder"> | boolean
    staffOnly?: BoolFilter<"Folder"> | boolean
    adminOnly?: BoolFilter<"Folder"> | boolean
    superAdminOnly?: BoolFilter<"Folder"> | boolean
    restrictedAcl?: BoolFilter<"Folder"> | boolean
    createdAt?: DateTimeFilter<"Folder"> | Date | string
    updatedAt?: DateTimeFilter<"Folder"> | Date | string
  }

  export type DocumentUpsertWithWhereUniqueWithoutClientEntityInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutClientEntityInput, DocumentUncheckedUpdateWithoutClientEntityInput>
    create: XOR<DocumentCreateWithoutClientEntityInput, DocumentUncheckedCreateWithoutClientEntityInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutClientEntityInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutClientEntityInput, DocumentUncheckedUpdateWithoutClientEntityInput>
  }

  export type DocumentUpdateManyWithWhereWithoutClientEntityInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutClientEntityInput>
  }

  export type ClientAclUpsertWithWhereUniqueWithoutClientEntityInput = {
    where: ClientAclWhereUniqueInput
    update: XOR<ClientAclUpdateWithoutClientEntityInput, ClientAclUncheckedUpdateWithoutClientEntityInput>
    create: XOR<ClientAclCreateWithoutClientEntityInput, ClientAclUncheckedCreateWithoutClientEntityInput>
  }

  export type ClientAclUpdateWithWhereUniqueWithoutClientEntityInput = {
    where: ClientAclWhereUniqueInput
    data: XOR<ClientAclUpdateWithoutClientEntityInput, ClientAclUncheckedUpdateWithoutClientEntityInput>
  }

  export type ClientAclUpdateManyWithWhereWithoutClientEntityInput = {
    where: ClientAclScalarWhereInput
    data: XOR<ClientAclUpdateManyMutationInput, ClientAclUncheckedUpdateManyWithoutClientEntityInput>
  }

  export type ClientStaffPermissionUpsertWithWhereUniqueWithoutClientEntityInput = {
    where: ClientStaffPermissionWhereUniqueInput
    update: XOR<ClientStaffPermissionUpdateWithoutClientEntityInput, ClientStaffPermissionUncheckedUpdateWithoutClientEntityInput>
    create: XOR<ClientStaffPermissionCreateWithoutClientEntityInput, ClientStaffPermissionUncheckedCreateWithoutClientEntityInput>
  }

  export type ClientStaffPermissionUpdateWithWhereUniqueWithoutClientEntityInput = {
    where: ClientStaffPermissionWhereUniqueInput
    data: XOR<ClientStaffPermissionUpdateWithoutClientEntityInput, ClientStaffPermissionUncheckedUpdateWithoutClientEntityInput>
  }

  export type ClientStaffPermissionUpdateManyWithWhereWithoutClientEntityInput = {
    where: ClientStaffPermissionScalarWhereInput
    data: XOR<ClientStaffPermissionUpdateManyMutationInput, ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityInput>
  }

  export type ClientStaffAssignmentUpsertWithWhereUniqueWithoutClientEntityInput = {
    where: ClientStaffAssignmentWhereUniqueInput
    update: XOR<ClientStaffAssignmentUpdateWithoutClientEntityInput, ClientStaffAssignmentUncheckedUpdateWithoutClientEntityInput>
    create: XOR<ClientStaffAssignmentCreateWithoutClientEntityInput, ClientStaffAssignmentUncheckedCreateWithoutClientEntityInput>
  }

  export type ClientStaffAssignmentUpdateWithWhereUniqueWithoutClientEntityInput = {
    where: ClientStaffAssignmentWhereUniqueInput
    data: XOR<ClientStaffAssignmentUpdateWithoutClientEntityInput, ClientStaffAssignmentUncheckedUpdateWithoutClientEntityInput>
  }

  export type ClientStaffAssignmentUpdateManyWithWhereWithoutClientEntityInput = {
    where: ClientStaffAssignmentScalarWhereInput
    data: XOR<ClientStaffAssignmentUpdateManyMutationInput, ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityInput>
  }

  export type ClientEntityCreateWithoutEntityTaxYearsInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutEntitiesInput
    folders?: FolderCreateNestedManyWithoutClientEntityInput
    documents?: DocumentCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUncheckedCreateWithoutEntityTaxYearsInput = {
    id?: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    folders?: FolderUncheckedCreateNestedManyWithoutClientEntityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityCreateOrConnectWithoutEntityTaxYearsInput = {
    where: ClientEntityWhereUniqueInput
    create: XOR<ClientEntityCreateWithoutEntityTaxYearsInput, ClientEntityUncheckedCreateWithoutEntityTaxYearsInput>
  }

  export type ChecklistItemCreateWithoutEntityTaxYearInput = {
    id?: string
    itemName: string
    itemType?: string | null
    required?: boolean
    status?: $Enums.ChecklistItemStatus
    receivedAt?: Date | string | null
    markedNotApplicableAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: ChecklistItemFileCreateNestedManyWithoutChecklistItemInput
  }

  export type ChecklistItemUncheckedCreateWithoutEntityTaxYearInput = {
    id?: string
    itemName: string
    itemType?: string | null
    required?: boolean
    status?: $Enums.ChecklistItemStatus
    receivedAt?: Date | string | null
    markedNotApplicableAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    files?: ChecklistItemFileUncheckedCreateNestedManyWithoutChecklistItemInput
  }

  export type ChecklistItemCreateOrConnectWithoutEntityTaxYearInput = {
    where: ChecklistItemWhereUniqueInput
    create: XOR<ChecklistItemCreateWithoutEntityTaxYearInput, ChecklistItemUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type ChecklistItemCreateManyEntityTaxYearInputEnvelope = {
    data: ChecklistItemCreateManyEntityTaxYearInput | ChecklistItemCreateManyEntityTaxYearInput[]
    skipDuplicates?: boolean
  }

  export type QuestionnaireAnswerCreateWithoutEntityTaxYearInput = {
    id?: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    question: QuestionnaireQuestionCreateNestedOneWithoutAnswersInput
  }

  export type QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput = {
    id?: string
    questionId: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireAnswerCreateOrConnectWithoutEntityTaxYearInput = {
    where: QuestionnaireAnswerWhereUniqueInput
    create: XOR<QuestionnaireAnswerCreateWithoutEntityTaxYearInput, QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type QuestionnaireAnswerCreateManyEntityTaxYearInputEnvelope = {
    data: QuestionnaireAnswerCreateManyEntityTaxYearInput | QuestionnaireAnswerCreateManyEntityTaxYearInput[]
    skipDuplicates?: boolean
  }

  export type MessageThreadCreateWithoutEntityTaxYearInput = {
    id?: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ThreadParticipantCreateNestedManyWithoutThreadInput
    messages?: MessageCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateWithoutEntityTaxYearInput = {
    id?: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ThreadParticipantUncheckedCreateNestedManyWithoutThreadInput
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadCreateOrConnectWithoutEntityTaxYearInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutEntityTaxYearInput, MessageThreadUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type ReminderStateCreateWithoutEntityTaxYearInput = {
    id?: string
    reminderType: $Enums.ReminderType
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    reminderCount?: number
    paused?: boolean
    pausedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderStateUncheckedCreateWithoutEntityTaxYearInput = {
    id?: string
    reminderType: $Enums.ReminderType
    nextReminderAt?: Date | string | null
    lastReminderAt?: Date | string | null
    reminderCount?: number
    paused?: boolean
    pausedReason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReminderStateCreateOrConnectWithoutEntityTaxYearInput = {
    where: ReminderStateWhereUniqueInput
    create: XOR<ReminderStateCreateWithoutEntityTaxYearInput, ReminderStateUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type StatusAuditLogCreateWithoutEntityTaxYearInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    reason?: string | null
    createdAt?: Date | string
    staff: StaffProfileCreateNestedOneWithoutStatusAuditLogsInput
  }

  export type StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    changedBy: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type StatusAuditLogCreateOrConnectWithoutEntityTaxYearInput = {
    where: StatusAuditLogWhereUniqueInput
    create: XOR<StatusAuditLogCreateWithoutEntityTaxYearInput, StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type StatusAuditLogCreateManyEntityTaxYearInputEnvelope = {
    data: StatusAuditLogCreateManyEntityTaxYearInput | StatusAuditLogCreateManyEntityTaxYearInput[]
    skipDuplicates?: boolean
  }

  export type DocumentEventCreateWithoutEntityTaxYearInput = {
    id?: string
    eventType: $Enums.DocumentEventType
    documentId?: string | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type DocumentEventUncheckedCreateWithoutEntityTaxYearInput = {
    id?: string
    eventType: $Enums.DocumentEventType
    documentId?: string | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type DocumentEventCreateOrConnectWithoutEntityTaxYearInput = {
    where: DocumentEventWhereUniqueInput
    create: XOR<DocumentEventCreateWithoutEntityTaxYearInput, DocumentEventUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type DocumentEventCreateManyEntityTaxYearInputEnvelope = {
    data: DocumentEventCreateManyEntityTaxYearInput | DocumentEventCreateManyEntityTaxYearInput[]
    skipDuplicates?: boolean
  }

  export type EngagementSignatureCreateWithoutEntityTaxYearInput = {
    id?: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput = {
    id?: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EngagementSignatureCreateOrConnectWithoutEntityTaxYearInput = {
    where: EngagementSignatureWhereUniqueInput
    create: XOR<EngagementSignatureCreateWithoutEntityTaxYearInput, EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type EngagementSignatureCreateManyEntityTaxYearInputEnvelope = {
    data: EngagementSignatureCreateManyEntityTaxYearInput | EngagementSignatureCreateManyEntityTaxYearInput[]
    skipDuplicates?: boolean
  }

  export type EfileAuthorizationCreateWithoutEntityTaxYearInput = {
    id?: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput = {
    id?: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EfileAuthorizationCreateOrConnectWithoutEntityTaxYearInput = {
    where: EfileAuthorizationWhereUniqueInput
    create: XOR<EfileAuthorizationCreateWithoutEntityTaxYearInput, EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type EfileAuthorizationCreateManyEntityTaxYearInputEnvelope = {
    data: EfileAuthorizationCreateManyEntityTaxYearInput | EfileAuthorizationCreateManyEntityTaxYearInput[]
    skipDuplicates?: boolean
  }

  export type ClientEntityUpsertWithoutEntityTaxYearsInput = {
    update: XOR<ClientEntityUpdateWithoutEntityTaxYearsInput, ClientEntityUncheckedUpdateWithoutEntityTaxYearsInput>
    create: XOR<ClientEntityCreateWithoutEntityTaxYearsInput, ClientEntityUncheckedCreateWithoutEntityTaxYearsInput>
    where?: ClientEntityWhereInput
  }

  export type ClientEntityUpdateToOneWithWhereWithoutEntityTaxYearsInput = {
    where?: ClientEntityWhereInput
    data: XOR<ClientEntityUpdateWithoutEntityTaxYearsInput, ClientEntityUncheckedUpdateWithoutEntityTaxYearsInput>
  }

  export type ClientEntityUpdateWithoutEntityTaxYearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntitiesNestedInput
    folders?: FolderUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateWithoutEntityTaxYearsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folders?: FolderUncheckedUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityNestedInput
  }

  export type ChecklistItemUpsertWithWhereUniqueWithoutEntityTaxYearInput = {
    where: ChecklistItemWhereUniqueInput
    update: XOR<ChecklistItemUpdateWithoutEntityTaxYearInput, ChecklistItemUncheckedUpdateWithoutEntityTaxYearInput>
    create: XOR<ChecklistItemCreateWithoutEntityTaxYearInput, ChecklistItemUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type ChecklistItemUpdateWithWhereUniqueWithoutEntityTaxYearInput = {
    where: ChecklistItemWhereUniqueInput
    data: XOR<ChecklistItemUpdateWithoutEntityTaxYearInput, ChecklistItemUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type ChecklistItemUpdateManyWithWhereWithoutEntityTaxYearInput = {
    where: ChecklistItemScalarWhereInput
    data: XOR<ChecklistItemUpdateManyMutationInput, ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearInput>
  }

  export type ChecklistItemScalarWhereInput = {
    AND?: ChecklistItemScalarWhereInput | ChecklistItemScalarWhereInput[]
    OR?: ChecklistItemScalarWhereInput[]
    NOT?: ChecklistItemScalarWhereInput | ChecklistItemScalarWhereInput[]
    id?: StringFilter<"ChecklistItem"> | string
    entityTaxYearId?: StringFilter<"ChecklistItem"> | string
    itemName?: StringFilter<"ChecklistItem"> | string
    itemType?: StringNullableFilter<"ChecklistItem"> | string | null
    required?: BoolFilter<"ChecklistItem"> | boolean
    status?: EnumChecklistItemStatusFilter<"ChecklistItem"> | $Enums.ChecklistItemStatus
    receivedAt?: DateTimeNullableFilter<"ChecklistItem"> | Date | string | null
    markedNotApplicableAt?: DateTimeNullableFilter<"ChecklistItem"> | Date | string | null
    notes?: StringNullableFilter<"ChecklistItem"> | string | null
    createdAt?: DateTimeFilter<"ChecklistItem"> | Date | string
    updatedAt?: DateTimeFilter<"ChecklistItem"> | Date | string
  }

  export type QuestionnaireAnswerUpsertWithWhereUniqueWithoutEntityTaxYearInput = {
    where: QuestionnaireAnswerWhereUniqueInput
    update: XOR<QuestionnaireAnswerUpdateWithoutEntityTaxYearInput, QuestionnaireAnswerUncheckedUpdateWithoutEntityTaxYearInput>
    create: XOR<QuestionnaireAnswerCreateWithoutEntityTaxYearInput, QuestionnaireAnswerUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type QuestionnaireAnswerUpdateWithWhereUniqueWithoutEntityTaxYearInput = {
    where: QuestionnaireAnswerWhereUniqueInput
    data: XOR<QuestionnaireAnswerUpdateWithoutEntityTaxYearInput, QuestionnaireAnswerUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type QuestionnaireAnswerUpdateManyWithWhereWithoutEntityTaxYearInput = {
    where: QuestionnaireAnswerScalarWhereInput
    data: XOR<QuestionnaireAnswerUpdateManyMutationInput, QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearInput>
  }

  export type QuestionnaireAnswerScalarWhereInput = {
    AND?: QuestionnaireAnswerScalarWhereInput | QuestionnaireAnswerScalarWhereInput[]
    OR?: QuestionnaireAnswerScalarWhereInput[]
    NOT?: QuestionnaireAnswerScalarWhereInput | QuestionnaireAnswerScalarWhereInput[]
    id?: StringFilter<"QuestionnaireAnswer"> | string
    entityTaxYearId?: StringFilter<"QuestionnaireAnswer"> | string
    questionId?: StringFilter<"QuestionnaireAnswer"> | string
    answerValue?: StringNullableFilter<"QuestionnaireAnswer"> | string | null
    createdAt?: DateTimeFilter<"QuestionnaireAnswer"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireAnswer"> | Date | string
  }

  export type MessageThreadUpsertWithoutEntityTaxYearInput = {
    update: XOR<MessageThreadUpdateWithoutEntityTaxYearInput, MessageThreadUncheckedUpdateWithoutEntityTaxYearInput>
    create: XOR<MessageThreadCreateWithoutEntityTaxYearInput, MessageThreadUncheckedCreateWithoutEntityTaxYearInput>
    where?: MessageThreadWhereInput
  }

  export type MessageThreadUpdateToOneWithWhereWithoutEntityTaxYearInput = {
    where?: MessageThreadWhereInput
    data: XOR<MessageThreadUpdateWithoutEntityTaxYearInput, MessageThreadUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type MessageThreadUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ThreadParticipantUpdateManyWithoutThreadNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ThreadParticipantUncheckedUpdateManyWithoutThreadNestedInput
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type ReminderStateUpsertWithoutEntityTaxYearInput = {
    update: XOR<ReminderStateUpdateWithoutEntityTaxYearInput, ReminderStateUncheckedUpdateWithoutEntityTaxYearInput>
    create: XOR<ReminderStateCreateWithoutEntityTaxYearInput, ReminderStateUncheckedCreateWithoutEntityTaxYearInput>
    where?: ReminderStateWhereInput
  }

  export type ReminderStateUpdateToOneWithWhereWithoutEntityTaxYearInput = {
    where?: ReminderStateWhereInput
    data: XOR<ReminderStateUpdateWithoutEntityTaxYearInput, ReminderStateUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type ReminderStateUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderCount?: IntFieldUpdateOperationsInput | number
    paused?: BoolFieldUpdateOperationsInput | boolean
    pausedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReminderStateUncheckedUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    reminderType?: EnumReminderTypeFieldUpdateOperationsInput | $Enums.ReminderType
    nextReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastReminderAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderCount?: IntFieldUpdateOperationsInput | number
    paused?: BoolFieldUpdateOperationsInput | boolean
    pausedReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAuditLogUpsertWithWhereUniqueWithoutEntityTaxYearInput = {
    where: StatusAuditLogWhereUniqueInput
    update: XOR<StatusAuditLogUpdateWithoutEntityTaxYearInput, StatusAuditLogUncheckedUpdateWithoutEntityTaxYearInput>
    create: XOR<StatusAuditLogCreateWithoutEntityTaxYearInput, StatusAuditLogUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type StatusAuditLogUpdateWithWhereUniqueWithoutEntityTaxYearInput = {
    where: StatusAuditLogWhereUniqueInput
    data: XOR<StatusAuditLogUpdateWithoutEntityTaxYearInput, StatusAuditLogUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type StatusAuditLogUpdateManyWithWhereWithoutEntityTaxYearInput = {
    where: StatusAuditLogScalarWhereInput
    data: XOR<StatusAuditLogUpdateManyMutationInput, StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearInput>
  }

  export type DocumentEventUpsertWithWhereUniqueWithoutEntityTaxYearInput = {
    where: DocumentEventWhereUniqueInput
    update: XOR<DocumentEventUpdateWithoutEntityTaxYearInput, DocumentEventUncheckedUpdateWithoutEntityTaxYearInput>
    create: XOR<DocumentEventCreateWithoutEntityTaxYearInput, DocumentEventUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type DocumentEventUpdateWithWhereUniqueWithoutEntityTaxYearInput = {
    where: DocumentEventWhereUniqueInput
    data: XOR<DocumentEventUpdateWithoutEntityTaxYearInput, DocumentEventUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type DocumentEventUpdateManyWithWhereWithoutEntityTaxYearInput = {
    where: DocumentEventScalarWhereInput
    data: XOR<DocumentEventUpdateManyMutationInput, DocumentEventUncheckedUpdateManyWithoutEntityTaxYearInput>
  }

  export type DocumentEventScalarWhereInput = {
    AND?: DocumentEventScalarWhereInput | DocumentEventScalarWhereInput[]
    OR?: DocumentEventScalarWhereInput[]
    NOT?: DocumentEventScalarWhereInput | DocumentEventScalarWhereInput[]
    id?: StringFilter<"DocumentEvent"> | string
    entityTaxYearId?: StringFilter<"DocumentEvent"> | string
    eventType?: EnumDocumentEventTypeFilter<"DocumentEvent"> | $Enums.DocumentEventType
    documentId?: StringNullableFilter<"DocumentEvent"> | string | null
    description?: StringNullableFilter<"DocumentEvent"> | string | null
    metadata?: StringNullableFilter<"DocumentEvent"> | string | null
    createdAt?: DateTimeFilter<"DocumentEvent"> | Date | string
  }

  export type EngagementSignatureUpsertWithWhereUniqueWithoutEntityTaxYearInput = {
    where: EngagementSignatureWhereUniqueInput
    update: XOR<EngagementSignatureUpdateWithoutEntityTaxYearInput, EngagementSignatureUncheckedUpdateWithoutEntityTaxYearInput>
    create: XOR<EngagementSignatureCreateWithoutEntityTaxYearInput, EngagementSignatureUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type EngagementSignatureUpdateWithWhereUniqueWithoutEntityTaxYearInput = {
    where: EngagementSignatureWhereUniqueInput
    data: XOR<EngagementSignatureUpdateWithoutEntityTaxYearInput, EngagementSignatureUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type EngagementSignatureUpdateManyWithWhereWithoutEntityTaxYearInput = {
    where: EngagementSignatureScalarWhereInput
    data: XOR<EngagementSignatureUpdateManyMutationInput, EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearInput>
  }

  export type EngagementSignatureScalarWhereInput = {
    AND?: EngagementSignatureScalarWhereInput | EngagementSignatureScalarWhereInput[]
    OR?: EngagementSignatureScalarWhereInput[]
    NOT?: EngagementSignatureScalarWhereInput | EngagementSignatureScalarWhereInput[]
    id?: StringFilter<"EngagementSignature"> | string
    entityTaxYearId?: StringFilter<"EngagementSignature"> | string
    signerName?: StringFilter<"EngagementSignature"> | string
    signerEmail?: StringFilter<"EngagementSignature"> | string
    signatureData?: StringFilter<"EngagementSignature"> | string
    signedAt?: DateTimeFilter<"EngagementSignature"> | Date | string
  }

  export type EfileAuthorizationUpsertWithWhereUniqueWithoutEntityTaxYearInput = {
    where: EfileAuthorizationWhereUniqueInput
    update: XOR<EfileAuthorizationUpdateWithoutEntityTaxYearInput, EfileAuthorizationUncheckedUpdateWithoutEntityTaxYearInput>
    create: XOR<EfileAuthorizationCreateWithoutEntityTaxYearInput, EfileAuthorizationUncheckedCreateWithoutEntityTaxYearInput>
  }

  export type EfileAuthorizationUpdateWithWhereUniqueWithoutEntityTaxYearInput = {
    where: EfileAuthorizationWhereUniqueInput
    data: XOR<EfileAuthorizationUpdateWithoutEntityTaxYearInput, EfileAuthorizationUncheckedUpdateWithoutEntityTaxYearInput>
  }

  export type EfileAuthorizationUpdateManyWithWhereWithoutEntityTaxYearInput = {
    where: EfileAuthorizationScalarWhereInput
    data: XOR<EfileAuthorizationUpdateManyMutationInput, EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearInput>
  }

  export type EfileAuthorizationScalarWhereInput = {
    AND?: EfileAuthorizationScalarWhereInput | EfileAuthorizationScalarWhereInput[]
    OR?: EfileAuthorizationScalarWhereInput[]
    NOT?: EfileAuthorizationScalarWhereInput | EfileAuthorizationScalarWhereInput[]
    id?: StringFilter<"EfileAuthorization"> | string
    entityTaxYearId?: StringFilter<"EfileAuthorization"> | string
    signerName?: StringFilter<"EfileAuthorization"> | string
    signerEmail?: StringFilter<"EfileAuthorization"> | string
    signatureData?: StringFilter<"EfileAuthorization"> | string
    signedAt?: DateTimeFilter<"EfileAuthorization"> | Date | string
  }

  export type ClientEntityCreateWithoutClientAclInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutEntitiesInput
    entityTaxYears?: EntityTaxYearCreateNestedManyWithoutClientEntityInput
    folders?: FolderCreateNestedManyWithoutClientEntityInput
    documents?: DocumentCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUncheckedCreateWithoutClientAclInput = {
    id?: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYears?: EntityTaxYearUncheckedCreateNestedManyWithoutClientEntityInput
    folders?: FolderUncheckedCreateNestedManyWithoutClientEntityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityCreateOrConnectWithoutClientAclInput = {
    where: ClientEntityWhereUniqueInput
    create: XOR<ClientEntityCreateWithoutClientAclInput, ClientEntityUncheckedCreateWithoutClientAclInput>
  }

  export type StaffProfileCreateWithoutClientAclInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutClientAclInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutClientAclInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutClientAclInput, StaffProfileUncheckedCreateWithoutClientAclInput>
  }

  export type ClientEntityUpsertWithoutClientAclInput = {
    update: XOR<ClientEntityUpdateWithoutClientAclInput, ClientEntityUncheckedUpdateWithoutClientAclInput>
    create: XOR<ClientEntityCreateWithoutClientAclInput, ClientEntityUncheckedCreateWithoutClientAclInput>
    where?: ClientEntityWhereInput
  }

  export type ClientEntityUpdateToOneWithWhereWithoutClientAclInput = {
    where?: ClientEntityWhereInput
    data: XOR<ClientEntityUpdateWithoutClientAclInput, ClientEntityUncheckedUpdateWithoutClientAclInput>
  }

  export type ClientEntityUpdateWithoutClientAclInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntitiesNestedInput
    entityTaxYears?: EntityTaxYearUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateWithoutClientAclInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYears?: EntityTaxYearUncheckedUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUncheckedUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityNestedInput
  }

  export type StaffProfileUpsertWithoutClientAclInput = {
    update: XOR<StaffProfileUpdateWithoutClientAclInput, StaffProfileUncheckedUpdateWithoutClientAclInput>
    create: XOR<StaffProfileCreateWithoutClientAclInput, StaffProfileUncheckedCreateWithoutClientAclInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutClientAclInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutClientAclInput, StaffProfileUncheckedUpdateWithoutClientAclInput>
  }

  export type StaffProfileUpdateWithoutClientAclInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutClientAclInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ClientEntityCreateWithoutClientStaffPermissionsInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutEntitiesInput
    entityTaxYears?: EntityTaxYearCreateNestedManyWithoutClientEntityInput
    folders?: FolderCreateNestedManyWithoutClientEntityInput
    documents?: DocumentCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUncheckedCreateWithoutClientStaffPermissionsInput = {
    id?: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYears?: EntityTaxYearUncheckedCreateNestedManyWithoutClientEntityInput
    folders?: FolderUncheckedCreateNestedManyWithoutClientEntityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityCreateOrConnectWithoutClientStaffPermissionsInput = {
    where: ClientEntityWhereUniqueInput
    create: XOR<ClientEntityCreateWithoutClientStaffPermissionsInput, ClientEntityUncheckedCreateWithoutClientStaffPermissionsInput>
  }

  export type StaffProfileCreateWithoutClientStaffPermissionsInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutClientStaffPermissionsInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutClientStaffPermissionsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutClientStaffPermissionsInput, StaffProfileUncheckedCreateWithoutClientStaffPermissionsInput>
  }

  export type ClientEntityUpsertWithoutClientStaffPermissionsInput = {
    update: XOR<ClientEntityUpdateWithoutClientStaffPermissionsInput, ClientEntityUncheckedUpdateWithoutClientStaffPermissionsInput>
    create: XOR<ClientEntityCreateWithoutClientStaffPermissionsInput, ClientEntityUncheckedCreateWithoutClientStaffPermissionsInput>
    where?: ClientEntityWhereInput
  }

  export type ClientEntityUpdateToOneWithWhereWithoutClientStaffPermissionsInput = {
    where?: ClientEntityWhereInput
    data: XOR<ClientEntityUpdateWithoutClientStaffPermissionsInput, ClientEntityUncheckedUpdateWithoutClientStaffPermissionsInput>
  }

  export type ClientEntityUpdateWithoutClientStaffPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntitiesNestedInput
    entityTaxYears?: EntityTaxYearUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateWithoutClientStaffPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYears?: EntityTaxYearUncheckedUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUncheckedUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityNestedInput
  }

  export type StaffProfileUpsertWithoutClientStaffPermissionsInput = {
    update: XOR<StaffProfileUpdateWithoutClientStaffPermissionsInput, StaffProfileUncheckedUpdateWithoutClientStaffPermissionsInput>
    create: XOR<StaffProfileCreateWithoutClientStaffPermissionsInput, StaffProfileUncheckedCreateWithoutClientStaffPermissionsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutClientStaffPermissionsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutClientStaffPermissionsInput, StaffProfileUncheckedUpdateWithoutClientStaffPermissionsInput>
  }

  export type StaffProfileUpdateWithoutClientStaffPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutClientStaffPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ClientEntityCreateWithoutClientStaffAssignmentsInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutEntitiesInput
    entityTaxYears?: EntityTaxYearCreateNestedManyWithoutClientEntityInput
    folders?: FolderCreateNestedManyWithoutClientEntityInput
    documents?: DocumentCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUncheckedCreateWithoutClientStaffAssignmentsInput = {
    id?: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYears?: EntityTaxYearUncheckedCreateNestedManyWithoutClientEntityInput
    folders?: FolderUncheckedCreateNestedManyWithoutClientEntityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityCreateOrConnectWithoutClientStaffAssignmentsInput = {
    where: ClientEntityWhereUniqueInput
    create: XOR<ClientEntityCreateWithoutClientStaffAssignmentsInput, ClientEntityUncheckedCreateWithoutClientStaffAssignmentsInput>
  }

  export type StaffProfileCreateWithoutClientStaffAssignmentsInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutClientStaffAssignmentsInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutClientStaffAssignmentsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutClientStaffAssignmentsInput, StaffProfileUncheckedCreateWithoutClientStaffAssignmentsInput>
  }

  export type ClientEntityUpsertWithoutClientStaffAssignmentsInput = {
    update: XOR<ClientEntityUpdateWithoutClientStaffAssignmentsInput, ClientEntityUncheckedUpdateWithoutClientStaffAssignmentsInput>
    create: XOR<ClientEntityCreateWithoutClientStaffAssignmentsInput, ClientEntityUncheckedCreateWithoutClientStaffAssignmentsInput>
    where?: ClientEntityWhereInput
  }

  export type ClientEntityUpdateToOneWithWhereWithoutClientStaffAssignmentsInput = {
    where?: ClientEntityWhereInput
    data: XOR<ClientEntityUpdateWithoutClientStaffAssignmentsInput, ClientEntityUncheckedUpdateWithoutClientStaffAssignmentsInput>
  }

  export type ClientEntityUpdateWithoutClientStaffAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntitiesNestedInput
    entityTaxYears?: EntityTaxYearUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateWithoutClientStaffAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYears?: EntityTaxYearUncheckedUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUncheckedUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityNestedInput
  }

  export type StaffProfileUpsertWithoutClientStaffAssignmentsInput = {
    update: XOR<StaffProfileUpdateWithoutClientStaffAssignmentsInput, StaffProfileUncheckedUpdateWithoutClientStaffAssignmentsInput>
    create: XOR<StaffProfileCreateWithoutClientStaffAssignmentsInput, StaffProfileUncheckedCreateWithoutClientStaffAssignmentsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutClientStaffAssignmentsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutClientStaffAssignmentsInput, StaffProfileUncheckedUpdateWithoutClientStaffAssignmentsInput>
  }

  export type StaffProfileUpdateWithoutClientStaffAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutClientStaffAssignmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ClientEntityCreateWithoutFoldersInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutEntitiesInput
    entityTaxYears?: EntityTaxYearCreateNestedManyWithoutClientEntityInput
    documents?: DocumentCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUncheckedCreateWithoutFoldersInput = {
    id?: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYears?: EntityTaxYearUncheckedCreateNestedManyWithoutClientEntityInput
    documents?: DocumentUncheckedCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityCreateOrConnectWithoutFoldersInput = {
    where: ClientEntityWhereUniqueInput
    create: XOR<ClientEntityCreateWithoutFoldersInput, ClientEntityUncheckedCreateWithoutFoldersInput>
  }

  export type FolderCreateWithoutChildrenInput = {
    id?: string
    name: string
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutFoldersInput
    parent?: FolderCreateNestedOneWithoutChildrenInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
    folderAcl?: FolderAclCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutChildrenInput = {
    id?: string
    clientId: string
    name: string
    parentId?: string | null
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutChildrenInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
  }

  export type FolderCreateWithoutParentInput = {
    id?: string
    name: string
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutFoldersInput
    children?: FolderCreateNestedManyWithoutParentInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
    folderAcl?: FolderAclCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutParentInput = {
    id?: string
    clientId: string
    name: string
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutParentInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderCreateManyParentInputEnvelope = {
    data: FolderCreateManyParentInput | FolderCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type DocumentCreateWithoutFolderInput = {
    id?: string
    storagePath: string
    displayName: string
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutDocumentsInput
    uploader?: StaffProfileCreateNestedOneWithoutUploadedDocumentsInput
    checklistItems?: ChecklistItemFileCreateNestedManyWithoutDocumentInput
  }

  export type DocumentUncheckedCreateWithoutFolderInput = {
    id?: string
    clientId: string
    storagePath: string
    displayName: string
    uploadedBy?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemFileUncheckedCreateNestedManyWithoutDocumentInput
  }

  export type DocumentCreateOrConnectWithoutFolderInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput>
  }

  export type DocumentCreateManyFolderInputEnvelope = {
    data: DocumentCreateManyFolderInput | DocumentCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type FolderAclCreateWithoutFolderInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    staff: StaffProfileCreateNestedOneWithoutFolderAclInput
  }

  export type FolderAclUncheckedCreateWithoutFolderInput = {
    id?: string
    staffUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderAclCreateOrConnectWithoutFolderInput = {
    where: FolderAclWhereUniqueInput
    create: XOR<FolderAclCreateWithoutFolderInput, FolderAclUncheckedCreateWithoutFolderInput>
  }

  export type FolderAclCreateManyFolderInputEnvelope = {
    data: FolderAclCreateManyFolderInput | FolderAclCreateManyFolderInput[]
    skipDuplicates?: boolean
  }

  export type ClientEntityUpsertWithoutFoldersInput = {
    update: XOR<ClientEntityUpdateWithoutFoldersInput, ClientEntityUncheckedUpdateWithoutFoldersInput>
    create: XOR<ClientEntityCreateWithoutFoldersInput, ClientEntityUncheckedCreateWithoutFoldersInput>
    where?: ClientEntityWhereInput
  }

  export type ClientEntityUpdateToOneWithWhereWithoutFoldersInput = {
    where?: ClientEntityWhereInput
    data: XOR<ClientEntityUpdateWithoutFoldersInput, ClientEntityUncheckedUpdateWithoutFoldersInput>
  }

  export type ClientEntityUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntitiesNestedInput
    entityTaxYears?: EntityTaxYearUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateWithoutFoldersInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYears?: EntityTaxYearUncheckedUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityNestedInput
  }

  export type FolderUpsertWithoutChildrenInput = {
    update: XOR<FolderUpdateWithoutChildrenInput, FolderUncheckedUpdateWithoutChildrenInput>
    create: XOR<FolderCreateWithoutChildrenInput, FolderUncheckedCreateWithoutChildrenInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutChildrenInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutChildrenInput, FolderUncheckedUpdateWithoutChildrenInput>
  }

  export type FolderUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutFoldersNestedInput
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
    folderAcl?: FolderAclUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUpsertWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    update: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
    create: XOR<FolderCreateWithoutParentInput, FolderUncheckedCreateWithoutParentInput>
  }

  export type FolderUpdateWithWhereUniqueWithoutParentInput = {
    where: FolderWhereUniqueInput
    data: XOR<FolderUpdateWithoutParentInput, FolderUncheckedUpdateWithoutParentInput>
  }

  export type FolderUpdateManyWithWhereWithoutParentInput = {
    where: FolderScalarWhereInput
    data: XOR<FolderUpdateManyMutationInput, FolderUncheckedUpdateManyWithoutParentInput>
  }

  export type DocumentUpsertWithWhereUniqueWithoutFolderInput = {
    where: DocumentWhereUniqueInput
    update: XOR<DocumentUpdateWithoutFolderInput, DocumentUncheckedUpdateWithoutFolderInput>
    create: XOR<DocumentCreateWithoutFolderInput, DocumentUncheckedCreateWithoutFolderInput>
  }

  export type DocumentUpdateWithWhereUniqueWithoutFolderInput = {
    where: DocumentWhereUniqueInput
    data: XOR<DocumentUpdateWithoutFolderInput, DocumentUncheckedUpdateWithoutFolderInput>
  }

  export type DocumentUpdateManyWithWhereWithoutFolderInput = {
    where: DocumentScalarWhereInput
    data: XOR<DocumentUpdateManyMutationInput, DocumentUncheckedUpdateManyWithoutFolderInput>
  }

  export type FolderAclUpsertWithWhereUniqueWithoutFolderInput = {
    where: FolderAclWhereUniqueInput
    update: XOR<FolderAclUpdateWithoutFolderInput, FolderAclUncheckedUpdateWithoutFolderInput>
    create: XOR<FolderAclCreateWithoutFolderInput, FolderAclUncheckedCreateWithoutFolderInput>
  }

  export type FolderAclUpdateWithWhereUniqueWithoutFolderInput = {
    where: FolderAclWhereUniqueInput
    data: XOR<FolderAclUpdateWithoutFolderInput, FolderAclUncheckedUpdateWithoutFolderInput>
  }

  export type FolderAclUpdateManyWithWhereWithoutFolderInput = {
    where: FolderAclScalarWhereInput
    data: XOR<FolderAclUpdateManyMutationInput, FolderAclUncheckedUpdateManyWithoutFolderInput>
  }

  export type FolderCreateWithoutFolderAclInput = {
    id?: string
    name: string
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutFoldersInput
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
    documents?: DocumentCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutFolderAclInput = {
    id?: string
    clientId: string
    name: string
    parentId?: string | null
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    documents?: DocumentUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutFolderAclInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutFolderAclInput, FolderUncheckedCreateWithoutFolderAclInput>
  }

  export type StaffProfileCreateWithoutFolderAclInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutFolderAclInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutFolderAclInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutFolderAclInput, StaffProfileUncheckedCreateWithoutFolderAclInput>
  }

  export type FolderUpsertWithoutFolderAclInput = {
    update: XOR<FolderUpdateWithoutFolderAclInput, FolderUncheckedUpdateWithoutFolderAclInput>
    create: XOR<FolderCreateWithoutFolderAclInput, FolderUncheckedCreateWithoutFolderAclInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutFolderAclInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutFolderAclInput, FolderUncheckedUpdateWithoutFolderAclInput>
  }

  export type FolderUpdateWithoutFolderAclInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutFoldersNestedInput
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutFolderAclInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type StaffProfileUpsertWithoutFolderAclInput = {
    update: XOR<StaffProfileUpdateWithoutFolderAclInput, StaffProfileUncheckedUpdateWithoutFolderAclInput>
    create: XOR<StaffProfileCreateWithoutFolderAclInput, StaffProfileUncheckedCreateWithoutFolderAclInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutFolderAclInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutFolderAclInput, StaffProfileUncheckedUpdateWithoutFolderAclInput>
  }

  export type StaffProfileUpdateWithoutFolderAclInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutFolderAclInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ClientEntityCreateWithoutDocumentsInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutEntitiesInput
    entityTaxYears?: EntityTaxYearCreateNestedManyWithoutClientEntityInput
    folders?: FolderCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityUncheckedCreateWithoutDocumentsInput = {
    id?: string
    accountId: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYears?: EntityTaxYearUncheckedCreateNestedManyWithoutClientEntityInput
    folders?: FolderUncheckedCreateNestedManyWithoutClientEntityInput
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutClientEntityInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutClientEntityInput
  }

  export type ClientEntityCreateOrConnectWithoutDocumentsInput = {
    where: ClientEntityWhereUniqueInput
    create: XOR<ClientEntityCreateWithoutDocumentsInput, ClientEntityUncheckedCreateWithoutDocumentsInput>
  }

  export type FolderCreateWithoutDocumentsInput = {
    id?: string
    name: string
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutFoldersInput
    parent?: FolderCreateNestedOneWithoutChildrenInput
    children?: FolderCreateNestedManyWithoutParentInput
    folderAcl?: FolderAclCreateNestedManyWithoutFolderInput
  }

  export type FolderUncheckedCreateWithoutDocumentsInput = {
    id?: string
    clientId: string
    name: string
    parentId?: string | null
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: FolderUncheckedCreateNestedManyWithoutParentInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutFolderInput
  }

  export type FolderCreateOrConnectWithoutDocumentsInput = {
    where: FolderWhereUniqueInput
    create: XOR<FolderCreateWithoutDocumentsInput, FolderUncheckedCreateWithoutDocumentsInput>
  }

  export type StaffProfileCreateWithoutUploadedDocumentsInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutUploadedDocumentsInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutUploadedDocumentsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutUploadedDocumentsInput, StaffProfileUncheckedCreateWithoutUploadedDocumentsInput>
  }

  export type ChecklistItemFileCreateWithoutDocumentInput = {
    id?: string
    createdAt?: Date | string
    checklistItem: ChecklistItemCreateNestedOneWithoutFilesInput
  }

  export type ChecklistItemFileUncheckedCreateWithoutDocumentInput = {
    id?: string
    checklistItemId: string
    createdAt?: Date | string
  }

  export type ChecklistItemFileCreateOrConnectWithoutDocumentInput = {
    where: ChecklistItemFileWhereUniqueInput
    create: XOR<ChecklistItemFileCreateWithoutDocumentInput, ChecklistItemFileUncheckedCreateWithoutDocumentInput>
  }

  export type ChecklistItemFileCreateManyDocumentInputEnvelope = {
    data: ChecklistItemFileCreateManyDocumentInput | ChecklistItemFileCreateManyDocumentInput[]
    skipDuplicates?: boolean
  }

  export type ClientEntityUpsertWithoutDocumentsInput = {
    update: XOR<ClientEntityUpdateWithoutDocumentsInput, ClientEntityUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ClientEntityCreateWithoutDocumentsInput, ClientEntityUncheckedCreateWithoutDocumentsInput>
    where?: ClientEntityWhereInput
  }

  export type ClientEntityUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ClientEntityWhereInput
    data: XOR<ClientEntityUpdateWithoutDocumentsInput, ClientEntityUncheckedUpdateWithoutDocumentsInput>
  }

  export type ClientEntityUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutEntitiesNestedInput
    entityTaxYears?: EntityTaxYearUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYears?: EntityTaxYearUncheckedUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUncheckedUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityNestedInput
  }

  export type FolderUpsertWithoutDocumentsInput = {
    update: XOR<FolderUpdateWithoutDocumentsInput, FolderUncheckedUpdateWithoutDocumentsInput>
    create: XOR<FolderCreateWithoutDocumentsInput, FolderUncheckedCreateWithoutDocumentsInput>
    where?: FolderWhereInput
  }

  export type FolderUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: FolderWhereInput
    data: XOR<FolderUpdateWithoutDocumentsInput, FolderUncheckedUpdateWithoutDocumentsInput>
  }

  export type FolderUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutFoldersNestedInput
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
    folderAcl?: FolderAclUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type StaffProfileUpsertWithoutUploadedDocumentsInput = {
    update: XOR<StaffProfileUpdateWithoutUploadedDocumentsInput, StaffProfileUncheckedUpdateWithoutUploadedDocumentsInput>
    create: XOR<StaffProfileCreateWithoutUploadedDocumentsInput, StaffProfileUncheckedCreateWithoutUploadedDocumentsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutUploadedDocumentsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutUploadedDocumentsInput, StaffProfileUncheckedUpdateWithoutUploadedDocumentsInput>
  }

  export type StaffProfileUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutUploadedDocumentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type ChecklistItemFileUpsertWithWhereUniqueWithoutDocumentInput = {
    where: ChecklistItemFileWhereUniqueInput
    update: XOR<ChecklistItemFileUpdateWithoutDocumentInput, ChecklistItemFileUncheckedUpdateWithoutDocumentInput>
    create: XOR<ChecklistItemFileCreateWithoutDocumentInput, ChecklistItemFileUncheckedCreateWithoutDocumentInput>
  }

  export type ChecklistItemFileUpdateWithWhereUniqueWithoutDocumentInput = {
    where: ChecklistItemFileWhereUniqueInput
    data: XOR<ChecklistItemFileUpdateWithoutDocumentInput, ChecklistItemFileUncheckedUpdateWithoutDocumentInput>
  }

  export type ChecklistItemFileUpdateManyWithWhereWithoutDocumentInput = {
    where: ChecklistItemFileScalarWhereInput
    data: XOR<ChecklistItemFileUpdateManyMutationInput, ChecklistItemFileUncheckedUpdateManyWithoutDocumentInput>
  }

  export type ChecklistItemFileScalarWhereInput = {
    AND?: ChecklistItemFileScalarWhereInput | ChecklistItemFileScalarWhereInput[]
    OR?: ChecklistItemFileScalarWhereInput[]
    NOT?: ChecklistItemFileScalarWhereInput | ChecklistItemFileScalarWhereInput[]
    id?: StringFilter<"ChecklistItemFile"> | string
    checklistItemId?: StringFilter<"ChecklistItemFile"> | string
    documentId?: StringFilter<"ChecklistItemFile"> | string
    createdAt?: DateTimeFilter<"ChecklistItemFile"> | Date | string
  }

  export type EntityTaxYearCreateWithoutChecklistItemsInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutChecklistItemsInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutChecklistItemsInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutChecklistItemsInput, EntityTaxYearUncheckedCreateWithoutChecklistItemsInput>
  }

  export type ChecklistItemFileCreateWithoutChecklistItemInput = {
    id?: string
    createdAt?: Date | string
    document: DocumentCreateNestedOneWithoutChecklistItemsInput
  }

  export type ChecklistItemFileUncheckedCreateWithoutChecklistItemInput = {
    id?: string
    documentId: string
    createdAt?: Date | string
  }

  export type ChecklistItemFileCreateOrConnectWithoutChecklistItemInput = {
    where: ChecklistItemFileWhereUniqueInput
    create: XOR<ChecklistItemFileCreateWithoutChecklistItemInput, ChecklistItemFileUncheckedCreateWithoutChecklistItemInput>
  }

  export type ChecklistItemFileCreateManyChecklistItemInputEnvelope = {
    data: ChecklistItemFileCreateManyChecklistItemInput | ChecklistItemFileCreateManyChecklistItemInput[]
    skipDuplicates?: boolean
  }

  export type EntityTaxYearUpsertWithoutChecklistItemsInput = {
    update: XOR<EntityTaxYearUpdateWithoutChecklistItemsInput, EntityTaxYearUncheckedUpdateWithoutChecklistItemsInput>
    create: XOR<EntityTaxYearCreateWithoutChecklistItemsInput, EntityTaxYearUncheckedCreateWithoutChecklistItemsInput>
    where?: EntityTaxYearWhereInput
  }

  export type EntityTaxYearUpdateToOneWithWhereWithoutChecklistItemsInput = {
    where?: EntityTaxYearWhereInput
    data: XOR<EntityTaxYearUpdateWithoutChecklistItemsInput, EntityTaxYearUncheckedUpdateWithoutChecklistItemsInput>
  }

  export type EntityTaxYearUpdateWithoutChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type ChecklistItemFileUpsertWithWhereUniqueWithoutChecklistItemInput = {
    where: ChecklistItemFileWhereUniqueInput
    update: XOR<ChecklistItemFileUpdateWithoutChecklistItemInput, ChecklistItemFileUncheckedUpdateWithoutChecklistItemInput>
    create: XOR<ChecklistItemFileCreateWithoutChecklistItemInput, ChecklistItemFileUncheckedCreateWithoutChecklistItemInput>
  }

  export type ChecklistItemFileUpdateWithWhereUniqueWithoutChecklistItemInput = {
    where: ChecklistItemFileWhereUniqueInput
    data: XOR<ChecklistItemFileUpdateWithoutChecklistItemInput, ChecklistItemFileUncheckedUpdateWithoutChecklistItemInput>
  }

  export type ChecklistItemFileUpdateManyWithWhereWithoutChecklistItemInput = {
    where: ChecklistItemFileScalarWhereInput
    data: XOR<ChecklistItemFileUpdateManyMutationInput, ChecklistItemFileUncheckedUpdateManyWithoutChecklistItemInput>
  }

  export type ChecklistItemCreateWithoutFilesInput = {
    id?: string
    itemName: string
    itemType?: string | null
    required?: boolean
    status?: $Enums.ChecklistItemStatus
    receivedAt?: Date | string | null
    markedNotApplicableAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutChecklistItemsInput
  }

  export type ChecklistItemUncheckedCreateWithoutFilesInput = {
    id?: string
    entityTaxYearId: string
    itemName: string
    itemType?: string | null
    required?: boolean
    status?: $Enums.ChecklistItemStatus
    receivedAt?: Date | string | null
    markedNotApplicableAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChecklistItemCreateOrConnectWithoutFilesInput = {
    where: ChecklistItemWhereUniqueInput
    create: XOR<ChecklistItemCreateWithoutFilesInput, ChecklistItemUncheckedCreateWithoutFilesInput>
  }

  export type DocumentCreateWithoutChecklistItemsInput = {
    id?: string
    storagePath: string
    displayName: string
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutDocumentsInput
    folder?: FolderCreateNestedOneWithoutDocumentsInput
    uploader?: StaffProfileCreateNestedOneWithoutUploadedDocumentsInput
  }

  export type DocumentUncheckedCreateWithoutChecklistItemsInput = {
    id?: string
    clientId: string
    folderId?: string | null
    storagePath: string
    displayName: string
    uploadedBy?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateOrConnectWithoutChecklistItemsInput = {
    where: DocumentWhereUniqueInput
    create: XOR<DocumentCreateWithoutChecklistItemsInput, DocumentUncheckedCreateWithoutChecklistItemsInput>
  }

  export type ChecklistItemUpsertWithoutFilesInput = {
    update: XOR<ChecklistItemUpdateWithoutFilesInput, ChecklistItemUncheckedUpdateWithoutFilesInput>
    create: XOR<ChecklistItemCreateWithoutFilesInput, ChecklistItemUncheckedCreateWithoutFilesInput>
    where?: ChecklistItemWhereInput
  }

  export type ChecklistItemUpdateToOneWithWhereWithoutFilesInput = {
    where?: ChecklistItemWhereInput
    data: XOR<ChecklistItemUpdateWithoutFilesInput, ChecklistItemUncheckedUpdateWithoutFilesInput>
  }

  export type ChecklistItemUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutChecklistItemsNestedInput
  }

  export type ChecklistItemUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpsertWithoutChecklistItemsInput = {
    update: XOR<DocumentUpdateWithoutChecklistItemsInput, DocumentUncheckedUpdateWithoutChecklistItemsInput>
    create: XOR<DocumentCreateWithoutChecklistItemsInput, DocumentUncheckedCreateWithoutChecklistItemsInput>
    where?: DocumentWhereInput
  }

  export type DocumentUpdateToOneWithWhereWithoutChecklistItemsInput = {
    where?: DocumentWhereInput
    data: XOR<DocumentUpdateWithoutChecklistItemsInput, DocumentUncheckedUpdateWithoutChecklistItemsInput>
  }

  export type DocumentUpdateWithoutChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutDocumentsNestedInput
    folder?: FolderUpdateOneWithoutDocumentsNestedInput
    uploader?: StaffProfileUpdateOneWithoutUploadedDocumentsNestedInput
  }

  export type DocumentUncheckedUpdateWithoutChecklistItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireQuestionCreateWithoutSectionInput = {
    id?: string
    questionText: string
    questionType: $Enums.QuestionType
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: QuestionnaireAnswerCreateNestedManyWithoutQuestionInput
  }

  export type QuestionnaireQuestionUncheckedCreateWithoutSectionInput = {
    id?: string
    questionText: string
    questionType: $Enums.QuestionType
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    answers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutQuestionInput
  }

  export type QuestionnaireQuestionCreateOrConnectWithoutSectionInput = {
    where: QuestionnaireQuestionWhereUniqueInput
    create: XOR<QuestionnaireQuestionCreateWithoutSectionInput, QuestionnaireQuestionUncheckedCreateWithoutSectionInput>
  }

  export type QuestionnaireQuestionCreateManySectionInputEnvelope = {
    data: QuestionnaireQuestionCreateManySectionInput | QuestionnaireQuestionCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type QuestionnaireQuestionUpsertWithWhereUniqueWithoutSectionInput = {
    where: QuestionnaireQuestionWhereUniqueInput
    update: XOR<QuestionnaireQuestionUpdateWithoutSectionInput, QuestionnaireQuestionUncheckedUpdateWithoutSectionInput>
    create: XOR<QuestionnaireQuestionCreateWithoutSectionInput, QuestionnaireQuestionUncheckedCreateWithoutSectionInput>
  }

  export type QuestionnaireQuestionUpdateWithWhereUniqueWithoutSectionInput = {
    where: QuestionnaireQuestionWhereUniqueInput
    data: XOR<QuestionnaireQuestionUpdateWithoutSectionInput, QuestionnaireQuestionUncheckedUpdateWithoutSectionInput>
  }

  export type QuestionnaireQuestionUpdateManyWithWhereWithoutSectionInput = {
    where: QuestionnaireQuestionScalarWhereInput
    data: XOR<QuestionnaireQuestionUpdateManyMutationInput, QuestionnaireQuestionUncheckedUpdateManyWithoutSectionInput>
  }

  export type QuestionnaireQuestionScalarWhereInput = {
    AND?: QuestionnaireQuestionScalarWhereInput | QuestionnaireQuestionScalarWhereInput[]
    OR?: QuestionnaireQuestionScalarWhereInput[]
    NOT?: QuestionnaireQuestionScalarWhereInput | QuestionnaireQuestionScalarWhereInput[]
    id?: StringFilter<"QuestionnaireQuestion"> | string
    sectionId?: StringFilter<"QuestionnaireQuestion"> | string
    questionText?: StringFilter<"QuestionnaireQuestion"> | string
    questionType?: EnumQuestionTypeFilter<"QuestionnaireQuestion"> | $Enums.QuestionType
    required?: BoolFilter<"QuestionnaireQuestion"> | boolean
    order?: IntFilter<"QuestionnaireQuestion"> | number
    conditionalLogic?: StringNullableFilter<"QuestionnaireQuestion"> | string | null
    createdAt?: DateTimeFilter<"QuestionnaireQuestion"> | Date | string
    updatedAt?: DateTimeFilter<"QuestionnaireQuestion"> | Date | string
  }

  export type QuestionnaireSectionCreateWithoutQuestionsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireSectionUncheckedCreateWithoutQuestionsInput = {
    id?: string
    name: string
    description?: string | null
    order?: number
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireSectionCreateOrConnectWithoutQuestionsInput = {
    where: QuestionnaireSectionWhereUniqueInput
    create: XOR<QuestionnaireSectionCreateWithoutQuestionsInput, QuestionnaireSectionUncheckedCreateWithoutQuestionsInput>
  }

  export type QuestionnaireAnswerCreateWithoutQuestionInput = {
    id?: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutQuestionnaireAnswersInput
  }

  export type QuestionnaireAnswerUncheckedCreateWithoutQuestionInput = {
    id?: string
    entityTaxYearId: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireAnswerCreateOrConnectWithoutQuestionInput = {
    where: QuestionnaireAnswerWhereUniqueInput
    create: XOR<QuestionnaireAnswerCreateWithoutQuestionInput, QuestionnaireAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionnaireAnswerCreateManyQuestionInputEnvelope = {
    data: QuestionnaireAnswerCreateManyQuestionInput | QuestionnaireAnswerCreateManyQuestionInput[]
    skipDuplicates?: boolean
  }

  export type QuestionnaireSectionUpsertWithoutQuestionsInput = {
    update: XOR<QuestionnaireSectionUpdateWithoutQuestionsInput, QuestionnaireSectionUncheckedUpdateWithoutQuestionsInput>
    create: XOR<QuestionnaireSectionCreateWithoutQuestionsInput, QuestionnaireSectionUncheckedCreateWithoutQuestionsInput>
    where?: QuestionnaireSectionWhereInput
  }

  export type QuestionnaireSectionUpdateToOneWithWhereWithoutQuestionsInput = {
    where?: QuestionnaireSectionWhereInput
    data: XOR<QuestionnaireSectionUpdateWithoutQuestionsInput, QuestionnaireSectionUncheckedUpdateWithoutQuestionsInput>
  }

  export type QuestionnaireSectionUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireSectionUncheckedUpdateWithoutQuestionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireAnswerUpsertWithWhereUniqueWithoutQuestionInput = {
    where: QuestionnaireAnswerWhereUniqueInput
    update: XOR<QuestionnaireAnswerUpdateWithoutQuestionInput, QuestionnaireAnswerUncheckedUpdateWithoutQuestionInput>
    create: XOR<QuestionnaireAnswerCreateWithoutQuestionInput, QuestionnaireAnswerUncheckedCreateWithoutQuestionInput>
  }

  export type QuestionnaireAnswerUpdateWithWhereUniqueWithoutQuestionInput = {
    where: QuestionnaireAnswerWhereUniqueInput
    data: XOR<QuestionnaireAnswerUpdateWithoutQuestionInput, QuestionnaireAnswerUncheckedUpdateWithoutQuestionInput>
  }

  export type QuestionnaireAnswerUpdateManyWithWhereWithoutQuestionInput = {
    where: QuestionnaireAnswerScalarWhereInput
    data: XOR<QuestionnaireAnswerUpdateManyMutationInput, QuestionnaireAnswerUncheckedUpdateManyWithoutQuestionInput>
  }

  export type EntityTaxYearCreateWithoutQuestionnaireAnswersInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutQuestionnaireAnswersInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutQuestionnaireAnswersInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutQuestionnaireAnswersInput, EntityTaxYearUncheckedCreateWithoutQuestionnaireAnswersInput>
  }

  export type QuestionnaireQuestionCreateWithoutAnswersInput = {
    id?: string
    questionText: string
    questionType: $Enums.QuestionType
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    section: QuestionnaireSectionCreateNestedOneWithoutQuestionsInput
  }

  export type QuestionnaireQuestionUncheckedCreateWithoutAnswersInput = {
    id?: string
    sectionId: string
    questionText: string
    questionType: $Enums.QuestionType
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireQuestionCreateOrConnectWithoutAnswersInput = {
    where: QuestionnaireQuestionWhereUniqueInput
    create: XOR<QuestionnaireQuestionCreateWithoutAnswersInput, QuestionnaireQuestionUncheckedCreateWithoutAnswersInput>
  }

  export type EntityTaxYearUpsertWithoutQuestionnaireAnswersInput = {
    update: XOR<EntityTaxYearUpdateWithoutQuestionnaireAnswersInput, EntityTaxYearUncheckedUpdateWithoutQuestionnaireAnswersInput>
    create: XOR<EntityTaxYearCreateWithoutQuestionnaireAnswersInput, EntityTaxYearUncheckedCreateWithoutQuestionnaireAnswersInput>
    where?: EntityTaxYearWhereInput
  }

  export type EntityTaxYearUpdateToOneWithWhereWithoutQuestionnaireAnswersInput = {
    where?: EntityTaxYearWhereInput
    data: XOR<EntityTaxYearUpdateWithoutQuestionnaireAnswersInput, EntityTaxYearUncheckedUpdateWithoutQuestionnaireAnswersInput>
  }

  export type EntityTaxYearUpdateWithoutQuestionnaireAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutQuestionnaireAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type QuestionnaireQuestionUpsertWithoutAnswersInput = {
    update: XOR<QuestionnaireQuestionUpdateWithoutAnswersInput, QuestionnaireQuestionUncheckedUpdateWithoutAnswersInput>
    create: XOR<QuestionnaireQuestionCreateWithoutAnswersInput, QuestionnaireQuestionUncheckedCreateWithoutAnswersInput>
    where?: QuestionnaireQuestionWhereInput
  }

  export type QuestionnaireQuestionUpdateToOneWithWhereWithoutAnswersInput = {
    where?: QuestionnaireQuestionWhereInput
    data: XOR<QuestionnaireQuestionUpdateWithoutAnswersInput, QuestionnaireQuestionUncheckedUpdateWithoutAnswersInput>
  }

  export type QuestionnaireQuestionUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    section?: QuestionnaireSectionUpdateOneRequiredWithoutQuestionsNestedInput
  }

  export type QuestionnaireQuestionUncheckedUpdateWithoutAnswersInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityTaxYearCreateWithoutEngagementSignaturesInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutEngagementSignaturesInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutEngagementSignaturesInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutEngagementSignaturesInput, EntityTaxYearUncheckedCreateWithoutEngagementSignaturesInput>
  }

  export type EntityTaxYearUpsertWithoutEngagementSignaturesInput = {
    update: XOR<EntityTaxYearUpdateWithoutEngagementSignaturesInput, EntityTaxYearUncheckedUpdateWithoutEngagementSignaturesInput>
    create: XOR<EntityTaxYearCreateWithoutEngagementSignaturesInput, EntityTaxYearUncheckedCreateWithoutEngagementSignaturesInput>
    where?: EntityTaxYearWhereInput
  }

  export type EntityTaxYearUpdateToOneWithWhereWithoutEngagementSignaturesInput = {
    where?: EntityTaxYearWhereInput
    data: XOR<EntityTaxYearUpdateWithoutEngagementSignaturesInput, EntityTaxYearUncheckedUpdateWithoutEngagementSignaturesInput>
  }

  export type EntityTaxYearUpdateWithoutEngagementSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutEngagementSignaturesInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearCreateWithoutEfileAuthorizationsInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutEfileAuthorizationsInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutEfileAuthorizationsInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutEfileAuthorizationsInput, EntityTaxYearUncheckedCreateWithoutEfileAuthorizationsInput>
  }

  export type EntityTaxYearUpsertWithoutEfileAuthorizationsInput = {
    update: XOR<EntityTaxYearUpdateWithoutEfileAuthorizationsInput, EntityTaxYearUncheckedUpdateWithoutEfileAuthorizationsInput>
    create: XOR<EntityTaxYearCreateWithoutEfileAuthorizationsInput, EntityTaxYearUncheckedCreateWithoutEfileAuthorizationsInput>
    where?: EntityTaxYearWhereInput
  }

  export type EntityTaxYearUpdateToOneWithWhereWithoutEfileAuthorizationsInput = {
    where?: EntityTaxYearWhereInput
    data: XOR<EntityTaxYearUpdateWithoutEfileAuthorizationsInput, EntityTaxYearUncheckedUpdateWithoutEfileAuthorizationsInput>
  }

  export type EntityTaxYearUpdateWithoutEfileAuthorizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutEfileAuthorizationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearCreateWithoutMessageThreadInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutMessageThreadInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutMessageThreadInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutMessageThreadInput, EntityTaxYearUncheckedCreateWithoutMessageThreadInput>
  }

  export type ThreadParticipantCreateWithoutThreadInput = {
    id?: string
    userType: $Enums.UserType
    createdAt?: Date | string
    staff?: StaffProfileCreateNestedOneWithoutAssignedThreadsInput
  }

  export type ThreadParticipantUncheckedCreateWithoutThreadInput = {
    id?: string
    userId: string
    userType: $Enums.UserType
    createdAt?: Date | string
  }

  export type ThreadParticipantCreateOrConnectWithoutThreadInput = {
    where: ThreadParticipantWhereUniqueInput
    create: XOR<ThreadParticipantCreateWithoutThreadInput, ThreadParticipantUncheckedCreateWithoutThreadInput>
  }

  export type ThreadParticipantCreateManyThreadInputEnvelope = {
    data: ThreadParticipantCreateManyThreadInput | ThreadParticipantCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutThreadInput = {
    id?: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    sender?: StaffProfileCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutThreadInput = {
    id?: string
    senderId: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MessageCreateOrConnectWithoutThreadInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput>
  }

  export type MessageCreateManyThreadInputEnvelope = {
    data: MessageCreateManyThreadInput | MessageCreateManyThreadInput[]
    skipDuplicates?: boolean
  }

  export type EntityTaxYearUpsertWithoutMessageThreadInput = {
    update: XOR<EntityTaxYearUpdateWithoutMessageThreadInput, EntityTaxYearUncheckedUpdateWithoutMessageThreadInput>
    create: XOR<EntityTaxYearCreateWithoutMessageThreadInput, EntityTaxYearUncheckedCreateWithoutMessageThreadInput>
    where?: EntityTaxYearWhereInput
  }

  export type EntityTaxYearUpdateToOneWithWhereWithoutMessageThreadInput = {
    where?: EntityTaxYearWhereInput
    data: XOR<EntityTaxYearUpdateWithoutMessageThreadInput, EntityTaxYearUncheckedUpdateWithoutMessageThreadInput>
  }

  export type EntityTaxYearUpdateWithoutMessageThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutMessageThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type ThreadParticipantUpsertWithWhereUniqueWithoutThreadInput = {
    where: ThreadParticipantWhereUniqueInput
    update: XOR<ThreadParticipantUpdateWithoutThreadInput, ThreadParticipantUncheckedUpdateWithoutThreadInput>
    create: XOR<ThreadParticipantCreateWithoutThreadInput, ThreadParticipantUncheckedCreateWithoutThreadInput>
  }

  export type ThreadParticipantUpdateWithWhereUniqueWithoutThreadInput = {
    where: ThreadParticipantWhereUniqueInput
    data: XOR<ThreadParticipantUpdateWithoutThreadInput, ThreadParticipantUncheckedUpdateWithoutThreadInput>
  }

  export type ThreadParticipantUpdateManyWithWhereWithoutThreadInput = {
    where: ThreadParticipantScalarWhereInput
    data: XOR<ThreadParticipantUpdateManyMutationInput, ThreadParticipantUncheckedUpdateManyWithoutThreadInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutThreadInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutThreadInput, MessageUncheckedUpdateWithoutThreadInput>
    create: XOR<MessageCreateWithoutThreadInput, MessageUncheckedCreateWithoutThreadInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutThreadInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutThreadInput, MessageUncheckedUpdateWithoutThreadInput>
  }

  export type MessageUpdateManyWithWhereWithoutThreadInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutThreadInput>
  }

  export type MessageThreadCreateWithoutParticipantsInput = {
    id?: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutMessageThreadInput
    messages?: MessageCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateWithoutParticipantsInput = {
    id?: string
    entityTaxYearId: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadCreateOrConnectWithoutParticipantsInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutParticipantsInput, MessageThreadUncheckedCreateWithoutParticipantsInput>
  }

  export type StaffProfileCreateWithoutAssignedThreadsInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutAssignedThreadsInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutAssignedThreadsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutAssignedThreadsInput, StaffProfileUncheckedCreateWithoutAssignedThreadsInput>
  }

  export type MessageThreadUpsertWithoutParticipantsInput = {
    update: XOR<MessageThreadUpdateWithoutParticipantsInput, MessageThreadUncheckedUpdateWithoutParticipantsInput>
    create: XOR<MessageThreadCreateWithoutParticipantsInput, MessageThreadUncheckedCreateWithoutParticipantsInput>
    where?: MessageThreadWhereInput
  }

  export type MessageThreadUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: MessageThreadWhereInput
    data: XOR<MessageThreadUpdateWithoutParticipantsInput, MessageThreadUncheckedUpdateWithoutParticipantsInput>
  }

  export type MessageThreadUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutMessageThreadNestedInput
    messages?: MessageUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type StaffProfileUpsertWithoutAssignedThreadsInput = {
    update: XOR<StaffProfileUpdateWithoutAssignedThreadsInput, StaffProfileUncheckedUpdateWithoutAssignedThreadsInput>
    create: XOR<StaffProfileCreateWithoutAssignedThreadsInput, StaffProfileUncheckedCreateWithoutAssignedThreadsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutAssignedThreadsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutAssignedThreadsInput, StaffProfileUncheckedUpdateWithoutAssignedThreadsInput>
  }

  export type StaffProfileUpdateWithoutAssignedThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutAssignedThreadsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type MessageThreadCreateWithoutMessagesInput = {
    id?: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    entityTaxYear: EntityTaxYearCreateNestedOneWithoutMessageThreadInput
    participants?: ThreadParticipantCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadUncheckedCreateWithoutMessagesInput = {
    id?: string
    entityTaxYearId: string
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    participants?: ThreadParticipantUncheckedCreateNestedManyWithoutThreadInput
  }

  export type MessageThreadCreateOrConnectWithoutMessagesInput = {
    where: MessageThreadWhereUniqueInput
    create: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
  }

  export type StaffProfileCreateWithoutSentMessagesInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutSentMessagesInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutSentMessagesInput, StaffProfileUncheckedCreateWithoutSentMessagesInput>
  }

  export type MessageThreadUpsertWithoutMessagesInput = {
    update: XOR<MessageThreadUpdateWithoutMessagesInput, MessageThreadUncheckedUpdateWithoutMessagesInput>
    create: XOR<MessageThreadCreateWithoutMessagesInput, MessageThreadUncheckedCreateWithoutMessagesInput>
    where?: MessageThreadWhereInput
  }

  export type MessageThreadUpdateToOneWithWhereWithoutMessagesInput = {
    where?: MessageThreadWhereInput
    data: XOR<MessageThreadUpdateWithoutMessagesInput, MessageThreadUncheckedUpdateWithoutMessagesInput>
  }

  export type MessageThreadUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutMessageThreadNestedInput
    participants?: ThreadParticipantUpdateManyWithoutThreadNestedInput
  }

  export type MessageThreadUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    participants?: ThreadParticipantUncheckedUpdateManyWithoutThreadNestedInput
  }

  export type StaffProfileUpsertWithoutSentMessagesInput = {
    update: XOR<StaffProfileUpdateWithoutSentMessagesInput, StaffProfileUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<StaffProfileCreateWithoutSentMessagesInput, StaffProfileUncheckedCreateWithoutSentMessagesInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutSentMessagesInput, StaffProfileUncheckedUpdateWithoutSentMessagesInput>
  }

  export type StaffProfileUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type EntityTaxYearCreateWithoutReminderStateInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutReminderStateInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutReminderStateInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutReminderStateInput, EntityTaxYearUncheckedCreateWithoutReminderStateInput>
  }

  export type EntityTaxYearUpsertWithoutReminderStateInput = {
    update: XOR<EntityTaxYearUpdateWithoutReminderStateInput, EntityTaxYearUncheckedUpdateWithoutReminderStateInput>
    create: XOR<EntityTaxYearCreateWithoutReminderStateInput, EntityTaxYearUncheckedCreateWithoutReminderStateInput>
    where?: EntityTaxYearWhereInput
  }

  export type EntityTaxYearUpdateToOneWithWhereWithoutReminderStateInput = {
    where?: EntityTaxYearWhereInput
    data: XOR<EntityTaxYearUpdateWithoutReminderStateInput, EntityTaxYearUncheckedUpdateWithoutReminderStateInput>
  }

  export type EntityTaxYearUpdateWithoutReminderStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutReminderStateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearCreateWithoutStatusAuditLogsInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    documentEvents?: DocumentEventCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutStatusAuditLogsInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    documentEvents?: DocumentEventUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutStatusAuditLogsInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutStatusAuditLogsInput, EntityTaxYearUncheckedCreateWithoutStatusAuditLogsInput>
  }

  export type StaffProfileCreateWithoutStatusAuditLogsInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    permissionAuditLogs?: PermissionAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutStatusAuditLogsInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    permissionAuditLogs?: PermissionAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutStatusAuditLogsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutStatusAuditLogsInput, StaffProfileUncheckedCreateWithoutStatusAuditLogsInput>
  }

  export type EntityTaxYearUpsertWithoutStatusAuditLogsInput = {
    update: XOR<EntityTaxYearUpdateWithoutStatusAuditLogsInput, EntityTaxYearUncheckedUpdateWithoutStatusAuditLogsInput>
    create: XOR<EntityTaxYearCreateWithoutStatusAuditLogsInput, EntityTaxYearUncheckedCreateWithoutStatusAuditLogsInput>
    where?: EntityTaxYearWhereInput
  }

  export type EntityTaxYearUpdateToOneWithWhereWithoutStatusAuditLogsInput = {
    where?: EntityTaxYearWhereInput
    data: XOR<EntityTaxYearUpdateWithoutStatusAuditLogsInput, EntityTaxYearUncheckedUpdateWithoutStatusAuditLogsInput>
  }

  export type EntityTaxYearUpdateWithoutStatusAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutStatusAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type StaffProfileUpsertWithoutStatusAuditLogsInput = {
    update: XOR<StaffProfileUpdateWithoutStatusAuditLogsInput, StaffProfileUncheckedUpdateWithoutStatusAuditLogsInput>
    create: XOR<StaffProfileCreateWithoutStatusAuditLogsInput, StaffProfileUncheckedCreateWithoutStatusAuditLogsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutStatusAuditLogsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutStatusAuditLogsInput, StaffProfileUncheckedUpdateWithoutStatusAuditLogsInput>
  }

  export type StaffProfileUpdateWithoutStatusAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    permissionAuditLogs?: PermissionAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutStatusAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    permissionAuditLogs?: PermissionAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileCreateWithoutPermissionAuditLogsInput = {
    id?: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutStaffProfileInput
    profile: ProfileCreateNestedOneWithoutStaffProfileInput
    clientAcl?: ClientAclCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantCreateNestedManyWithoutStaffInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileUncheckedCreateWithoutPermissionAuditLogsInput = {
    id?: string
    userId: string
    staffRole?: $Enums.StaffRole
    staffTeamReporting?: string | null
    jobTitle?: string | null
    phone?: string | null
    active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clientAcl?: ClientAclUncheckedCreateNestedManyWithoutStaffInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedCreateNestedManyWithoutStaffInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedCreateNestedManyWithoutStaffInput
    folderAcl?: FolderAclUncheckedCreateNestedManyWithoutStaffInput
    uploadedDocuments?: DocumentUncheckedCreateNestedManyWithoutUploaderInput
    assignedThreads?: ThreadParticipantUncheckedCreateNestedManyWithoutStaffInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutStaffInput
  }

  export type StaffProfileCreateOrConnectWithoutPermissionAuditLogsInput = {
    where: StaffProfileWhereUniqueInput
    create: XOR<StaffProfileCreateWithoutPermissionAuditLogsInput, StaffProfileUncheckedCreateWithoutPermissionAuditLogsInput>
  }

  export type StaffProfileUpsertWithoutPermissionAuditLogsInput = {
    update: XOR<StaffProfileUpdateWithoutPermissionAuditLogsInput, StaffProfileUncheckedUpdateWithoutPermissionAuditLogsInput>
    create: XOR<StaffProfileCreateWithoutPermissionAuditLogsInput, StaffProfileUncheckedCreateWithoutPermissionAuditLogsInput>
    where?: StaffProfileWhereInput
  }

  export type StaffProfileUpdateToOneWithWhereWithoutPermissionAuditLogsInput = {
    where?: StaffProfileWhereInput
    data: XOR<StaffProfileUpdateWithoutPermissionAuditLogsInput, StaffProfileUncheckedUpdateWithoutPermissionAuditLogsInput>
  }

  export type StaffProfileUpdateWithoutPermissionAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutStaffProfileNestedInput
    profile?: ProfileUpdateOneRequiredWithoutStaffProfileNestedInput
    clientAcl?: ClientAclUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutStaffNestedInput
  }

  export type StaffProfileUncheckedUpdateWithoutPermissionAuditLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    staffRole?: EnumStaffRoleFieldUpdateOperationsInput | $Enums.StaffRole
    staffTeamReporting?: NullableStringFieldUpdateOperationsInput | string | null
    jobTitle?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientAcl?: ClientAclUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutStaffNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutStaffNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutStaffNestedInput
    uploadedDocuments?: DocumentUncheckedUpdateManyWithoutUploaderNestedInput
    assignedThreads?: ThreadParticipantUncheckedUpdateManyWithoutStaffNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutStaffNestedInput
  }

  export type EntityTaxYearCreateWithoutDocumentEventsInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    clientEntity: ClientEntityCreateNestedOneWithoutEntityTaxYearsInput
    checklistItems?: ChecklistItemCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearUncheckedCreateWithoutDocumentEventsInput = {
    id?: string
    clientEntityId: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    checklistItems?: ChecklistItemUncheckedCreateNestedManyWithoutEntityTaxYearInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedCreateNestedManyWithoutEntityTaxYearInput
    messageThread?: MessageThreadUncheckedCreateNestedOneWithoutEntityTaxYearInput
    reminderState?: ReminderStateUncheckedCreateNestedOneWithoutEntityTaxYearInput
    statusAuditLogs?: StatusAuditLogUncheckedCreateNestedManyWithoutEntityTaxYearInput
    engagementSignatures?: EngagementSignatureUncheckedCreateNestedManyWithoutEntityTaxYearInput
    efileAuthorizations?: EfileAuthorizationUncheckedCreateNestedManyWithoutEntityTaxYearInput
  }

  export type EntityTaxYearCreateOrConnectWithoutDocumentEventsInput = {
    where: EntityTaxYearWhereUniqueInput
    create: XOR<EntityTaxYearCreateWithoutDocumentEventsInput, EntityTaxYearUncheckedCreateWithoutDocumentEventsInput>
  }

  export type EntityTaxYearUpsertWithoutDocumentEventsInput = {
    update: XOR<EntityTaxYearUpdateWithoutDocumentEventsInput, EntityTaxYearUncheckedUpdateWithoutDocumentEventsInput>
    create: XOR<EntityTaxYearCreateWithoutDocumentEventsInput, EntityTaxYearUncheckedCreateWithoutDocumentEventsInput>
    where?: EntityTaxYearWhereInput
  }

  export type EntityTaxYearUpdateToOneWithWhereWithoutDocumentEventsInput = {
    where?: EntityTaxYearWhereInput
    data: XOR<EntityTaxYearUpdateWithoutDocumentEventsInput, EntityTaxYearUncheckedUpdateWithoutDocumentEventsInput>
  }

  export type EntityTaxYearUpdateWithoutDocumentEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutEntityTaxYearsNestedInput
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutDocumentEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientEntityId?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type AccountUserCreateManyProfileInput = {
    id?: string
    accountId: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutAccountUsersNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAclCreateManyStaffInput = {
    id?: string
    clientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffPermissionCreateManyStaffInput = {
    id?: string
    clientId: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffAssignmentCreateManyStaffInput = {
    id?: string
    clientId: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderAclCreateManyStaffInput = {
    id?: string
    folderId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyUploaderInput = {
    id?: string
    clientId: string
    folderId?: string | null
    storagePath: string
    displayName: string
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThreadParticipantCreateManyStaffInput = {
    id?: string
    threadId: string
    userType: $Enums.UserType
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    threadId: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusAuditLogCreateManyStaffInput = {
    id?: string
    entityTaxYearId: string
    oldStatus?: string | null
    newStatus: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type PermissionAuditLogCreateManyStaffInput = {
    id?: string
    changeType: string
    clientId?: string | null
    staffUserId?: string | null
    oldValue?: string | null
    newValue?: string | null
    reason?: string | null
    createdAt?: Date | string
  }

  export type ClientAclUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutClientAclNestedInput
  }

  export type ClientAclUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAclUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffPermissionUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutClientStaffPermissionsNestedInput
  }

  export type ClientStaffPermissionUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffPermissionUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffAssignmentUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutClientStaffAssignmentsNestedInput
  }

  export type ClientStaffAssignmentUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffAssignmentUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderAclUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneRequiredWithoutFolderAclNestedInput
  }

  export type FolderAclUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderAclUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutDocumentsNestedInput
    folder?: FolderUpdateOneWithoutDocumentsNestedInput
    checklistItems?: ChecklistItemFileUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemFileUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreadParticipantUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type ThreadParticipantUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreadParticipantUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    thread?: MessageThreadUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    threadId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAuditLogUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutStatusAuditLogsNestedInput
  }

  export type StatusAuditLogUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAuditLogUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditLogUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    staffUserId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditLogUncheckedUpdateWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    staffUserId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PermissionAuditLogUncheckedUpdateManyWithoutStaffInput = {
    id?: StringFieldUpdateOperationsInput | string
    changeType?: StringFieldUpdateOperationsInput | string
    clientId?: NullableStringFieldUpdateOperationsInput | string | null
    staffUserId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserCreateManyAccountInput = {
    id?: string
    userId: string
    clientRole?: $Enums.ClientRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientEntityCreateManyAccountInput = {
    id?: string
    entityName: string
    entityType: $Enums.EntityType
    status?: string | null
    isRestricted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneRequiredWithoutAccountUsersNestedInput
  }

  export type AccountUserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUserUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clientRole?: EnumClientRoleFieldUpdateOperationsInput | $Enums.ClientRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientEntityUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYears?: EntityTaxYearUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYears?: EntityTaxYearUncheckedUpdateManyWithoutClientEntityNestedInput
    folders?: FolderUncheckedUpdateManyWithoutClientEntityNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutClientEntityNestedInput
    clientAcl?: ClientAclUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffPermissions?: ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityNestedInput
    clientStaffAssignments?: ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityNestedInput
  }

  export type ClientEntityUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityName?: StringFieldUpdateOperationsInput | string
    entityType?: EnumEntityTypeFieldUpdateOperationsInput | $Enums.EntityType
    status?: NullableStringFieldUpdateOperationsInput | string | null
    isRestricted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EntityTaxYearCreateManyClientEntityInput = {
    id?: string
    taxYear: number
    taxReturnExpected?: boolean
    inviteStatus?: $Enums.InviteStatus
    inviteSentAt?: Date | string | null
    attemptCount?: number
    lastError?: string | null
    engagementStatus?: $Enums.EngagementStatus
    engagementSignedAt?: Date | string | null
    engagementSigner1Id?: string | null
    engagementSigner2Id?: string | null
    docsRequiredCount?: number
    docsReceivedCount?: number
    checklistCompleteAt?: Date | string | null
    docConfirmationStatus?: $Enums.ConfirmationStatus
    docConfirmationSignedAt?: Date | string | null
    docConfirmationSignerId?: string | null
    questionnaireStatus?: $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: Date | string | null
    idStatus?: $Enums.IdStatus
    idValidUntil?: Date | string | null
    readyForPrep?: boolean
    extensionRequested?: boolean
    extensionFiled?: boolean
    extendedDueDate?: Date | string | null
    internalStatus?: $Enums.InternalStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderCreateManyClientEntityInput = {
    id?: string
    name: string
    parentId?: string | null
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyClientEntityInput = {
    id?: string
    folderId?: string | null
    storagePath: string
    displayName: string
    uploadedBy?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientAclCreateManyClientEntityInput = {
    id?: string
    staffUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffPermissionCreateManyClientEntityInput = {
    id?: string
    staffUserId: string
    canSeeTaxes?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClientStaffAssignmentCreateManyClientEntityInput = {
    id?: string
    staffUserId: string
    roleOnClient: string
    active?: boolean
    assignedBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EntityTaxYearUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    questionnaireAnswers?: QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    messageThread?: MessageThreadUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    reminderState?: ReminderStateUncheckedUpdateOneWithoutEntityTaxYearNestedInput
    statusAuditLogs?: StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    documentEvents?: DocumentEventUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    engagementSignatures?: EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearNestedInput
    efileAuthorizations?: EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearNestedInput
  }

  export type EntityTaxYearUncheckedUpdateManyWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    taxYear?: IntFieldUpdateOperationsInput | number
    taxReturnExpected?: BoolFieldUpdateOperationsInput | boolean
    inviteStatus?: EnumInviteStatusFieldUpdateOperationsInput | $Enums.InviteStatus
    inviteSentAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    attemptCount?: IntFieldUpdateOperationsInput | number
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    engagementStatus?: EnumEngagementStatusFieldUpdateOperationsInput | $Enums.EngagementStatus
    engagementSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    engagementSigner1Id?: NullableStringFieldUpdateOperationsInput | string | null
    engagementSigner2Id?: NullableStringFieldUpdateOperationsInput | string | null
    docsRequiredCount?: IntFieldUpdateOperationsInput | number
    docsReceivedCount?: IntFieldUpdateOperationsInput | number
    checklistCompleteAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationStatus?: EnumConfirmationStatusFieldUpdateOperationsInput | $Enums.ConfirmationStatus
    docConfirmationSignedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    docConfirmationSignerId?: NullableStringFieldUpdateOperationsInput | string | null
    questionnaireStatus?: EnumQuestionnaireStatusFieldUpdateOperationsInput | $Enums.QuestionnaireStatus
    questionnaireCompletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    idStatus?: EnumIdStatusFieldUpdateOperationsInput | $Enums.IdStatus
    idValidUntil?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    readyForPrep?: BoolFieldUpdateOperationsInput | boolean
    extensionRequested?: BoolFieldUpdateOperationsInput | boolean
    extensionFiled?: BoolFieldUpdateOperationsInput | boolean
    extendedDueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    internalStatus?: EnumInternalStatusFieldUpdateOperationsInput | $Enums.InternalStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: FolderUpdateOneWithoutChildrenNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
    folderAcl?: FolderAclUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    folder?: FolderUpdateOneWithoutDocumentsNestedInput
    uploader?: StaffProfileUpdateOneWithoutUploadedDocumentsNestedInput
    checklistItems?: ChecklistItemFileUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemFileUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    folderId?: NullableStringFieldUpdateOperationsInput | string | null
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAclUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffProfileUpdateOneRequiredWithoutClientAclNestedInput
  }

  export type ClientAclUncheckedUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientAclUncheckedUpdateManyWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffPermissionUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffProfileUpdateOneRequiredWithoutClientStaffPermissionsNestedInput
  }

  export type ClientStaffPermissionUncheckedUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffPermissionUncheckedUpdateManyWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    canSeeTaxes?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffAssignmentUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffProfileUpdateOneRequiredWithoutClientStaffAssignmentsNestedInput
  }

  export type ClientStaffAssignmentUncheckedUpdateWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClientStaffAssignmentUncheckedUpdateManyWithoutClientEntityInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    roleOnClient?: StringFieldUpdateOperationsInput | string
    active?: BoolFieldUpdateOperationsInput | boolean
    assignedBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemCreateManyEntityTaxYearInput = {
    id?: string
    itemName: string
    itemType?: string | null
    required?: boolean
    status?: $Enums.ChecklistItemStatus
    receivedAt?: Date | string | null
    markedNotApplicableAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireAnswerCreateManyEntityTaxYearInput = {
    id?: string
    questionId: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StatusAuditLogCreateManyEntityTaxYearInput = {
    id?: string
    oldStatus?: string | null
    newStatus: string
    changedBy: string
    reason?: string | null
    createdAt?: Date | string
  }

  export type DocumentEventCreateManyEntityTaxYearInput = {
    id?: string
    eventType: $Enums.DocumentEventType
    documentId?: string | null
    description?: string | null
    metadata?: string | null
    createdAt?: Date | string
  }

  export type EngagementSignatureCreateManyEntityTaxYearInput = {
    id?: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type EfileAuthorizationCreateManyEntityTaxYearInput = {
    id?: string
    signerName: string
    signerEmail: string
    signatureData: string
    signedAt?: Date | string
  }

  export type ChecklistItemUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ChecklistItemFileUpdateManyWithoutChecklistItemNestedInput
  }

  export type ChecklistItemUncheckedUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ChecklistItemFileUncheckedUpdateManyWithoutChecklistItemNestedInput
  }

  export type ChecklistItemUncheckedUpdateManyWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemName?: StringFieldUpdateOperationsInput | string
    itemType?: NullableStringFieldUpdateOperationsInput | string | null
    required?: BoolFieldUpdateOperationsInput | boolean
    status?: EnumChecklistItemStatusFieldUpdateOperationsInput | $Enums.ChecklistItemStatus
    receivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    markedNotApplicableAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireAnswerUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    question?: QuestionnaireQuestionUpdateOneRequiredWithoutAnswersNestedInput
  }

  export type QuestionnaireAnswerUncheckedUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireAnswerUncheckedUpdateManyWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionId?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAuditLogUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffProfileUpdateOneRequiredWithoutStatusAuditLogsNestedInput
  }

  export type StatusAuditLogUncheckedUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StatusAuditLogUncheckedUpdateManyWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    oldStatus?: NullableStringFieldUpdateOperationsInput | string | null
    newStatus?: StringFieldUpdateOperationsInput | string
    changedBy?: StringFieldUpdateOperationsInput | string
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentEventUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumDocumentEventTypeFieldUpdateOperationsInput | $Enums.DocumentEventType
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentEventUncheckedUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumDocumentEventTypeFieldUpdateOperationsInput | $Enums.DocumentEventType
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentEventUncheckedUpdateManyWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: EnumDocumentEventTypeFieldUpdateOperationsInput | $Enums.DocumentEventType
    documentId?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementSignatureUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementSignatureUncheckedUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EngagementSignatureUncheckedUpdateManyWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EfileAuthorizationUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EfileAuthorizationUncheckedUpdateWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EfileAuthorizationUncheckedUpdateManyWithoutEntityTaxYearInput = {
    id?: StringFieldUpdateOperationsInput | string
    signerName?: StringFieldUpdateOperationsInput | string
    signerEmail?: StringFieldUpdateOperationsInput | string
    signatureData?: StringFieldUpdateOperationsInput | string
    signedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderCreateManyParentInput = {
    id?: string
    clientId: string
    name: string
    folderType?: string | null
    isSystem?: boolean
    clientVisible?: boolean
    staffOnly?: boolean
    adminOnly?: boolean
    superAdminOnly?: boolean
    restrictedAcl?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DocumentCreateManyFolderInput = {
    id?: string
    clientId: string
    storagePath: string
    displayName: string
    uploadedBy?: string | null
    fileSize?: number | null
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderAclCreateManyFolderInput = {
    id?: string
    staffUserId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FolderUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutFoldersNestedInput
    children?: FolderUpdateManyWithoutParentNestedInput
    documents?: DocumentUpdateManyWithoutFolderNestedInput
    folderAcl?: FolderAclUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: FolderUncheckedUpdateManyWithoutParentNestedInput
    documents?: DocumentUncheckedUpdateManyWithoutFolderNestedInput
    folderAcl?: FolderAclUncheckedUpdateManyWithoutFolderNestedInput
  }

  export type FolderUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    folderType?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    clientVisible?: BoolFieldUpdateOperationsInput | boolean
    staffOnly?: BoolFieldUpdateOperationsInput | boolean
    adminOnly?: BoolFieldUpdateOperationsInput | boolean
    superAdminOnly?: BoolFieldUpdateOperationsInput | boolean
    restrictedAcl?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clientEntity?: ClientEntityUpdateOneRequiredWithoutDocumentsNestedInput
    uploader?: StaffProfileUpdateOneWithoutUploadedDocumentsNestedInput
    checklistItems?: ChecklistItemFileUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItems?: ChecklistItemFileUncheckedUpdateManyWithoutDocumentNestedInput
  }

  export type DocumentUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    clientId?: StringFieldUpdateOperationsInput | string
    storagePath?: StringFieldUpdateOperationsInput | string
    displayName?: StringFieldUpdateOperationsInput | string
    uploadedBy?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderAclUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffProfileUpdateOneRequiredWithoutFolderAclNestedInput
  }

  export type FolderAclUncheckedUpdateWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FolderAclUncheckedUpdateManyWithoutFolderInput = {
    id?: StringFieldUpdateOperationsInput | string
    staffUserId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemFileCreateManyDocumentInput = {
    id?: string
    checklistItemId: string
    createdAt?: Date | string
  }

  export type ChecklistItemFileUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklistItem?: ChecklistItemUpdateOneRequiredWithoutFilesNestedInput
  }

  export type ChecklistItemFileUncheckedUpdateWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklistItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemFileUncheckedUpdateManyWithoutDocumentInput = {
    id?: StringFieldUpdateOperationsInput | string
    checklistItemId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemFileCreateManyChecklistItemInput = {
    id?: string
    documentId: string
    createdAt?: Date | string
  }

  export type ChecklistItemFileUpdateWithoutChecklistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    document?: DocumentUpdateOneRequiredWithoutChecklistItemsNestedInput
  }

  export type ChecklistItemFileUncheckedUpdateWithoutChecklistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChecklistItemFileUncheckedUpdateManyWithoutChecklistItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireQuestionCreateManySectionInput = {
    id?: string
    questionText: string
    questionType: $Enums.QuestionType
    required?: boolean
    order?: number
    conditionalLogic?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireQuestionUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: QuestionnaireAnswerUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionnaireQuestionUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    answers?: QuestionnaireAnswerUncheckedUpdateManyWithoutQuestionNestedInput
  }

  export type QuestionnaireQuestionUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    questionText?: StringFieldUpdateOperationsInput | string
    questionType?: EnumQuestionTypeFieldUpdateOperationsInput | $Enums.QuestionType
    required?: BoolFieldUpdateOperationsInput | boolean
    order?: IntFieldUpdateOperationsInput | number
    conditionalLogic?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireAnswerCreateManyQuestionInput = {
    id?: string
    entityTaxYearId: string
    answerValue?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type QuestionnaireAnswerUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    entityTaxYear?: EntityTaxYearUpdateOneRequiredWithoutQuestionnaireAnswersNestedInput
  }

  export type QuestionnaireAnswerUncheckedUpdateWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type QuestionnaireAnswerUncheckedUpdateManyWithoutQuestionInput = {
    id?: StringFieldUpdateOperationsInput | string
    entityTaxYearId?: StringFieldUpdateOperationsInput | string
    answerValue?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreadParticipantCreateManyThreadInput = {
    id?: string
    userId: string
    userType: $Enums.UserType
    createdAt?: Date | string
  }

  export type MessageCreateManyThreadInput = {
    id?: string
    senderId: string
    senderType: $Enums.UserType
    content: string
    read?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ThreadParticipantUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    staff?: StaffProfileUpdateOneWithoutAssignedThreadsNestedInput
  }

  export type ThreadParticipantUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ThreadParticipantUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    userType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: StaffProfileUpdateOneWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUncheckedUpdateManyWithoutThreadInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    senderType?: EnumUserTypeFieldUpdateOperationsInput | $Enums.UserType
    content?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}